# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `opal` gem.
# Please instead update this file by running `bin/tapioca gem opal`.


module AST; end
class AST::Processor; end

# source://opal//lib/opal/parser/patch.rb#136
module AST::Processor::Mixin
  # source://ast/2.4.2/lib/ast/processor/mixin.rb#284
  def handler_missing(node); end

  # This patch to #process removes a bit of dynamic abilities (removed
  # call to node.to_ast) and it tries to optimize away the string
  # operations and method existence check by caching them inside a
  # processor.
  #
  # This is the second most inefficient call in the compilation phase
  # so an optimization may be warranted.
  #
  # source://opal//lib/opal/parser/patch.rb#145
  def process(node); end

  # source://ast/2.4.2/lib/ast/processor/mixin.rb#274
  def process_all(nodes); end
end

# source://opal//lib/opal/config.rb#5
module Opal
  extend ::Opal::UseGem
  extend ::Opal::Deprecations

  class << self
    # source://opal//lib/opal/errors.rb#41
    def add_opal_location_to_error(opal_location, error); end

    # Add a file path to opals load path. Any gem containing ruby code that Opal
    # has access to should add a load path through this method. Load paths added
    # here should only be paths which contain code targeted at being compiled by
    # Opal.
    #
    # source://opal//lib/opal/paths.rb#23
    def append_path(path); end

    # Same as #append_path but can take multiple paths.
    #
    # source://opal//lib/opal/paths.rb#28
    def append_paths(*paths); end

    # source://opal//lib/opal/builder_scheduler.rb#14
    def builder_scheduler; end

    # source://opal//lib/opal/builder_scheduler.rb#14
    def builder_scheduler=(_arg0); end

    # source://opal//lib/opal/cache.rb#15
    def cache; end

    # source://opal//lib/opal/cache.rb#13
    def cache=(_arg0); end

    # Compile a string of ruby code into javascript.
    #
    # @example
    #
    #   Opal.compile "ruby_code"
    #   # => "string of javascript code"
    # @param source [String] ruby source
    # @param options [Hash] compiler options
    # @return [String] javascript code
    # @see Opal::Compiler.new for compiler options
    #
    # source://opal//lib/opal/compiler.rb#30
    def compile(source, options = T.unsafe(nil)); end

    # source://opal//lib/opal/paths.rb#10
    def core_dir; end

    # All files that Opal depends on while compiling (for cache keying and
    # watching)
    #
    # source://opal//lib/opal/paths.rb#35
    def dependent_files; end

    # We use this file from inside Opal as well, and __dir__ is not yet supported.
    #
    # source://opal//lib/opal/paths.rb#6
    def gem_dir; end

    # source://opal//lib/opal/errors.rb#34
    def opal_location_from_error(error); end

    # source://opal//lib/opal/paths.rb#86
    def paths; end

    # Resets Opal.paths to the default value
    # (includes `corelib`, `stdlib`, `opal/lib`, `ast` gem and `parser` gem)
    #
    # source://opal//lib/opal/paths.rb#92
    def reset_paths!; end

    # source://opal//lib/opal/paths.rb#14
    def std_dir; end
  end
end

# source://opal//lib/opal/ast/node.rb#7
module Opal::AST; end

# source://opal//lib/opal/ast/builder.rb#8
class Opal::AST::Builder < ::Parser::Builders::Default
  # source://opal//lib/opal/ast/builder.rb#11
  def n(type, children, location); end
end

# source://opal//lib/opal/ast/matcher.rb#8
class Opal::AST::Matcher
  # @return [Matcher] a new instance of Matcher
  #
  # source://opal//lib/opal/ast/matcher.rb#9
  def initialize(&block); end

  # source://opal//lib/opal/ast/matcher.rb#17
  def cap(capture); end

  # Returns the value of attribute captures.
  #
  # source://opal//lib/opal/ast/matcher.rb#31
  def captures; end

  # Sets the attribute captures
  #
  # @param value the value to set the attribute captures to.
  #
  # source://opal//lib/opal/ast/matcher.rb#31
  def captures=(_arg0); end

  # source://opal//lib/opal/ast/matcher.rb#27
  def inspect; end

  # source://opal//lib/opal/ast/matcher.rb#21
  def match(ast); end

  # source://opal//lib/opal/ast/matcher.rb#13
  def s(type, *children); end
end

# source://opal//lib/opal/ast/matcher.rb#33
class Opal::AST::Matcher::Node < ::Struct
  # Returns the value of attribute children
  #
  # @return [Object] the current value of children
  def children; end

  # Sets the attribute children
  #
  # @param value [Object] the value to set the attribute children to.
  # @return [Object] the newly set value
  def children=(_); end

  # source://opal//lib/opal/ast/matcher.rb#67
  def inspect; end

  # source://opal//lib/opal/ast/matcher.rb#34
  def match(ast, matcher); end

  # Returns the value of attribute type
  #
  # @return [Object] the current value of type
  def type; end

  # Sets the attribute type
  #
  # @param value [Object] the value to set the attribute type to.
  # @return [Object] the newly set value
  def type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://opal//lib/opal/ast/node.rb#8
class Opal::AST::Node < ::Parser::AST::Node
  # source://opal//lib/opal/ast/node.rb#11
  def assign_properties(properties); end

  # source://opal//lib/opal/ast/node.rb#26
  def column; end

  # source://opal//lib/opal/ast/node.rb#22
  def line; end

  # Returns the value of attribute meta.
  #
  # source://opal//lib/opal/ast/node.rb#9
  def meta; end
end

# source://opal//lib/opal/builder.rb#11
class Opal::Builder
  include ::Opal::UseGem

  # @return [Builder] a new instance of Builder
  #
  # source://opal//lib/opal/builder.rb#65
  def initialize(options = T.unsafe(nil)); end

  # source://opal//lib/opal/builder.rb#170
  def already_processed; end

  # source://opal//lib/opal/builder.rb#137
  def append_paths(*paths); end

  # source://opal//lib/opal/builder.rb#91
  def build(path, options = T.unsafe(nil)); end

  # source://opal//lib/opal/builder.rb#112
  def build_require(path, options = T.unsafe(nil)); end

  # source://opal//lib/opal/builder.rb#100
  def build_str(source, rel_path, options = T.unsafe(nil)); end

  # Returns the value of attribute cache.
  #
  # source://opal//lib/opal/builder.rb#178
  def cache; end

  # Sets the attribute cache
  #
  # @param value the value to set the attribute cache to.
  #
  # source://opal//lib/opal/builder.rb#178
  def cache=(_arg0); end

  # Returns the value of attribute compiler_options.
  #
  # source://opal//lib/opal/builder.rb#178
  def compiler_options; end

  # Sets the attribute compiler_options
  #
  # @param value the value to set the attribute compiler_options to.
  #
  # source://opal//lib/opal/builder.rb#178
  def compiler_options=(_arg0); end

  # Return a list of dependent files, for watching purposes
  #
  # source://opal//lib/opal/builder.rb#196
  def dependent_files; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/builder.rb#181
  def esm?; end

  # source://opal//lib/opal/builder.rb#200
  def expand_ext(path); end

  # Returns the value of attribute missing_require_severity.
  #
  # source://opal//lib/opal/builder.rb#178
  def missing_require_severity; end

  # Sets the attribute missing_require_severity
  #
  # @param value the value to set the attribute missing_require_severity to.
  #
  # source://opal//lib/opal/builder.rb#178
  def missing_require_severity=(_arg0); end

  # Output extension, to be used by runners. At least Node.JS switches
  # to ESM mode only if the extension is "mjs"
  #
  # source://opal//lib/opal/builder.rb#187
  def output_extension; end

  # Returns the value of attribute path_reader.
  #
  # source://opal//lib/opal/builder.rb#178
  def path_reader; end

  # Sets the attribute path_reader
  #
  # @param value the value to set the attribute path_reader to.
  #
  # source://opal//lib/opal/builder.rb#178
  def path_reader=(_arg0); end

  # Returns the value of attribute preload.
  #
  # source://opal//lib/opal/builder.rb#178
  def preload; end

  # Sets the attribute preload
  #
  # @param value the value to set the attribute preload to.
  #
  # source://opal//lib/opal/builder.rb#178
  def preload=(_arg0); end

  # Returns the value of attribute prerequired.
  #
  # source://opal//lib/opal/builder.rb#178
  def prerequired; end

  # Sets the attribute prerequired
  #
  # @param value the value to set the attribute prerequired to.
  #
  # source://opal//lib/opal/builder.rb#178
  def prerequired=(_arg0); end

  # source://opal//lib/opal/builder.rb#163
  def process_require(rel_path, autoloads, options); end

  # source://opal//lib/opal/builder.rb#141
  def process_require_threadsafely(rel_path, autoloads, options); end

  # Returns the value of attribute processed.
  #
  # source://opal//lib/opal/builder.rb#176
  def processed; end

  # Returns the value of attribute processors.
  #
  # source://opal//lib/opal/builder.rb#178
  def processors; end

  # Sets the attribute processors
  #
  # @param value the value to set the attribute processors to.
  #
  # source://opal//lib/opal/builder.rb#178
  def processors=(_arg0); end

  # Returns the value of attribute scheduler.
  #
  # source://opal//lib/opal/builder.rb#178
  def scheduler; end

  # Sets the attribute scheduler
  #
  # @param value the value to set the attribute scheduler to.
  #
  # source://opal//lib/opal/builder.rb#178
  def scheduler=(_arg0); end

  # Retrieve the source for a given path the same way #build would do.
  #
  # source://opal//lib/opal/builder.rb#96
  def source_for(path); end

  # source://opal//lib/opal/builder.rb#133
  def source_map; end

  # Returns the value of attribute stubs.
  #
  # source://opal//lib/opal/builder.rb#178
  def stubs; end

  # Sets the attribute stubs
  #
  # @param value the value to set the attribute stubs to.
  #
  # source://opal//lib/opal/builder.rb#178
  def stubs=(_arg0); end

  # source://opal//lib/opal/builder.rb#129
  def to_s; end

  private

  # source://opal//lib/opal/builder.rb#277
  def expand_path(path); end

  # source://opal//lib/opal/builder.rb#286
  def extensions; end

  # source://opal//lib/opal/builder.rb#116
  def initialize_copy(other); end

  # source://opal//lib/opal/builder.rb#215
  def process_requires(rel_path, requires, autoloads, options); end

  # source://opal//lib/opal/builder.rb#238
  def processor_for(source, rel_path, abs_path, autoload, options); end

  # source://opal//lib/opal/builder.rb#255
  def read(path, autoload); end

  # @return [Boolean]
  #
  # source://opal//lib/opal/builder.rb#282
  def stub?(path); end

  # source://opal//lib/opal/builder.rb#219
  def tree_requires(asset, asset_path); end

  class << self
    # source://opal//lib/opal/builder.rb#87
    def build(*args, &block); end

    # All the extensions supported by registered processors
    #
    # source://opal//lib/opal/builder.rb#18
    def extensions; end

    # The registered processors
    #
    # source://opal//lib/opal/builder.rb#13
    def processors; end

    # Register a builder processor and the supported extensions.
    # A processor will respond to:
    #
    # ## `#requires`
    # An array of string containing the logic paths of required assets
    #
    # ## `#required_trees`
    # An array of string containing the logic paths of required directories
    #
    # ## `#autoloads`
    # An array of entities that are autoloaded and their compile-time load failure can
    # be safely ignored
    #
    # ## `#to_s`
    # The processed source
    #
    # ## `#source_map`
    # An instance of `::Opal::SourceMap::File` representing the processd asset's source
    # map.
    #
    # ## `.new(source, filename, compiler_options)`
    # The processor will be instantiated passing:
    # - the unprocessed source
    # - the asset's filename
    # - Opal's compiler options
    #
    # ## `.match?(path)`
    # The processor is able to recognize paths suitable for its type of
    # processing.
    #
    # source://opal//lib/opal/builder.rb#53
    def register_processor(processor, processor_extensions); end
  end
end

# source://opal//lib/opal/builder.rb#59
class Opal::Builder::MissingRequire < ::LoadError; end

# source://opal//lib/opal/builder.rb#62
class Opal::Builder::ProcessorNotFound < ::LoadError; end

# source://opal//lib/opal/builder_processors.rb#7
module Opal::BuilderProcessors; end

# This handler is for files named ".js.erb", which ought to
# first get preprocessed via ERB, then served verbatim as JS.
#
# source://opal//lib/opal/builder_processors.rb#165
class Opal::BuilderProcessors::ERBProcessor < ::Opal::BuilderProcessors::Processor
  # source://opal//lib/opal/builder_processors.rb#168
  def source; end
end

# source://opal//lib/opal/builder_processors.rb#52
class Opal::BuilderProcessors::JsProcessor < ::Opal::BuilderProcessors::Processor
  # source://opal//lib/opal/builder_processors.rb#69
  def source; end

  # source://opal//lib/opal/builder_processors.rb#57
  def source_map; end
end

# source://opal//lib/opal/builder_processors.rb#55
class Opal::BuilderProcessors::JsProcessor::ManualFragment < ::Struct
  # Returns the value of attribute code
  #
  # @return [Object] the current value of code
  def code; end

  # Sets the attribute code
  #
  # @param value [Object] the value to set the attribute code to.
  # @return [Object] the newly set value
  def code=(_); end

  # Returns the value of attribute column
  #
  # @return [Object] the current value of column
  def column; end

  # Sets the attribute column
  #
  # @param value [Object] the value to set the attribute column to.
  # @return [Object] the newly set value
  def column=(_); end

  # Returns the value of attribute line
  #
  # @return [Object] the current value of line
  def line; end

  # Sets the attribute line
  #
  # @param value [Object] the value to set the attribute line to.
  # @return [Object] the newly set value
  def line=(_); end

  # Returns the value of attribute source_map_name
  #
  # @return [Object] the current value of source_map_name
  def source_map_name; end

  # Sets the attribute source_map_name
  #
  # @param value [Object] the value to set the attribute source_map_name to.
  # @return [Object] the newly set value
  def source_map_name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# This handler is for files named ".opalerb", which ought to
# first get compiled to Ruby code using ERB, then with Opal.
# Unlike below processors, OpalERBProcessor can be used to
# compile templates, which will in turn output HTML. Take
# a look at docs/templates.md to understand this subsystem
# better.
#
# source://opal//lib/opal/builder_processors.rb#125
class Opal::BuilderProcessors::OpalERBProcessor < ::Opal::BuilderProcessors::RubyProcessor
  # @return [OpalERBProcessor] a new instance of OpalERBProcessor
  #
  # source://opal//lib/opal/builder_processors.rb#128
  def initialize(*args); end

  # source://opal//lib/opal/builder_processors.rb#133
  def requires; end

  private

  # source://opal//lib/opal/builder_processors.rb#139
  def prepare(source, path); end
end

# source://opal//lib/opal/builder_processors.rb#8
class Opal::BuilderProcessors::Processor
  # @return [Processor] a new instance of Processor
  #
  # source://opal//lib/opal/builder_processors.rb#9
  def initialize(source, filename, abs_path = T.unsafe(nil), options = T.unsafe(nil)); end

  # Returns the value of attribute abs_path.
  #
  # source://opal//lib/opal/builder_processors.rb#19
  def abs_path; end

  # Returns the value of attribute autoloads.
  #
  # source://opal//lib/opal/builder_processors.rb#19
  def autoloads; end

  # Returns the value of attribute filename.
  #
  # source://opal//lib/opal/builder_processors.rb#19
  def filename; end

  # source://opal//lib/opal/builder_processors.rb#47
  def mark_as_required(filename); end

  # Returns the value of attribute options.
  #
  # source://opal//lib/opal/builder_processors.rb#19
  def options; end

  # Returns the value of attribute required_trees.
  #
  # source://opal//lib/opal/builder_processors.rb#19
  def required_trees; end

  # Returns the value of attribute requires.
  #
  # source://opal//lib/opal/builder_processors.rb#19
  def requires; end

  # Returns the value of attribute source.
  #
  # source://opal//lib/opal/builder_processors.rb#19
  def source; end

  # source://opal//lib/opal/builder_processors.rb#21
  def to_s; end

  class << self
    # Returns the value of attribute extensions.
    #
    # source://opal//lib/opal/builder_processors.rb#26
    def extensions; end

    # source://opal//lib/opal/builder_processors.rb#28
    def handles(*extensions); end

    # @return [Boolean]
    #
    # source://opal//lib/opal/builder_processors.rb#38
    def match?(other); end

    # source://opal//lib/opal/builder_processors.rb#42
    def match_regexp; end
  end
end

# This handler is for files named ".rb.erb", which ought to
# first get preprocessed via ERB, then via Opal.
#
# source://opal//lib/opal/builder_processors.rb#146
class Opal::BuilderProcessors::RubyERBProcessor < ::Opal::BuilderProcessors::RubyProcessor
  # source://opal//lib/opal/builder_processors.rb#149
  def compiled; end
end

# source://opal//lib/opal/builder_processors.rb#74
class Opal::BuilderProcessors::RubyProcessor < ::Opal::BuilderProcessors::Processor
  # source://opal//lib/opal/builder_processors.rb#109
  def autoloads; end

  # source://opal//lib/opal/builder_processors.rb#93
  def cache_key; end

  # source://opal//lib/opal/builder_processors.rb#85
  def compiled; end

  # source://opal//lib/opal/builder_processors.rb#97
  def compiler_for(source, options = T.unsafe(nil)); end

  # source://opal//lib/opal/builder_processors.rb#105
  def required_trees; end

  # source://opal//lib/opal/builder_processors.rb#101
  def requires; end

  # source://opal//lib/opal/builder_processors.rb#77
  def source; end

  # source://opal//lib/opal/builder_processors.rb#81
  def source_map; end

  class << self
    # Also catch a files with missing extensions and nil.
    #
    # @return [Boolean]
    #
    # source://opal//lib/opal/builder_processors.rb#114
    def match?(other); end
  end
end

# source://opal//lib/opal/builder_scheduler.rb#6
class Opal::BuilderScheduler
  # @return [BuilderScheduler] a new instance of BuilderScheduler
  #
  # source://opal//lib/opal/builder_scheduler.rb#7
  def initialize(builder); end

  # Returns the value of attribute builder.
  #
  # source://opal//lib/opal/builder_scheduler.rb#11
  def builder; end

  # Sets the attribute builder
  #
  # @param value the value to set the attribute builder to.
  #
  # source://opal//lib/opal/builder_scheduler.rb#11
  def builder=(_arg0); end
end

# source://opal//lib/opal/builder_scheduler/prefork.rb#8
class Opal::BuilderScheduler::Prefork < ::Opal::BuilderScheduler
  # We hook into the process_requires method
  #
  # source://opal//lib/opal/builder_scheduler/prefork.rb#10
  def process_requires(rel_path, requires, autoloads, options); end

  private

  # By default we use 3/4 of CPU threads detected.
  #
  # source://opal//lib/opal/builder_scheduler/prefork.rb#208
  def fork_count; end

  # source://opal//lib/opal/builder_scheduler/prefork.rb#216
  def fork_entrypoint(io); end

  # source://opal//lib/opal/builder_scheduler/prefork.rb#212
  def prefork; end

  # source://opal//lib/opal/builder_scheduler/prefork.rb#245
  def prefork_reactor(rel_path, requires, autoloads, options); end
end

# source://opal//lib/opal/builder_scheduler/prefork.rb#132
class Opal::BuilderScheduler::Prefork::Fork
  # @return [Fork] a new instance of Fork
  #
  # source://opal//lib/opal/builder_scheduler/prefork.rb#133
  def initialize(forkset); end

  # source://opal//lib/opal/builder_scheduler/prefork.rb#159
  def close; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/builder_scheduler/prefork.rb#190
  def eof?; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/builder_scheduler/prefork.rb#178
  def fork?; end

  # source://opal//lib/opal/builder_scheduler/prefork.rb#164
  def goodbye; end

  # source://opal//lib/opal/builder_scheduler/prefork.rb#182
  def read_io; end

  # source://opal//lib/opal/builder_scheduler/prefork.rb#198
  def recv; end

  # source://opal//lib/opal/builder_scheduler/prefork.rb#173
  def recv_message(io); end

  # source://opal//lib/opal/builder_scheduler/prefork.rb#194
  def send(*msg); end

  # source://opal//lib/opal/builder_scheduler/prefork.rb#168
  def send_message(io, msg); end

  # source://opal//lib/opal/builder_scheduler/prefork.rb#202
  def wait; end

  # source://opal//lib/opal/builder_scheduler/prefork.rb#186
  def write_io; end
end

# source://opal//lib/opal/builder_scheduler/prefork.rb#75
class Opal::BuilderScheduler::Prefork::ForkSet < ::Array
  # @return [ForkSet] a new instance of ForkSet
  #
  # source://opal//lib/opal/builder_scheduler/prefork.rb#76
  def initialize(count, &block); end

  # source://opal//lib/opal/builder_scheduler/prefork.rb#123
  def close; end

  # source://opal//lib/opal/builder_scheduler/prefork.rb#115
  def create_fork; end

  # source://opal//lib/opal/builder_scheduler/prefork.rb#119
  def from_io(io, type); end

  # source://opal//lib/opal/builder_scheduler/prefork.rb#84
  def get_events(queue_length); end

  # source://opal//lib/opal/builder_scheduler/prefork.rb#127
  def wait; end
end

# Prefork is not deterministic. This module corrects an order of processed
# files so that it would be exactly the same as if building sequentially.
# While for Ruby files it usually isn't a problem, because the real order
# stems from how `Opal.modules` array is accessed, the JavaScript files
# are executed verbatim and their order may be important. Also, having
# deterministic output is always a good thing.
#
# source://opal//lib/opal/builder_scheduler/prefork.rb#33
module Opal::BuilderScheduler::Prefork::OrderCorrector
  private

  # source://opal//lib/opal/builder_scheduler/prefork.rb#61
  def build_require_order_array(requires, requires_hash, built_for = T.unsafe(nil)); end

  # source://opal//lib/opal/builder_scheduler/prefork.rb#36
  def correct_order(processed, requires, builder); end

  # Expand a requires array, so that the requires filenames will be
  # matching BuilderProcessor#. Builder needs to be passed so that
  # we can access an `expand_ext` function from its context.
  #
  # source://opal//lib/opal/builder_scheduler/prefork.rb#57
  def expand_requires(requires, builder); end

  class << self
    # source://opal//lib/opal/builder_scheduler/prefork.rb#61
    def build_require_order_array(requires, requires_hash, built_for = T.unsafe(nil)); end

    # source://opal//lib/opal/builder_scheduler/prefork.rb#36
    def correct_order(processed, requires, builder); end

    # Expand a requires array, so that the requires filenames will be
    # matching BuilderProcessor#. Builder needs to be passed so that
    # we can access an `expand_ext` function from its context.
    #
    # source://opal//lib/opal/builder_scheduler/prefork.rb#57
    def expand_requires(requires, builder); end
  end
end

# source://opal//lib/opal/regexp_anchors.rb#32
Opal::CONST_NAME_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://opal//lib/opal/cache/file_cache.rb#7
module Opal::Cache
  private

  # source://opal//lib/opal/cache.rb#61
  def digest(string); end

  # source://opal//lib/opal/cache.rb#33
  def fetch(cache, key, &block); end

  # source://opal//lib/opal/cache.rb#49
  def runtime_key; end

  class << self
    # source://opal//lib/opal/cache.rb#61
    def digest(string); end

    # source://opal//lib/opal/cache.rb#33
    def fetch(cache, key, &block); end

    # source://opal//lib/opal/cache.rb#49
    def runtime_key; end
  end
end

# source://opal//lib/opal/cache/file_cache.rb#8
class Opal::Cache::FileCache
  # @return [FileCache] a new instance of FileCache
  #
  # source://opal//lib/opal/cache/file_cache.rb#9
  def initialize(dir: T.unsafe(nil), max_size: T.unsafe(nil)); end

  # source://opal//lib/opal/cache/file_cache.rb#39
  def get(key); end

  # source://opal//lib/opal/cache/file_cache.rb#20
  def set(key, data); end

  private

  # source://opal//lib/opal/cache/file_cache.rb#123
  def cache_filename_for(key); end

  # Remove cache entries that overflow our cache limit... and which
  # were used least recently.
  #
  # source://opal//lib/opal/cache/file_cache.rb#54
  def tidy_up_cache; end

  class << self
    # Check if we can robustly mkdir_p a directory.
    #
    # @return [Boolean]
    #
    # source://opal//lib/opal/cache/file_cache.rb#82
    def dir_writable?(*paths); end

    # source://opal//lib/opal/cache/file_cache.rb#93
    def find_dir; end
  end
end

# source://opal//lib/opal/cache.rb#25
class Opal::Cache::NullCache
  # source://opal//lib/opal/cache.rb#26
  def fetch(*_arg0); end
end

# source://opal//lib/opal/errors.rb#20
class Opal::CompilationError < ::Opal::Error
  # Returns the value of attribute location.
  #
  # source://opal//lib/opal/errors.rb#21
  def location; end

  # Sets the attribute location
  #
  # @param value the value to set the attribute location to.
  #
  # source://opal//lib/opal/errors.rb#21
  def location=(_arg0); end
end

# {Opal::Compiler} is the main class used to compile ruby to javascript code.
# This class uses {Opal::Parser} to gather the sexp syntax tree for the ruby
# code, and then uses {Opal::Node} to step through the sexp to generate valid
# javascript.
#
# @example
#   Opal::Compiler.new("ruby code").compile
#   # => "javascript code"
# @example Accessing result
#   compiler = Opal::Compiler.new("ruby_code")
#   compiler.compile
#   compiler.result # => "javascript code"
# @example Source Maps
#   compiler = Opal::Compiler.new("")
#   compiler.compile
#   compiler.source_map # => #<SourceMap:>
#
# source://opal//lib/opal/compiler.rb#53
class Opal::Compiler
  include ::Opal::Nodes::Closure::CompilerSupport

  # @return [Compiler] a new instance of Compiler
  #
  # source://opal//lib/opal/compiler.rb#281
  def initialize(source, options = T.unsafe(nil)); end

  # adds an arity check to every method definition
  #
  # @return [Boolean]
  #
  # source://opal//lib/opal/compiler.rb#74
  def arity_check?; end

  # Enable async/await support and optionally enable auto-await.
  #
  # Use either true, false, an Array of Symbols, a String containing names
  # to auto-await separated by a comma or a Regexp.
  #
  # Auto-await awaits provided methods by default as if .__await__ was added to
  # them automatically.
  #
  # By default, the support is disabled (set to false).
  #
  # If the config value is not set to false, any calls to #__await__ will be
  # translated to ES8 await keyword which makes the scope return a Promise
  # and a containing scope will be async (instead of a value, it will return
  # a Promise).
  #
  # If the config value is an array, or a String separated by a comma,
  # auto-await is also enabled.
  #
  # A member of this collection can contain a wildcard character * in which
  # case all methods containing a given substring will be awaited.
  #
  # It can be used as a magic comment, examples:
  # ```
  # # await: true
  # # await: *await*
  # # await: *await*, sleep, gets
  #
  # source://opal//lib/opal/compiler.rb#358
  def async_await; end

  # Enable async/await support and optionally enable auto-await.
  #
  # Use either true, false, an Array of Symbols, a String containing names
  # to auto-await separated by a comma or a Regexp.
  #
  # Auto-await awaits provided methods by default as if .__await__ was added to
  # them automatically.
  #
  # By default, the support is disabled (set to false).
  #
  # If the config value is not set to false, any calls to #__await__ will be
  # translated to ES8 await keyword which makes the scope return a Promise
  # and a containing scope will be async (instead of a value, it will return
  # a Promise).
  #
  # If the config value is an array, or a String separated by a comma,
  # auto-await is also enabled.
  #
  # A member of this collection can contain a wildcard character * in which
  # case all methods containing a given substring will be awaited.
  #
  # It can be used as a magic comment, examples:
  # ```
  # # await: true
  # # await: *await*
  # # await: *await*, sleep, gets
  #
  # source://opal//lib/opal/compiler.rb#74
  def async_await_before_typecasting; end

  # source://opal//lib/opal/compiler.rb#377
  def async_await_set_to_regexp(set); end

  # An array of things (requires, trees) which don't need to success in
  # loading compile-time.
  #
  # source://opal//lib/opal/compiler.rb#540
  def autoloads; end

  # Allows use of a backtick operator (and `%x{}``) to embed verbatim JavaScript.
  # If false, backtick operator will
  #
  # source://opal//lib/opal/compiler.rb#74
  def backtick_javascript?; end

  # Warn about impending compatibility break
  #
  # @return [Boolean]
  #
  # source://opal//lib/opal/compiler.rb#198
  def backtick_javascript_or_warn?; end

  # Current case_stmt
  #
  # source://opal//lib/opal/compiler.rb#260
  def case_stmt; end

  # Comments from the source code
  #
  # source://opal//lib/opal/compiler.rb#266
  def comments; end

  # Compile some ruby code to a string.
  #
  # @return [String] javascript code
  #
  # source://opal//lib/opal/compiler.rb#297
  def compile; end

  # Set if some rewritter caused a dynamic cache result, meaning it's not
  # fit to be cached
  #
  # source://opal//lib/opal/compiler.rb#279
  def dynamic_cache_result; end

  # Set if some rewritter caused a dynamic cache result, meaning it's not
  # fit to be cached
  #
  # source://opal//lib/opal/compiler.rb#279
  def dynamic_cache_result=(_arg0); end

  # how to handle dynamic requires (:error, :warning, :ignore)
  #
  # source://opal//lib/opal/compiler.rb#74
  def dynamic_require_severity; end

  # Embeds source code along compiled files
  #
  # source://opal//lib/opal/compiler.rb#74
  def enable_file_source_embed?; end

  # Adds source_location for every method definition
  #
  # source://opal//lib/opal/compiler.rb#74
  def enable_source_location?; end

  # Any content in __END__ special construct
  #
  # source://opal//lib/opal/compiler.rb#263
  def eof_content; end

  # This is called when a parsing/processing error occurs. This
  # method simply appends the filename and curent line number onto
  # the message and raises it.
  #
  # source://opal//lib/opal/compiler.rb#386
  def error(msg, line = T.unsafe(nil)); end

  # Encourage ESM semantics, eg. exporting run result
  #
  # source://opal//lib/opal/compiler.rb#74
  def esm?; end

  # source://opal//lib/opal/compiler.rb#74
  def eval?; end

  # The filename to use for compiling this code. Used for __FILE__ directives
  # as well as finding relative require()
  #
  # @return [String]
  #
  # source://opal//lib/opal/compiler.rb#74
  def file; end

  # source://opal//lib/opal/compiler.rb#423
  def fragment(str, scope, sexp = T.unsafe(nil)); end

  # @return [Array] all [Opal::Fragment] used to produce result
  #
  # source://opal//lib/opal/compiler.rb#251
  def fragments; end

  # stubs out #freeze and #frozen?
  #
  # @deprecated
  # @return [Boolean]
  #
  # source://opal//lib/opal/compiler.rb#74
  def freezing?; end

  # source://opal//lib/opal/compiler.rb#629
  def handle_block_given_call(sexp); end

  # source://opal//lib/opal/compiler.rb#523
  def handlers; end

  # Use the given helper
  #
  # source://opal//lib/opal/compiler.rb#458
  def helper(name); end

  # Any helpers required by this file. Used by {Opal::Nodes::Top} to reference
  # runtime helpers that are needed. These are used to minify resulting
  # javascript by keeping a reference to helpers used.
  #
  # @return [Set<Symbol>]
  #
  # source://opal//lib/opal/compiler.rb#347
  def helpers; end

  # source://opal//lib/opal/compiler.rb#497
  def in_case; end

  # Used when we enter a while statement. This pushes onto the current
  # scope's while stack so we know how to handle break, next etc.
  #
  # source://opal//lib/opal/compiler.rb#489
  def in_while; end

  # Returns true if the parser is curently handling a while sexp,
  # false otherwise.
  #
  # @return [Boolean]
  #
  # source://opal//lib/opal/compiler.rb#507
  def in_while?; end

  # To keep code blocks nicely indented, this will yield a block after
  # adding an extra layer of indent, and then returning the resulting
  # code after reverting the indent.
  #
  # source://opal//lib/opal/compiler.rb#465
  def indent; end

  # are operators compiled inline
  #
  # source://opal//lib/opal/compiler.rb#74
  def inline_operators?; end

  # compile top level local vars with support for irb style vars
  #
  # source://opal//lib/opal/compiler.rb#74
  def irb?; end

  # Instantly load a requirable module
  #
  # source://opal//lib/opal/compiler.rb#74
  def load?; end

  # Magic comment flags extracted from the leading comments
  #
  # source://opal//lib/opal/compiler.rb#272
  def magic_comments; end

  # Marshalling for cache shortpath
  #
  # source://opal//lib/opal/compiler.rb#641
  def marshal_dump; end

  # source://opal//lib/opal/compiler.rb#647
  def marshal_load(src); end

  # Method calls made in this file
  #
  # source://opal//lib/opal/compiler.rb#269
  def method_calls; end

  # adds method stubs for all used methods in file
  #
  # @return [Boolean]
  #
  # source://opal//lib/opal/compiler.rb#74
  def method_missing?; end

  # Don't export this compile, even if ESM mode is enabled. We use
  # this internally in CLI, so that even if ESM output is desired,
  # we would only have one default export.
  #
  # source://opal//lib/opal/compiler.rb#74
  def no_export?; end

  # Fetches and memoizes the value for an option.
  #
  # source://opal//lib/opal/compiler.rb#78
  def option_value(name, config); end

  # source://opal//lib/opal/compiler.rb#306
  def parse; end

  # Adds comments for every method definition
  #
  # source://opal//lib/opal/compiler.rb#74
  def parse_comments?; end

  # Instances of `Scope` can use this to determine the current
  # scope indent. The indent is used to keep generated code easily
  # readable.
  #
  # source://opal//lib/opal/compiler.rb#414
  def parser_indent; end

  # Process the given sexp by creating a node instance, based on its type,
  # and compiling it to fragments.
  #
  # source://opal//lib/opal/compiler.rb#513
  def process(sexp, level = T.unsafe(nil)); end

  # source://opal//lib/opal/compiler.rb#392
  def re_raise_with_location; end

  # source://opal//lib/opal/compiler.rb#353
  def record_method_call(mid); end

  # Prepare the code for future requires
  #
  # source://opal//lib/opal/compiler.rb#74
  def requirable?; end

  # An array of trees required in this file
  # (typically by calling #require_tree)
  #
  # source://opal//lib/opal/compiler.rb#534
  def required_trees; end

  # An array of requires used in this file
  #
  # source://opal//lib/opal/compiler.rb#528
  def requires; end

  # @return [String] The compiled ruby code
  #
  # source://opal//lib/opal/compiler.rb#248
  def result; end

  # The last sexps in method bodies, for example, need to be returned
  # in the compiled javascript. Due to syntax differences between
  # javascript any ruby, some sexps need to be handled specially. For
  # example, `if` statemented cannot be returned in javascript, so
  # instead the "truthy" and "falsy" parts of the if statement both
  # need to be returned instead.
  #
  # Sexps that need to be returned are passed to this method, and the
  # alterned/new sexps are returned and should be used instead. Most
  # sexps can just be added into a `s(:return) sexp`, so that is the
  # default action if no special case is required.
  #
  # source://opal//lib/opal/compiler.rb#555
  def returns(sexp); end

  # Create a new sexp using the given parts.
  #
  # source://opal//lib/opal/compiler.rb#419
  def s(type, *children); end

  # Current scope
  #
  # source://opal//lib/opal/compiler.rb#254
  def scope; end

  # Current scope
  #
  # source://opal//lib/opal/compiler.rb#254
  def scope=(_arg0); end

  # source://opal//lib/opal/compiler.rb#74
  def scope_variables; end

  # Access the source code currently processed
  #
  # source://opal//lib/opal/compiler.rb#275
  def source; end

  # Returns a source map that can be used in the browser to map back to
  # original ruby code.
  #
  # @param source_file [String] optional source_file to reference ruby source
  # @return [Opal::SourceMap]
  #
  # source://opal//lib/opal/compiler.rb#337
  def source_map; end

  # Top scope
  #
  # source://opal//lib/opal/compiler.rb#257
  def top_scope; end

  # Top scope
  #
  # source://opal//lib/opal/compiler.rb#257
  def top_scope=(_arg0); end

  # Used to generate a unique id name per file. These are used
  # mainly to name method bodies for methods that use blocks.
  #
  # source://opal//lib/opal/compiler.rb#429
  def unique_temp(name); end

  # Enables JavaScript's strict mode (i.e., adds 'use strict'; statement)
  #
  # source://opal//lib/opal/compiler.rb#74
  def use_strict?; end

  # This is called when a parsing/processing warning occurs. This
  # method simply appends the filename and curent line number onto
  # the message and issues a warning.
  #
  # source://opal//lib/opal/compiler.rb#407
  def warning(msg, line = T.unsafe(nil)); end

  # Temporary varibales will be needed from time to time in the
  # generated code, and this method will assign (or reuse) on
  # while the block is yielding, and queue it back up once it is
  # finished. Variables are queued once finished with to save the
  # numbers of variables needed at runtime.
  #
  # source://opal//lib/opal/compiler.rb#480
  def with_temp; end

  class << self
    # Defines a compiler option.
    #
    # @option as:
    # @option default:
    # @option magic_comment:
    # @param as: [Hash] a customizable set of options
    # @param default: [Hash] a customizable set of options
    # @param magic_comment: [Hash] a customizable set of options
    #
    # source://opal//lib/opal/compiler.rb#72
    def compiler_option(name, config = T.unsafe(nil)); end

    # source://opal//lib/opal/compiler.rb#63
    def module_name(path); end
  end
end

# All compare method nodes - used to optimize performance of
# math comparisons
#
# source://opal//lib/opal/compiler.rb#61
Opal::Compiler::COMPARE = T.let(T.unsafe(nil), Array)

# Generated code gets indented with two spaces on each scope
#
# source://opal//lib/opal/compiler.rb#57
Opal::Compiler::INDENT = T.let(T.unsafe(nil), String)

# source://opal//lib/opal/config.rb#6
module Opal::Config
  extend ::Opal::Config

  # @return [Hash] the configuration for Opal::Compiler
  #
  # source://opal//lib/opal/config.rb#55
  def compiler_options; end

  # @return [Hash] the current configuration, defaults to #default_config
  #
  # source://opal//lib/opal/config.rb#65
  def config; end

  # @return [Hash] the default configuration
  #
  # source://opal//lib/opal/config.rb#44
  def default_config; end

  # Resets the config to its default value
  #
  # @return [void]
  #
  # source://opal//lib/opal/config.rb#72
  def reset!; end

  private

  # Defines a new configuration option
  #
  # @param name [String] the option name
  # @param default_value [Object] the option's default value
  #
  # source://opal//lib/opal/config.rb#21
  def config_option(name, default_value, options = T.unsafe(nil)); end

  # source://opal//lib/opal/config.rb#11
  def config_options; end

  class << self
    # source://opal//lib/opal/config.rb#30
    def arity_check_enabled; end

    # source://opal//lib/opal/config.rb#31
    def arity_check_enabled=(value); end

    # source://opal//lib/opal/config.rb#30
    def const_missing_enabled; end

    # source://opal//lib/opal/config.rb#31
    def const_missing_enabled=(value); end

    # source://opal//lib/opal/config.rb#30
    def dynamic_require_severity; end

    # source://opal//lib/opal/config.rb#31
    def dynamic_require_severity=(value); end

    # source://opal//lib/opal/config.rb#30
    def enable_file_source_embed; end

    # source://opal//lib/opal/config.rb#31
    def enable_file_source_embed=(value); end

    # source://opal//lib/opal/config.rb#30
    def enable_source_location; end

    # source://opal//lib/opal/config.rb#31
    def enable_source_location=(value); end

    # source://opal//lib/opal/config.rb#30
    def esm; end

    # source://opal//lib/opal/config.rb#31
    def esm=(value); end

    # source://opal//lib/opal/config.rb#30
    def freezing_stubs_enabled; end

    # source://opal//lib/opal/config.rb#31
    def freezing_stubs_enabled=(value); end

    # source://opal//lib/opal/config.rb#30
    def inline_operators_enabled; end

    # source://opal//lib/opal/config.rb#31
    def inline_operators_enabled=(value); end

    # source://opal//lib/opal/config.rb#30
    def irb_enabled; end

    # source://opal//lib/opal/config.rb#31
    def irb_enabled=(value); end

    # source://opal//lib/opal/config.rb#30
    def method_missing_enabled; end

    # source://opal//lib/opal/config.rb#31
    def method_missing_enabled=(value); end

    # source://opal//lib/opal/config.rb#30
    def missing_require_severity; end

    # source://opal//lib/opal/config.rb#31
    def missing_require_severity=(value); end

    # source://opal//lib/opal/config.rb#30
    def source_map_enabled; end

    # source://opal//lib/opal/config.rb#31
    def source_map_enabled=(value); end

    # source://opal//lib/opal/config.rb#30
    def stubbed_files; end

    # source://opal//lib/opal/config.rb#31
    def stubbed_files=(value); end
  end
end

# source://opal//lib/opal/deprecations.rb#4
module Opal::Deprecations
  # source://opal//lib/opal/deprecations.rb#7
  def deprecation(message); end

  # Returns the value of attribute raise_on_deprecation.
  #
  # source://opal//lib/opal/deprecations.rb#5
  def raise_on_deprecation; end

  # Sets the attribute raise_on_deprecation
  #
  # @param value the value to set the attribute raise_on_deprecation to.
  #
  # source://opal//lib/opal/deprecations.rb#5
  def raise_on_deprecation=(_arg0); end
end

# source://opal//lib/opal/erb.rb#6
module Opal::ERB
  class << self
    # Compile ERB code into javascript.
    #
    # [Opal::ERB] can be used to compile [ERB] templates into javascript code.
    # This module uses the [Opal::Compiler] internally.
    #
    # Compiled templates, when run in a javascript environment, will appear
    # under the `Template` namespace, and can be accessed as:
    #
    #     Template['template_name'] # => template instance
    #
    # @example
    #
    #   source = "<div><%= @content %></div>"
    #
    #   Opal::ERB.compile source, "my_template.erb"
    # @param source [String] erb content
    # @param file_name [String] filename for reference in template
    # @return [String] javascript code
    #
    # source://opal//lib/opal/erb.rb#27
    def compile(source, file_name = T.unsafe(nil)); end
  end
end

# source://opal//lib/opal/erb.rb#31
class Opal::ERB::Compiler
  # @return [Compiler] a new instance of Compiler
  #
  # source://opal//lib/opal/erb.rb#34
  def initialize(source, file_name = T.unsafe(nil)); end

  # source://opal//lib/opal/erb.rb#50
  def compile; end

  # source://opal//lib/opal/erb.rb#74
  def find_code(result); end

  # source://opal//lib/opal/erb.rb#62
  def find_contents(result); end

  # source://opal//lib/opal/erb.rb#54
  def fix_quotes(result); end

  # source://opal//lib/opal/erb.rb#38
  def prepared_source; end

  # source://opal//lib/opal/erb.rb#58
  def require_erb(result); end

  # source://opal//lib/opal/erb.rb#81
  def wrap_compiled(result); end
end

# source://opal//lib/opal/erb.rb#32
Opal::ERB::Compiler::BLOCK_EXPR = T.let(T.unsafe(nil), Regexp)

# source://opal//lib/opal/eof_content.rb#4
class Opal::EofContent
  # @return [EofContent] a new instance of EofContent
  #
  # source://opal//lib/opal/eof_content.rb#7
  def initialize(tokens, source); end

  # source://opal//lib/opal/eof_content.rb#12
  def eof; end

  private

  # source://opal//lib/opal/eof_content.rb#33
  def last_token_position; end
end

# source://opal//lib/opal/eof_content.rb#5
Opal::EofContent::DATA_SEPARATOR = T.let(T.unsafe(nil), String)

# Generic Opal error
#
# source://opal//lib/opal/errors.rb#5
class Opal::Error < ::StandardError; end

# source://opal//lib/opal/regexp_anchors.rb#31
Opal::FORBIDDEN_CONST_NAME_CHARS = T.let(T.unsafe(nil), String)

# source://opal//lib/opal/regexp_anchors.rb#26
Opal::FORBIDDEN_ENDING_IDENTIFIER_CHARS = T.let(T.unsafe(nil), String)

# source://opal//lib/opal/regexp_anchors.rb#14
Opal::FORBIDDEN_STARTING_IDENTIFIER_CHARS = T.let(T.unsafe(nil), String)

# A fragment holds a string of generated javascript that will be written
# to the destination. It also keeps hold of the original sexp from which
# it was generated. Using this sexp, when writing fragments in order, a
# mapping can be created of the original location => target location,
# aka, source-maps!
#
# These are generated by nodes, so will not have to create directly.
#
# source://opal//lib/opal/fragment.rb#11
class Opal::Fragment
  # Create fragment with javascript code and optional original [Opal::Sexp].
  #
  # @param code [String] javascript code
  # @param sexp [Opal::Sexp] sexp used for creating fragment
  # @return [Fragment] a new instance of Fragment
  #
  # source://opal//lib/opal/fragment.rb#20
  def initialize(code, scope, sexp = T.unsafe(nil)); end

  # String of javascript this fragment holds
  #
  # @return [String]
  #
  # source://opal//lib/opal/fragment.rb#14
  def code; end

  # Original column this fragment was created from
  #
  # @return [Integer, nil]
  #
  # source://opal//lib/opal/fragment.rb#127
  def column; end

  # Inspect the contents of this fragment, f("fooo")
  #
  # source://opal//lib/opal/fragment.rb#27
  def inspect; end

  # Original line this fragment was created from
  #
  # @return [Integer, nil]
  #
  # source://opal//lib/opal/fragment.rb#121
  def line; end

  # source://opal//lib/opal/fragment.rb#95
  def location; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/fragment.rb#131
  def skip_source_map?; end

  # source://opal//lib/opal/fragment.rb#89
  def source_map_name; end

  # source://opal//lib/opal/fragment.rb#31
  def source_map_name_for(sexp); end
end

# raised if Gem not found in Opal#use_gem
#
# source://opal//lib/opal/errors.rb#9
class Opal::GemNotFound < ::Opal::Error
  # @param gem_name [String] name of gem that not found
  # @return [GemNotFound] a new instance of GemNotFound
  #
  # source://opal//lib/opal/errors.rb#14
  def initialize(gem_name); end

  # name of gem that not found
  #
  # source://opal//lib/opal/errors.rb#11
  def gem_name; end
end

# Taken from hike v1.2.3
#
# source://opal//lib/opal/hike.rb#28
module Opal::Hike; end

# `Index` is an internal cached variant of `Trail`. It assumes the
# file system does not change between `find` calls. All `stat` and
# `entries` calls are cached for the lifetime of the `Index` object.
#
# source://opal//lib/opal/hike.rb#32
class Opal::Hike::Index
  # `Index.new` is an internal method. Instead of constructing it
  # directly, create a `Trail` and call `Trail#index`.
  #
  # @return [Index] a new instance of Index
  #
  # source://opal//lib/opal/hike.rb#41
  def initialize(root, paths, extensions); end

  # A cached version of `Dir.entries` that filters out `.` files and
  # `~` swap files. Returns an empty `Array` if the directory does
  # not exist.
  #
  # source://opal//lib/opal/hike.rb#86
  def entries(path); end

  # `Index#extensions` is an immutable collection of extensions.
  #
  # source://opal//lib/opal/hike.rb#37
  def extensions; end

  # The real implementation of `find`. `Trail#find` generates a one
  # time index and delegates here.
  #
  # See `Trail#find` for usage.
  #
  # source://opal//lib/opal/hike.rb#70
  def find(logical_path); end

  # `Index#index` returns `self` to be compatable with the `Trail` interface.
  #
  # source://opal//lib/opal/hike.rb#62
  def index; end

  # `Index#paths` is an immutable collection of `Pathname`s.
  #
  # source://opal//lib/opal/hike.rb#34
  def paths; end

  # `Index#root` returns root path as a `String`. This attribute is immutable.
  #
  # source://opal//lib/opal/hike.rb#57
  def root; end

  # A cached version of `File.stat`. Returns nil if the file does
  # not exist.
  #
  # source://opal//lib/opal/hike.rb#99
  def stat(path); end

  protected

  # Returns a `Regexp` that matches the allowed extensions.
  #
  #     pattern_for("index.html") #=> /^index(.html|.htm)(.builder|.erb)*$/
  #
  # source://opal//lib/opal/hike.rb#167
  def build_pattern_for(basename); end

  # source://opal//lib/opal/hike.rb#112
  def extract_options!(arguments); end

  # Finds relative logical path, `../test/test_trail`. Requires a
  # `base_path` for reference.
  #
  # source://opal//lib/opal/hike.rb#126
  def find_in_base_path(logical_path, base_path, &block); end

  # Finds logical path across all `paths`
  #
  # source://opal//lib/opal/hike.rb#117
  def find_in_paths(logical_path, &block); end

  # Checks if the path is actually on the file system and performs
  # any syscalls if necessary.
  #
  # source://opal//lib/opal/hike.rb#134
  def match(dirname, basename); end

  # Returns true if `dirname` is a subdirectory of any of the `paths`
  #
  # @return [Boolean]
  #
  # source://opal//lib/opal/hike.rb#155
  def paths_contain?(dirname); end

  # Cache results of `build_pattern_for`
  #
  # source://opal//lib/opal/hike.rb#160
  def pattern_for(basename); end

  # Sorts candidate matches by their extension
  # priority. Extensions in the front of the `extensions` carry
  # more weight.
  #
  # source://opal//lib/opal/hike.rb#175
  def sort_matches(matches, basename); end
end

# `Trail` is the public container class for holding paths and extensions.
#
# source://opal//lib/opal/hike.rb#191
class Opal::Hike::Trail
  # A Trail accepts an optional root path that defaults to your
  # current working directory. Any relative paths added to
  # `Trail#paths` will expanded relative to the root.
  #
  # @return [Trail] a new instance of Trail
  #
  # source://opal//lib/opal/hike.rb#217
  def initialize(root = T.unsafe(nil)); end

  # Append `extension` to `Extensions` collection
  #
  # source://opal//lib/opal/hike.rb#234
  def append_extensions(*extensions); end

  # Append `path` to `Paths` collection
  #
  # source://opal//lib/opal/hike.rb#229
  def append_paths(*paths); end

  # `Trail#entries` is equivalent to `Dir#entries`. It is not
  # recommend to use this method for general purposes. It exists for
  # parity with `Index#entries`.
  #
  # source://opal//lib/opal/hike.rb#272
  def entries(path); end

  # `Trail#extensions` is a mutable `Extensions` collection.
  #
  #     trail = Hike::Trail.new
  #     trail.paths.push "~/Projects/hike/lib"
  #     trail.extensions.push ".rb"
  #
  # Extensions allow you to find files by just their name omitting
  # their extension. Is similar to Ruby's require mechanism that
  # allows you to require files with specifiying `foo.rb`.
  #
  # source://opal//lib/opal/hike.rb#212
  def extensions; end

  # `Trail#find` returns a the expand path for a logical path in the
  # path collection.
  #
  #     trail = Hike::Trail.new "~/Projects/hike"
  #     trail.extensions.push ".rb"
  #     trail.paths.push "lib", "test"
  #
  #     trail.find "hike/trail"
  #     # => "~/Projects/hike/lib/hike/trail.rb"
  #
  #     trail.find "test_trail"
  #     # => "~/Projects/hike/test/test_trail.rb"
  #
  # source://opal//lib/opal/hike.rb#251
  def find(*args, &block); end

  # `Trail#index` returns an `Index` object that has the same
  # interface as `Trail`. An `Index` is a cached `Trail` object that
  # does not update when the file system changes. If you are
  # confident that you are not making changes the paths you are
  # searching, `index` will avoid excess system calls.
  #
  #     index = trail.index
  #     index.find "hike/trail"
  #     index.find "test_trail"
  #
  # source://opal//lib/opal/hike.rb#265
  def index; end

  # `Trail#paths` is a mutable `Paths` collection.
  #
  #     trail = Hike::Trail.new
  #     trail.paths.push "~/Projects/hike/lib", "~/Projects/hike/test"
  #
  # The order of the paths is significant. Paths in the beginning of
  # the collection will be checked first. In the example above,
  # `~/Projects/hike/lib/hike.rb` would shadow the existent of
  # `~/Projects/hike/test/hike.rb`.
  #
  # source://opal//lib/opal/hike.rb#201
  def paths; end

  # `Trail#root` returns root path as a `String`. This attribute is immutable.
  #
  # source://opal//lib/opal/hike.rb#224
  def root; end

  # `Trail#stat` is equivalent to `File#stat`. It is not
  # recommend to use this method for general purposes. It exists for
  # parity with `Index#stat`.
  #
  # source://opal//lib/opal/hike.rb#284
  def stat(path); end

  private

  # source://opal//lib/opal/hike.rb#294
  def normalize_extension(ext); end

  # source://opal//lib/opal/hike.rb#298
  def normalize_path(path); end
end

# source://opal//lib/opal/regexp_anchors.rb#27
Opal::INLINE_IDENTIFIER_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://opal//lib/opal/magic_comments.rb#3
module Opal::MagicComments
  class << self
    # source://opal//lib/opal/magic_comments.rb#7
    def parse(sexp, comments); end
  end
end

# source://opal//lib/opal/magic_comments.rb#5
Opal::MagicComments::EMACS_MAGIC_COMMENT_RE = T.let(T.unsafe(nil), Regexp)

# source://opal//lib/opal/magic_comments.rb#4
Opal::MagicComments::MAGIC_COMMENT_RE = T.let(T.unsafe(nil), Regexp)

# source://opal//lib/opal/nodes/closure.rb#4
module Opal::Nodes; end

# source://opal//lib/opal/nodes/definitions.rb#19
class Opal::Nodes::AliasNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/definitions.rb#24
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def new_name; end

  # source://opal//lib/opal/nodes/base.rb#24
  def old_name; end
end

# FIXME: needs rewrite
#
# source://opal//lib/opal/nodes/arglist.rb#8
class Opal::Nodes::ArglistNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/arglist.rb#11
  def compile; end
end

# source://opal//lib/opal/nodes/args/arg.rb#7
module Opal::Nodes::Args; end

# Compiles a single inline required argument
# def m(a); end
#       ^
#
# source://opal//lib/opal/nodes/args/arg.rb#11
class Opal::Nodes::Args::ArgNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/args/arg.rb#15
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def name; end
end

# A utility node responsible for compiling
# a runtime validation for kwargs.
#
# This node is used for both inline and post-kwargs
#
# source://opal//lib/opal/nodes/args/ensure_kwargs_are_kwargs.rb#13
class Opal::Nodes::Args::EnsureKwargsAreKwargs < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/args/ensure_kwargs_are_kwargs.rb#16
  def compile; end
end

# Compiles extraction of the block argument
# def m(&block); end
#       ^^^^^^
#
# This node doesn't exist in the original AST,
# InlineArgs rewriter creates it to simplify compilation
#
# source://opal//lib/opal/nodes/args/extract_block_arg.rb#14
class Opal::Nodes::Args::ExtractBlockarg < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/args/extract_block_arg.rb#18
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def name; end
end

# This node is responsible for extracting a single
# required keyword argument from $kwargs
#
# $kwargs always exist (as argument when inlining is possible
# and as a local variable when it's not)
#
# source://opal//lib/opal/nodes/args/extract_kwarg.rb#14
class Opal::Nodes::Args::ExtractKwarg < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/args/extract_kwarg.rb#18
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def lvar_name; end
end

# A utility node responsible for extracting
# post-kwargs from post-arguments.
#
# This node is used when kwargs cannot be inlined:
#   def m(a = 1, kw:); end
#
# This node is NOT used when kwargs can be inlined:
#   def m(a, kw:); end
#
# source://opal//lib/opal/nodes/args/extract_kwargs.rb#17
class Opal::Nodes::Args::ExtractKwargs < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/args/extract_kwargs.rb#20
  def compile; end
end

# This node is responsible for extracting a single
# optional keyword argument from $kwargs
#
# $kwargs always exist (as argument when inlining is possible
# and as a local variable when it's not)
#
# source://opal//lib/opal/nodes/args/extract_kwoptarg.rb#14
class Opal::Nodes::Args::ExtractKwoptarg < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/args/extract_kwoptarg.rb#18
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def default_value; end

  # source://opal//lib/opal/nodes/base.rb#24
  def lvar_name; end
end

# This node is responsible for extracting a single
# splat keyword argument from $kwargs
#
# $kwargs always exist (as argument when inlining is possible
# and as a local variable when it's not)
#
# source://opal//lib/opal/nodes/args/extract_kwrestarg.rb#14
class Opal::Nodes::Args::ExtractKwrestarg < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/args/extract_kwrestarg.rb#18
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def name; end

  # source://opal//lib/opal/nodes/args/extract_kwrestarg.rb#30
  def used_kwargs; end
end

# Compiles extraction of a single inline optional argument
# def m(a = 1); end
#       ^^^^^
#
# This node doesn't exist in the original AST,
# InlineArgs rewriter creates it to simplify compilation
#
# Sometimes the argument can't be inlined.
# In such cases InlineArgs rewriter replaces
#   s(:optarg, :arg_name, ...default value...)
# to:
#   s(:fakearg) + s(:extract_post_optarg, :arg_name, ...default value...)
#
# source://opal//lib/opal/nodes/args/extract_optarg.rb#21
class Opal::Nodes::Args::ExtractOptargNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/args/extract_optarg.rb#25
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def default_value; end

  # source://opal//lib/opal/nodes/base.rb#24
  def name; end
end

# This node is responsible for extracting a single
# required post-argument from $post_args
#
# source://opal//lib/opal/nodes/args/extract_post_arg.rb#11
class Opal::Nodes::Args::ExtractPostArg < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/args/extract_post_arg.rb#15
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def name; end
end

# This node is responsible for extracting a single
# optional post-argument
#
# args_to_keep is the number of required post-arguments
#
#   def m(a = 1, b, c, d); end
# becomes something like:
#   if post_args.length > 3
#     a = post_args[0]
#     post_args = post_args[1..-1]
#   end
#
# source://opal//lib/opal/nodes/args/extract_post_optarg.rb#20
class Opal::Nodes::Args::ExtractPostOptarg < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/base.rb#24
  def args_to_keep; end

  # source://opal//lib/opal/nodes/args/extract_post_optarg.rb#24
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def default_value; end

  # source://opal//lib/opal/nodes/base.rb#24
  def name; end
end

# This node is responsible for extracting a splat argument from post-arguments
#
# args_to_keep is the number of required post-arguments
#
#   def m(*a, b, c, d); end
# becomes something like:
#   a = post_args[0..-3]
#   post_args = post_args[-3..-1]
#
# source://opal//lib/opal/nodes/args/extract_restarg.rb#17
class Opal::Nodes::Args::ExtractRestarg < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/base.rb#24
  def args_to_keep; end

  # source://opal//lib/opal/nodes/args/extract_restarg.rb#21
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def name; end
end

# Compiles a fake argument produced by the InlineArgs rewriter.
#
# This argument represents an argument from the
# Ruby code that gets initialized later in the function body.
#
# def m(a = 1, b); end
#              ^
#
# source://opal//lib/opal/nodes/args/fake_arg.rb#15
class Opal::Nodes::Args::FakeArgNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/args/fake_arg.rb#18
  def compile; end
end

# This node is responsible for initializing a single
# required block arg
#
#   proc { |a| }
#
# Procs don't have arity checking and code like
#   proc { |a| }.call
# must return nil
#
# source://opal//lib/opal/nodes/args/initialize_iterarg.rb#16
class Opal::Nodes::Args::InitializeIterarg < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/args/initialize_iterarg.rb#20
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def name; end
end

# This node is responsible for initializing a shadow arg
#
# proc { |;a| }
#
# source://opal//lib/opal/nodes/args/initialize_shadowarg.rb#12
class Opal::Nodes::Args::InitializeShadowarg < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/args/initialize_shadowarg.rb#16
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def name; end
end

# source://opal//lib/opal/nodes/args/parameters.rb#6
class Opal::Nodes::Args::Parameters
  # @return [Parameters] a new instance of Parameters
  #
  # source://opal//lib/opal/nodes/args/parameters.rb#7
  def initialize(args); end

  # source://opal//lib/opal/nodes/args/parameters.rb#19
  def on_arg(arg); end

  # source://opal//lib/opal/nodes/args/parameters.rb#62
  def on_blockarg(arg); end

  # source://opal//lib/opal/nodes/args/parameters.rb#43
  def on_kwarg(arg); end

  # source://opal//lib/opal/nodes/args/parameters.rb#68
  def on_kwnilarg(_arg); end

  # source://opal//lib/opal/nodes/args/parameters.rb#48
  def on_kwoptarg(arg); end

  # source://opal//lib/opal/nodes/args/parameters.rb#53
  def on_kwrestarg(arg); end

  # source://opal//lib/opal/nodes/args/parameters.rb#24
  def on_mlhs(_arg); end

  # source://opal//lib/opal/nodes/args/parameters.rb#28
  def on_optarg(arg); end

  # source://opal//lib/opal/nodes/args/parameters.rb#33
  def on_restarg(arg); end

  # source://opal//lib/opal/nodes/args/parameters.rb#72
  def on_shadowarg(_arg); end

  # source://opal//lib/opal/nodes/args/parameters.rb#11
  def to_code; end
end

# A utility node responsible for preparing
# post-argument for :extract_post_* nodes
#
# source://opal//lib/opal/nodes/args/prepare_post_args.rb#10
class Opal::Nodes::Args::PreparePostArgs < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/args/prepare_post_args.rb#14
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def offset; end
end

# source://opal//lib/opal/nodes/args.rb#25
class Opal::Nodes::ArgsNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/args.rb#28
  def compile; end
end

# source://opal//lib/opal/nodes/args/arity_check.rb#8
class Opal::Nodes::ArityCheckNode < ::Opal::Nodes::Base
  # @return [ArityCheckNode] a new instance of ArityCheckNode
  #
  # source://opal//lib/opal/nodes/args/arity_check.rb#12
  def initialize(*_arg0); end

  # source://opal//lib/opal/nodes/args/arity_check.rb#44
  def all_args; end

  # source://opal//lib/opal/nodes/base.rb#24
  def args_node; end

  # source://opal//lib/opal/nodes/args/arity_check.rb#76
  def arity; end

  # Returns an array of JS conditions for raising and argument
  # error caused by arity check
  #
  # source://opal//lib/opal/nodes/args/arity_check.rb#50
  def arity_checks; end

  # source://opal//lib/opal/nodes/args/arity_check.rb#27
  def compile; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/args/arity_check.rb#109
  def has_only_optional_kwargs?; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/args/arity_check.rb#113
  def has_required_kwargs?; end

  # source://opal//lib/opal/nodes/args/arity_check.rb#40
  def kwargs; end

  # source://opal//lib/opal/nodes/args/arity_check.rb#84
  def negative_arity; end

  # source://opal//lib/opal/nodes/args/arity_check.rb#100
  def positive_arity; end
end

# source://opal//lib/opal/nodes/array.rb#7
class Opal::Nodes::ArrayNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/array.rb#10
  def compile; end
end

# back_ref can be:
# $`
# $'
# $&
# $+ (currently unsupported)
#
# source://opal//lib/opal/nodes/variables.rb#118
class Opal::Nodes::BackRefNode < ::Opal::Nodes::GlobalVariableNode
  # source://opal//lib/opal/nodes/variables.rb#121
  def compile; end

  # source://opal//lib/opal/nodes/variables.rb#138
  def handle_global_match; end

  # source://opal//lib/opal/nodes/variables.rb#150
  def handle_post_match; end

  # source://opal//lib/opal/nodes/variables.rb#144
  def handle_pre_match; end
end

# source://opal//lib/opal/nodes/base.rb#8
class Opal::Nodes::Base
  include ::Opal::Nodes::Helpers
  include ::Opal::Nodes::Closure::NodeSupport

  # @return [Base] a new instance of Base
  #
  # source://opal//lib/opal/nodes/base.rb#36
  def initialize(sexp, level, compiler); end

  # source://opal//lib/opal/nodes/base.rb#143
  def add_gvar(name); end

  # source://opal//lib/opal/nodes/base.rb#139
  def add_ivar(name); end

  # source://opal//lib/opal/nodes/base.rb#135
  def add_local(name); end

  # source://opal//lib/opal/nodes/base.rb#147
  def add_temp(temp); end

  # source://opal//lib/opal/nodes/base.rb#44
  def children; end

  # source://opal//lib/opal/nodes/base.rb#207
  def class_variable_owner; end

  # source://opal//lib/opal/nodes/base.rb#191
  def class_variable_owner_nesting_level; end

  # source://opal//lib/opal/nodes/base.rb#215
  def comments; end

  # source://opal//lib/opal/nodes/base.rb#56
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#48
  def compile_to_fragments; end

  # Returns the value of attribute compiler.
  #
  # source://opal//lib/opal/nodes/base.rb#34
  def compiler; end

  # source://opal//lib/opal/nodes/base.rb#83
  def error(msg); end

  # source://opal//lib/opal/nodes/base.rb#115
  def expr(sexp); end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/base.rb#99
  def expr?; end

  # source://opal//lib/opal/nodes/base.rb#131
  def expr_or_empty(sexp); end

  # source://opal//lib/opal/nodes/base.rb#127
  def expr_or_nil(sexp); end

  # source://opal//lib/opal/nodes/base.rb#79
  def fragment(str, loc: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/base.rb#167
  def has_rescue_else?; end

  # source://opal//lib/opal/nodes/base.rb#151
  def helper(name); end

  # source://opal//lib/opal/nodes/base.rb#171
  def in_ensure(&block); end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/base.rb#175
  def in_ensure?; end

  # source://opal//lib/opal/nodes/base.rb#179
  def in_resbody(&block); end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/base.rb#183
  def in_resbody?; end

  # source://opal//lib/opal/nodes/base.rb#187
  def in_rescue(node, &block); end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/base.rb#159
  def in_while?; end

  # source://opal//lib/opal/nodes/base.rb#111
  def process(sexp, level = T.unsafe(nil)); end

  # source://opal//lib/opal/nodes/base.rb#60
  def push(*strs); end

  # source://opal//lib/opal/nodes/base.rb#119
  def recv(sexp); end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/base.rb#103
  def recv?; end

  # source://opal//lib/opal/nodes/base.rb#95
  def s(type, *children); end

  # source://opal//lib/opal/nodes/base.rb#87
  def scope; end

  # Returns the value of attribute sexp.
  #
  # source://opal//lib/opal/nodes/base.rb#34
  def sexp; end

  # source://opal//lib/opal/nodes/base.rb#219
  def source_location; end

  # source://opal//lib/opal/nodes/base.rb#123
  def stmt(sexp); end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/base.rb#107
  def stmt?; end

  # source://opal//lib/opal/nodes/base.rb#91
  def top_scope; end

  # Returns the value of attribute type.
  #
  # source://opal//lib/opal/nodes/base.rb#34
  def type; end

  # source://opal//lib/opal/nodes/base.rb#67
  def unshift(*strs); end

  # source://opal//lib/opal/nodes/base.rb#163
  def while_loop; end

  # source://opal//lib/opal/nodes/base.rb#155
  def with_temp(&block); end

  # source://opal//lib/opal/nodes/base.rb#74
  def wrap(pre, post); end

  class << self
    # source://opal//lib/opal/nodes/base.rb#22
    def children(*names); end

    # source://opal//lib/opal/nodes/base.rb#16
    def handle(*types); end

    # source://opal//lib/opal/nodes/base.rb#12
    def handlers; end

    # @return [Boolean]
    #
    # source://opal//lib/opal/nodes/base.rb#30
    def truthy_optimize?; end
  end
end

# source://opal//lib/opal/nodes/if.rb#395
class Opal::Nodes::BaseFlipFlop < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/if.rb#398
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def end_condition; end

  # source://opal//lib/opal/nodes/base.rb#24
  def start_condition; end
end

# This base class is used just to child the find_super_dispatcher method
# body. This is then used by actual super calls, or a defined?(super) style
# call.
#
# source://opal//lib/opal/nodes/super.rb#10
class Opal::Nodes::BaseSuperNode < ::Opal::Nodes::CallNode
  # @return [BaseSuperNode] a new instance of BaseSuperNode
  #
  # source://opal//lib/opal/nodes/super.rb#11
  def initialize(*_arg0); end

  # source://opal//lib/opal/nodes/super.rb#27
  def compile_using_send; end

  private

  # source://opal//lib/opal/nodes/super.rb#67
  def allow_stubs; end

  # source://opal//lib/opal/nodes/super.rb#83
  def compile_method_body; end

  # source://opal//lib/opal/nodes/super.rb#94
  def compile_method_name; end

  # Using super in a block inside a method is allowed, e.g.
  # def a
  #  { super }
  # end
  #
  # This method finds returns a closest s(:def) (or s(:defs))
  #
  # source://opal//lib/opal/nodes/super.rb#47
  def def_scope; end

  # source://opal//lib/opal/nodes/super.rb#63
  def def_scope_identity; end

  # source://opal//lib/opal/nodes/super.rb#51
  def defined_check_param; end

  # source://opal//lib/opal/nodes/super.rb#55
  def implicit_arguments_param; end

  # source://opal//lib/opal/nodes/super.rb#59
  def method_id; end

  # source://opal//lib/opal/nodes/super.rb#76
  def super_block_invocation; end

  # source://opal//lib/opal/nodes/super.rb#71
  def super_method_invocation; end
end

# source://opal//lib/opal/nodes/yield.rb#7
class Opal::Nodes::BaseYieldNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/yield.rb#8
  def compile_call; end

  # source://opal//lib/opal/nodes/yield.rb#30
  def find_yielding_scope; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/yield.rb#46
  def uses_splat?(children); end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/yield.rb#42
  def yields_single_arg?(children); end
end

# source://opal//lib/opal/nodes/definitions.rb#43
class Opal::Nodes::BeginNode < ::Opal::Nodes::ScopeNode
  # source://opal//lib/opal/nodes/definitions.rb#46
  def compile; end

  # source://opal//lib/opal/nodes/definitions.rb#80
  def compile_children(children, level); end

  # source://opal//lib/opal/nodes/definitions.rb#94
  def compile_inline_children(children, level); end

  # source://opal//lib/opal/nodes/definitions.rb#69
  def returned_children; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/definitions.rb#88
  def simple_children?; end
end

# source://opal//lib/opal/nodes/definitions.rb#86
Opal::Nodes::BeginNode::COMPLEX_CHILDREN = T.let(T.unsafe(nil), Array)

# source://opal//lib/opal/nodes/logic.rb#128
class Opal::Nodes::BlockPassNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/logic.rb#133
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def value; end
end

# source://opal//lib/opal/nodes/logic.rb#26
class Opal::Nodes::BreakNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/logic.rb#31
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def value; end
end

# source://opal//lib/opal/nodes/call.rb#9
class Opal::Nodes::CallNode < ::Opal::Nodes::Base
  # @return [CallNode] a new instance of CallNode
  #
  # source://opal//lib/opal/nodes/call.rb#25
  def initialize(*_arg0); end

  # Returns the value of attribute arglist.
  #
  # source://opal//lib/opal/nodes/call.rb#12
  def arglist; end

  # source://opal//lib/opal/nodes/call.rb#41
  def compile; end

  # source://opal//lib/opal/nodes/call.rb#368
  def handle___OPAL_COMPILER_CONFIG__; end

  # source://opal//lib/opal/nodes/call.rb#431
  def handle___await__(compile_default); end

  # source://opal//lib/opal/nodes/call.rb#326
  def handle___callee__; end

  # source://opal//lib/opal/nodes/call.rb#342
  def handle___dir__; end

  # source://opal//lib/opal/nodes/call.rb#334
  def handle___method__; end

  # source://opal//lib/opal/nodes/call.rb#293
  def handle_autoload(compile_default); end

  # source://opal//lib/opal/nodes/call.rb#417
  def handle_binding(compile_default); end

  # source://opal//lib/opal/nodes/call.rb#322
  def handle_block_given?; end

  # source://opal//lib/opal/nodes/call.rb#385
  def handle_constants(compile_default); end

  # source://opal//lib/opal/nodes/call.rb#364
  def handle_debugger; end

  # source://opal//lib/opal/nodes/call.rb#394
  def handle_eval(compile_default); end

  # source://opal//lib/opal/nodes/call.rb#372
  def handle_lambda(compile_default); end

  # source://opal//lib/opal/nodes/call.rb#410
  def handle_local_variables(compile_default); end

  # source://opal//lib/opal/nodes/call.rb#378
  def handle_nesting(compile_default); end

  # source://opal//lib/opal/nodes/call.rb#275
  def handle_require(compile_default); end

  # source://opal//lib/opal/nodes/call.rb#281
  def handle_require_relative; end

  # source://opal//lib/opal/nodes/call.rb#307
  def handle_require_tree(compile_default); end

  # source://opal//lib/opal/nodes/call.rb#347
  def handle_using(compile_default); end

  # Returns the value of attribute iter.
  #
  # source://opal//lib/opal/nodes/call.rb#12
  def iter; end

  # Returns the value of attribute meth.
  #
  # source://opal//lib/opal/nodes/call.rb#12
  def meth; end

  # Returns the value of attribute recvr.
  #
  # source://opal//lib/opal/nodes/call.rb#12
  def recvr; end

  private

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/call.rb#237
  def auto_await?; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/call.rb#465
  def call_is_writer_that_needs_handling?; end

  # source://opal//lib/opal/nodes/call.rb#163
  def compile_arguments(skip_comma = T.unsafe(nil)); end

  # source://opal//lib/opal/nodes/call.rb#177
  def compile_block_pass; end

  # source://opal//lib/opal/nodes/call.rb#215
  def compile_eval_var; end

  # Used to generate the code to use this sexp as an ivar var reference
  #
  # source://opal//lib/opal/nodes/call.rb#206
  def compile_irb_var; end

  # source://opal//lib/opal/nodes/call.rb#159
  def compile_method_name; end

  # source://opal//lib/opal/nodes/call.rb#155
  def compile_receiver; end

  # source://opal//lib/opal/nodes/call.rb#183
  def compile_refinements; end

  # source://opal//lib/opal/nodes/call.rb#188
  def compile_simple_call_chain; end

  # Compiles method call using `Opal.refined_send`
  #
  # @example
  #   a.b(c, &block)
  #
  #   Opal.refined_send(a, 'b', [c], block, [[Opal.MyRefinements]])
  #
  # source://opal//lib/opal/nodes/call.rb#143
  def compile_using_refined_send; end

  # Compiles method call using `Opal.send`
  #
  # @example
  #   a.b(c, &block)
  #
  #   Opal.send(a, 'b', [c], block)
  #
  # source://opal//lib/opal/nodes/call.rb#125
  def compile_using_send; end

  # Is it a conditional send, ie. `foo&.bar`?
  #
  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/call.rb#93
  def csend?; end

  # source://opal//lib/opal/nodes/call.rb#97
  def default_compile; end

  # Handle safe-operator calls: foo&.bar / foo&.bar ||= baz / ...
  #
  # source://opal//lib/opal/nodes/call.rb#470
  def handle_conditional_send; end

  # Handle "special" method calls, e.g. require(). Subclasses can override
  # this method. If this method returns nil, then the method will continue
  # to be generated by CallNode.
  #
  # source://opal//lib/opal/nodes/call.rb#246
  def handle_special(&compile_default); end

  # source://opal//lib/opal/nodes/call.rb#482
  def handle_writer; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/call.rb#88
  def invoke_using_refinement?; end

  # Opal has a runtime helper 'Opal.send_method_name' that assigns
  # provided block to a '$$p' property of the method body
  # and invokes a method using 'apply'.
  #
  # We have to compile a method call using this 'Opal.send_method_name' when a method:
  # 1. takes a splat
  # 2. takes a block
  #
  # Arguments that contain splat must be handled in a different way.
  # When a method takes a block we have to calculate all arguments
  # **before** assigning '$$p' property (that stores a passed block)
  # to a method body. This is some kind of protection from method calls
  # like 'a(a {}) { 1 }'.
  #
  # @return [Boolean]
  # @see #compile_arguments
  #
  # source://opal//lib/opal/nodes/call.rb#84
  def invoke_using_send?; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/call.rb#63
  def iter_has_break?; end

  # source://opal//lib/opal/nodes/call.rb#201
  def method_jsid; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/call.rb#442
  def push_nesting?; end

  # source://opal//lib/opal/nodes/call.rb#197
  def receiver_sexp; end

  # source://opal//lib/opal/nodes/call.rb#233
  def sexp_with_arglist; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/call.rb#193
  def splat?; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/call.rb#225
  def using_eval?; end

  # a variable reference in irb mode in top scope might be a var ref,
  # or it might be a method call
  #
  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/call.rb#221
  def using_irb?; end

  # source://opal//lib/opal/nodes/call.rb#355
  def using_refinement(arg); end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/call.rb#229
  def variable_like?; end

  # source://opal//lib/opal/nodes/call.rb#453
  def with_wrapper(&block); end

  class << self
    # source://opal//lib/opal/nodes/call.rb#20
    def add_special(name, options = T.unsafe(nil), &handler); end
  end
end

# source://opal//lib/opal/nodes/call.rb#495
class Opal::Nodes::CallNode::DependencyResolver
  # @return [DependencyResolver] a new instance of DependencyResolver
  #
  # source://opal//lib/opal/nodes/call.rb#496
  def initialize(compiler, sexp, missing_dynamic_require = T.unsafe(nil)); end

  # source://opal//lib/opal/nodes/call.rb#544
  def expand_path(path, base = T.unsafe(nil)); end

  # source://opal//lib/opal/nodes/call.rb#506
  def handle_part(sexp, missing_dynamic_require = T.unsafe(nil)); end

  # source://opal//lib/opal/nodes/call.rb#502
  def resolve; end
end

# Operators that get optimized by compiler
#
# source://opal//lib/opal/nodes/call.rb#17
Opal::Nodes::CallNode::OPERATORS = T.let(T.unsafe(nil), Hash)

# source://opal//lib/opal/nodes/call.rb#14
Opal::Nodes::CallNode::SPECIALS = T.let(T.unsafe(nil), Hash)

# ::CONST
# s(:const, s(:cbase), :CONST)
#
# source://opal//lib/opal/nodes/constants.rb#53
class Opal::Nodes::CbaseNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/constants.rb#56
  def compile; end
end

# source://opal//lib/opal/nodes/class.rb#7
class Opal::Nodes::ClassNode < ::Opal::Nodes::ModuleNode
  # source://opal//lib/opal/nodes/base.rb#24
  def body; end

  # source://opal//lib/opal/nodes/base.rb#24
  def cid; end

  # source://opal//lib/opal/nodes/class.rb#12
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def sup; end

  # source://opal//lib/opal/nodes/class.rb#46
  def super_code; end
end

# source://opal//lib/opal/nodes/variables.rb#210
class Opal::Nodes::ClassVarAssignNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/variables.rb#215
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def name; end

  # source://opal//lib/opal/nodes/base.rb#24
  def value; end
end

# source://opal//lib/opal/nodes/variables.rb#191
class Opal::Nodes::ClassVariableNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/variables.rb#196
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def name; end
end

# This module takes care of providing information about the
# closure stack that we have for the nodes during compile time.
# This is not a typical node.
#
# Also, while loops are not closures per se, this module also
# takes a note about them.
#
# Then we can use this information for control flow like
# generating breaks, nexts, returns.
#
# source://opal//lib/opal/nodes/closure.rb#14
class Opal::Nodes::Closure
  # @return [Closure] a new instance of Closure
  #
  # source://opal//lib/opal/nodes/closure.rb#46
  def initialize(node, type, parent); end

  # Returns the value of attribute catchers.
  #
  # source://opal//lib/opal/nodes/closure.rb#70
  def catchers; end

  # Sets the attribute catchers
  #
  # @param value the value to set the attribute catchers to.
  #
  # source://opal//lib/opal/nodes/closure.rb#70
  def catchers=(_arg0); end

  # source://opal//lib/opal/nodes/closure.rb#66
  def inspect; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/closure.rb#62
  def is?(type); end

  # Returns the value of attribute node.
  #
  # source://opal//lib/opal/nodes/closure.rb#70
  def node; end

  # Sets the attribute node
  #
  # @param value the value to set the attribute node to.
  #
  # source://opal//lib/opal/nodes/closure.rb#70
  def node=(_arg0); end

  # Returns the value of attribute parent.
  #
  # source://opal//lib/opal/nodes/closure.rb#70
  def parent; end

  # Sets the attribute parent
  #
  # @param value the value to set the attribute parent to.
  #
  # source://opal//lib/opal/nodes/closure.rb#70
  def parent=(_arg0); end

  # source://opal//lib/opal/nodes/closure.rb#52
  def register_catcher(type = T.unsafe(nil)); end

  # source://opal//lib/opal/nodes/closure.rb#58
  def register_thrower(type, id); end

  # Returns the value of attribute throwers.
  #
  # source://opal//lib/opal/nodes/closure.rb#70
  def throwers; end

  # Sets the attribute throwers
  #
  # @param value the value to set the attribute throwers to.
  #
  # source://opal//lib/opal/nodes/closure.rb#70
  def throwers=(_arg0); end

  # Returns the value of attribute type.
  #
  # source://opal//lib/opal/nodes/closure.rb#70
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  #
  # source://opal//lib/opal/nodes/closure.rb#70
  def type=(_arg0); end

  class << self
    # source://opal//lib/opal/nodes/closure.rb#19
    def add_type(name, value); end

    # source://opal//lib/opal/nodes/closure.rb#24
    def type_inspect(type); end
  end
end

# source://opal//lib/opal/nodes/closure.rb#44
Opal::Nodes::Closure::ANY = T.let(T.unsafe(nil), Integer)

# source://opal//lib/opal/nodes/closure.rb#251
module Opal::Nodes::Closure::CompilerSupport
  # source://opal//lib/opal/nodes/closure.rb#252
  def closure_stack; end
end

# source://opal//lib/opal/nodes/closure.rb#20
Opal::Nodes::Closure::DEF = T.let(T.unsafe(nil), Integer)

# source://opal//lib/opal/nodes/closure.rb#20
Opal::Nodes::Closure::ITER = T.let(T.unsafe(nil), Integer)

# source://opal//lib/opal/nodes/closure.rb#20
Opal::Nodes::Closure::JS_FUNCTION = T.let(T.unsafe(nil), Integer)

# source://opal//lib/opal/nodes/closure.rb#20
Opal::Nodes::Closure::JS_LOOP = T.let(T.unsafe(nil), Integer)

# source://opal//lib/opal/nodes/closure.rb#20
Opal::Nodes::Closure::JS_LOOP_INSIDE = T.let(T.unsafe(nil), Integer)

# source://opal//lib/opal/nodes/closure.rb#20
Opal::Nodes::Closure::LAMBDA = T.let(T.unsafe(nil), Integer)

# source://opal//lib/opal/nodes/closure.rb#20
Opal::Nodes::Closure::LOOP = T.let(T.unsafe(nil), Integer)

# source://opal//lib/opal/nodes/closure.rb#20
Opal::Nodes::Closure::LOOP_INSIDE = T.let(T.unsafe(nil), Integer)

# source://opal//lib/opal/nodes/closure.rb#20
Opal::Nodes::Closure::MODULE = T.let(T.unsafe(nil), Integer)

# source://opal//lib/opal/nodes/closure.rb#15
Opal::Nodes::Closure::NONE = T.let(T.unsafe(nil), Integer)

# source://opal//lib/opal/nodes/closure.rb#72
module Opal::Nodes::Closure::NodeSupport
  # Returns the value of attribute closure.
  #
  # source://opal//lib/opal/nodes/closure.rb#79
  def closure; end

  # Sets the attribute closure
  #
  # @param value the value to set the attribute closure to.
  #
  # source://opal//lib/opal/nodes/closure.rb#79
  def closure=(_arg0); end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/closure.rb#202
  def closure_is?(type); end

  # Generate a catcher if thrower has been used
  #
  # source://opal//lib/opal/nodes/closure.rb#207
  def compile_catcher; end

  # source://opal//lib/opal/nodes/closure.rb#102
  def generate_thrower(type, closure, value); end

  # source://opal//lib/opal/nodes/closure.rb#109
  def generate_thrower_without_catcher(type, closure, value); end

  # source://opal//lib/opal/nodes/closure.rb#88
  def in_closure(type = T.unsafe(nil)); end

  # source://opal//lib/opal/nodes/closure.rb#81
  def pop_closure; end

  # source://opal//lib/opal/nodes/closure.rb#73
  def push_closure(type = T.unsafe(nil)); end

  # source://opal//lib/opal/nodes/closure.rb#95
  def select_closure(type = T.unsafe(nil), break_after: T.unsafe(nil)); end

  # source://opal//lib/opal/nodes/closure.rb#124
  def thrower(type, value = T.unsafe(nil)); end
end

# source://opal//lib/opal/nodes/closure.rb#20
Opal::Nodes::Closure::RESCUE_RETRIER = T.let(T.unsafe(nil), Integer)

# source://opal//lib/opal/nodes/closure.rb#20
Opal::Nodes::Closure::SEND = T.let(T.unsafe(nil), Integer)

# source://opal//lib/opal/nodes/closure.rb#20
Opal::Nodes::Closure::TOP = T.let(T.unsafe(nil), Integer)

# 0b1110i -> s(:complex, (0+14i))
# -0b1110i -> s(:complex, (0-14i))
#
# source://opal//lib/opal/nodes/literal.rb#359
class Opal::Nodes::ComplexNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/literal.rb#364
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def value; end
end

# source://opal//lib/opal/nodes/constants.rb#61
class Opal::Nodes::ConstAssignNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/base.rb#24
  def base; end

  # source://opal//lib/opal/nodes/constants.rb#66
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def name; end

  # source://opal//lib/opal/nodes/base.rb#24
  def value; end
end

# source://opal//lib/opal/nodes/constants.rb#7
class Opal::Nodes::ConstNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/constants.rb#12
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def const_scope; end

  # Ruby has a magical const DATA
  # that should be processed in a different way:
  # 1. When current file contains __END__ in the end of the file
  #    DATA const should be resolved to the string located after __END__
  # 2. When current file doesn't have __END__ section
  #    DATA const should be resolved to a regular ::DATA constant
  #
  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/constants.rb#35
  def magical_data_const?; end

  # source://opal//lib/opal/nodes/base.rb#24
  def name; end

  # For a certain case of calls like `::Opal.coerce_to?` we can
  # optimize the calls. We can be sure they are defined from the
  # beginning.
  #
  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/constants.rb#46
  def optimized_access?; end
end

# source://opal//lib/opal/nodes/constants.rb#39
Opal::Nodes::ConstNode::OPTIMIZED_ACCESS_CONSTS = T.let(T.unsafe(nil), Array)

# source://opal//lib/opal/nodes/def.rb#7
class Opal::Nodes::DefNode < ::Opal::Nodes::NodeWithArgs
  # source://opal//lib/opal/nodes/def.rb#90
  def comments_code; end

  # source://opal//lib/opal/nodes/def.rb#12
  def compile; end

  # source://opal//lib/opal/nodes/def.rb#43
  def compile_body; end

  # source://opal//lib/opal/nodes/base.rb#24
  def inline_args; end

  # source://opal//lib/opal/nodes/base.rb#24
  def mid; end

  # source://opal//lib/opal/nodes/base.rb#24
  def stmts; end

  # source://opal//lib/opal/nodes/def.rb#83
  def wrap_with_definition; end
end

# source://opal//lib/opal/nodes/defined.rb#7
class Opal::Nodes::DefinedNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/defined.rb#12
  def compile; end

  # source://opal//lib/opal/nodes/defined.rb#62
  def compile_defined(node); end

  # source://opal//lib/opal/nodes/defined.rb#215
  def compile_defined_array(node); end

  # source://opal//lib/opal/nodes/defined.rb#200
  def compile_defined_back_ref; end

  # source://opal//lib/opal/nodes/defined.rb#162
  def compile_defined_const(node); end

  # source://opal//lib/opal/nodes/defined.rb#178
  def compile_defined_cvar(node); end

  # source://opal//lib/opal/nodes/defined.rb#185
  def compile_defined_gvar(node); end

  # source://opal//lib/opal/nodes/defined.rb#135
  def compile_defined_ivar(node); end

  # source://opal//lib/opal/nodes/defined.rb#207
  def compile_defined_nth_ref; end

  # source://opal//lib/opal/nodes/defined.rb#94
  def compile_defined_send(node); end

  # source://opal//lib/opal/nodes/defined.rb#147
  def compile_defined_super; end

  # source://opal//lib/opal/nodes/defined.rb#158
  def compile_defined_xstr(node); end

  # source://opal//lib/opal/nodes/defined.rb#151
  def compile_defined_yield; end

  # source://opal//lib/opal/nodes/defined.rb#90
  def compile_send_recv_doesnt_raise(recv_code); end

  # source://opal//lib/opal/nodes/base.rb#24
  def value; end

  # source://opal//lib/opal/nodes/defined.rb#74
  def wrap_with_try_catch(code); end
end

# source://opal//lib/opal/nodes/super.rb#104
class Opal::Nodes::DefinedSuperNode < ::Opal::Nodes::BaseSuperNode
  # source://opal//lib/opal/nodes/super.rb#107
  def allow_stubs; end

  # source://opal//lib/opal/nodes/super.rb#115
  def compile; end

  # source://opal//lib/opal/nodes/super.rb#111
  def defined_check_param; end
end

# source://opal//lib/opal/nodes/defs.rb#7
class Opal::Nodes::DefsNode < ::Opal::Nodes::DefNode
  # source://opal//lib/opal/nodes/base.rb#24
  def inline_args; end

  # source://opal//lib/opal/nodes/base.rb#24
  def mid; end

  # source://opal//lib/opal/nodes/base.rb#24
  def recvr; end

  # source://opal//lib/opal/nodes/base.rb#24
  def stmts; end

  # source://opal//lib/opal/nodes/defs.rb#11
  def wrap_with_definition; end
end

# source://opal//lib/opal/nodes/literal.rb#258
class Opal::Nodes::DynamicStringNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/literal.rb#261
  def compile; end
end

# source://opal//lib/opal/nodes/literal.rb#286
class Opal::Nodes::DynamicSymbolNode < ::Opal::Nodes::DynamicStringNode; end

# source://opal//lib/opal/nodes/if.rb#438
class Opal::Nodes::EFlipFlop < ::Opal::Nodes::BaseFlipFlop
  # Exclusive flip flop, check 'end_condition' in the next iteration after 'start_condition' is truthy
  #
  # source://opal//lib/opal/nodes/if.rb#442
  def excl; end
end

# source://opal//lib/opal/nodes/rescue.rb#7
class Opal::Nodes::EnsureNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/base.rb#24
  def begn; end

  # source://opal//lib/opal/nodes/rescue.rb#65
  def body_sexp; end

  # source://opal//lib/opal/nodes/rescue.rb#12
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def ensr; end

  # source://opal//lib/opal/nodes/rescue.rb#73
  def ensr_sexp; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/rescue.rb#87
  def has_rescue_else?; end

  # source://opal//lib/opal/nodes/rescue.rb#81
  def rescue_else_code; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/rescue.rb#77
  def wrap_in_closure?; end
end

# source://opal//lib/opal/nodes/literal.rb#333
class Opal::Nodes::ExclusiveRangeNode < ::Opal::Nodes::RangeNode
  # source://opal//lib/opal/nodes/literal.rb#336
  def compile_inline; end

  # source://opal//lib/opal/nodes/literal.rb#340
  def compile_range_initialize; end
end

# source://opal//lib/opal/nodes/variables.rb#157
class Opal::Nodes::GlobalAssignNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/variables.rb#166
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def name; end

  # source://opal//lib/opal/nodes/base.rb#24
  def value; end

  # source://opal//lib/opal/nodes/variables.rb#162
  def var_name; end
end

# source://opal//lib/opal/nodes/variables.rb#95
class Opal::Nodes::GlobalVariableNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/variables.rb#104
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def name; end

  # source://opal//lib/opal/nodes/variables.rb#100
  def var_name; end
end

# source://opal//lib/opal/nodes/hash.rb#7
class Opal::Nodes::HashNode < ::Opal::Nodes::Base
  # @return [HashNode] a new instance of HashNode
  #
  # source://opal//lib/opal/nodes/hash.rb#12
  def initialize(*_arg0); end

  # source://opal//lib/opal/nodes/hash.rb#33
  def compile; end

  # Compiles a hash without kwsplats
  # with simple or complex keys.
  #
  # source://opal//lib/opal/nodes/hash.rb#76
  def compile_hash; end

  # Compiles hashes containing kwsplats inside.
  # hash like { **{ nested: 1 }, a: 1, **{ nested: 2} }
  # should be compiled to
  # { nested: 1}.merge(a: 1).merge(nested: 2)
  # Each kwsplat overrides previosly defined keys
  # Hash k/v pairs override previously defined kwsplat values
  #
  # source://opal//lib/opal/nodes/hash.rb#47
  def compile_merge; end

  # Returns the value of attribute has_kwsplat.
  #
  # source://opal//lib/opal/nodes/hash.rb#10
  def has_kwsplat; end

  # Sets the attribute has_kwsplat
  #
  # @param value the value to set the attribute has_kwsplat to.
  #
  # source://opal//lib/opal/nodes/hash.rb#10
  def has_kwsplat=(_arg0); end

  # Returns the value of attribute keys.
  #
  # source://opal//lib/opal/nodes/hash.rb#10
  def keys; end

  # Sets the attribute keys
  #
  # @param value the value to set the attribute keys to.
  #
  # source://opal//lib/opal/nodes/hash.rb#10
  def keys=(_arg0); end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/hash.rb#29
  def simple_keys?; end

  # Returns the value of attribute values.
  #
  # source://opal//lib/opal/nodes/hash.rb#10
  def values; end

  # Sets the attribute values
  #
  # @param value the value to set the attribute values to.
  #
  # source://opal//lib/opal/nodes/hash.rb#10
  def values=(_arg0); end
end

# source://opal//lib/opal/nodes/helpers.rb#7
module Opal::Nodes::Helpers
  # source://opal//lib/opal/nodes/helpers.rb#33
  def current_indent; end

  # source://opal//lib/opal/nodes/helpers.rb#42
  def empty_line; end

  # source://opal//lib/opal/nodes/helpers.rb#29
  def indent(&block); end

  # source://opal//lib/opal/nodes/helpers.rb#46
  def js_truthy(sexp); end

  # source://opal//lib/opal/nodes/helpers.rb#55
  def js_truthy_optimize(sexp); end

  # source://opal//lib/opal/nodes/helpers.rb#37
  def line(*strs); end

  # Converts a ruby method name into its javascript equivalent for
  # a method/function call. All ruby method names get prefixed with
  # a '$', and if the name is a valid javascript identifier, it will
  # have a '.' prefix (for dot-calling), otherwise it will be
  # wrapped in brackets to use reference notation calling.
  #
  # source://opal//lib/opal/nodes/helpers.rb#21
  def mid_to_jsid(mid); end

  # source://opal//lib/opal/nodes/helpers.rb#8
  def property(name); end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/helpers.rb#12
  def valid_name?(name); end
end

# source://opal//lib/opal/nodes/if.rb#429
class Opal::Nodes::IFlipFlop < ::Opal::Nodes::BaseFlipFlop
  # Inclusive flip flop, check 'end_condition' in the same iteration when 'start_condition' is truthy
  #
  # source://opal//lib/opal/nodes/if.rb#433
  def excl; end
end

# source://opal//lib/opal/nodes/if.rb#8
class Opal::Nodes::IfNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/if.rb#13
  def compile; end

  # source://opal//lib/opal/nodes/if.rb#365
  def compile_switch_case(test); end

  # source://opal//lib/opal/nodes/if.rb#387
  def compile_switch_default; end

  # source://opal//lib/opal/nodes/if.rb#130
  def compile_with_binary_and; end

  # source://opal//lib/opal/nodes/if.rb#143
  def compile_with_binary_or; end

  # source://opal//lib/opal/nodes/if.rb#29
  def compile_with_if; end

  # source://opal//lib/opal/nodes/if.rb#346
  def compile_with_switch; end

  # source://opal//lib/opal/nodes/if.rb#112
  def compile_with_ternary; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/if.rb#254
  def could_become_switch?; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/if.rb#286
  def could_become_switch_branch?(body); end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/if.rb#98
  def expects_expression?; end

  # source://opal//lib/opal/nodes/base.rb#24
  def false_body; end

  # source://opal//lib/opal/nodes/if.rb#86
  def falsy; end

  # source://opal//lib/opal/nodes/if.rb#272
  def handle_additional_switch_rules(additional_rules); end

  # source://opal//lib/opal/nodes/if.rb#90
  def returnify(body); end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/if.rb#360
  def returning?(body); end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/if.rb#78
  def returning_if?; end

  # There was a particular case in the past, that when we
  # expected an expression from if, we always had to closure
  # it. This produced an ugly code that was hard to minify.
  # This addition tries to make a few cases compiled with
  # a ternary operator instead and possibly a binary operator
  # even?
  #
  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/if.rb#108
  def should_compile_as_simple_expression?; end

  # Let's ensure there are no control flow statements inside.
  #
  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/if.rb#157
  def simple?(body); end

  # source://opal//lib/opal/nodes/base.rb#24
  def test; end

  # source://opal//lib/opal/nodes/base.rb#24
  def true_body; end

  # source://opal//lib/opal/nodes/if.rb#82
  def truthy; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/if.rb#325
  def valid_switch_body?(body, check_variable = T.unsafe(nil)); end
end

# Matches: `when 456` (from `case foo; when 123; when 456; end`)
# Captures: [s(:int, 456), "$ret_or_1"]
#
# source://opal//lib/opal/nodes/if.rb#228
Opal::Nodes::IfNode::SWITCH_BRANCH_TEST_MATCH = T.let(T.unsafe(nil), Opal::AST::Matcher)

# Matches: `when 456`
# Captures: [
#   s(:int, 789),
#   "$ret_or_1",
#   here we delegate to either SWITCH_BRANCH_TEST_MATCH or SWITCH_BRANCH_TEST_MATCH_CONTINUED
# ]
#
# source://opal//lib/opal/nodes/if.rb#242
Opal::Nodes::IfNode::SWITCH_BRANCH_TEST_MATCH_CONTINUED = T.let(T.unsafe(nil), Opal::AST::Matcher)

# Matches: `case some_value_or_expression; when 123`
# Captures: [s(:int, 123), "$ret_or_1", s(:send, nil, :some_value_or_expression))]
#
# source://opal//lib/opal/nodes/if.rb#199
Opal::Nodes::IfNode::SWITCH_TEST_MATCH = T.let(T.unsafe(nil), Opal::AST::Matcher)

# Matches: case some_value_or_expression; when 123, 456; end
# Captures: [
#   s(:int, 123),
#   "$ret_or_1",
#   s(:send, nil, :some_value_or_expression)),
#   here we delegate to either SWITCH_BRANCH_TEST_MATCH or SWITCH_BRANCH_TEST_MATCH_CONTINUED
# ]
#
# source://opal//lib/opal/nodes/if.rb#214
Opal::Nodes::IfNode::SWITCH_TEST_MATCH_CONTINUED = T.let(T.unsafe(nil), Opal::AST::Matcher)

# source://opal//lib/opal/nodes/literal.rb#321
class Opal::Nodes::InclusiveRangeNode < ::Opal::Nodes::RangeNode
  # source://opal//lib/opal/nodes/literal.rb#324
  def compile_inline; end

  # source://opal//lib/opal/nodes/literal.rb#328
  def compile_range_initialize; end
end

# source://opal//lib/opal/nodes/variables.rb#77
class Opal::Nodes::InstanceAssignNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/variables.rb#86
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def name; end

  # source://opal//lib/opal/nodes/base.rb#24
  def value; end

  # source://opal//lib/opal/nodes/variables.rb#82
  def var_name; end
end

# source://opal//lib/opal/nodes/variables.rb#61
class Opal::Nodes::InstanceVariableNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/variables.rb#70
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def name; end

  # source://opal//lib/opal/nodes/variables.rb#66
  def var_name; end
end

# source://opal//lib/opal/nodes/args/arity_check.rb#118
class Opal::Nodes::IterArityCheckNode < ::Opal::Nodes::ArityCheckNode
  # source://opal//lib/opal/nodes/args/arity_check.rb#121
  def compile; end
end

# source://opal//lib/opal/nodes/iter.rb#7
class Opal::Nodes::IterNode < ::Opal::Nodes::NodeWithArgs
  # source://opal//lib/opal/nodes/iter.rb#135
  def arity_check_node; end

  # source://opal//lib/opal/nodes/iter.rb#12
  def compile; end

  # source://opal//lib/opal/nodes/iter.rb#90
  def compile_block_arg; end

  # source://opal//lib/opal/nodes/iter.rb#57
  def compile_body; end

  # source://opal//lib/opal/nodes/iter.rb#96
  def extract_underscore_args; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/iter.rb#124
  def has_top_level_mlhs_arg?; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/iter.rb#128
  def has_trailing_comma_in_args?; end

  # source://opal//lib/opal/nodes/base.rb#24
  def inline_args; end

  # source://opal//lib/opal/nodes/iter.rb#120
  def returned_body; end

  # source://opal//lib/opal/nodes/base.rb#24
  def stmts; end
end

# source://opal//lib/opal/nodes/logic.rb#107
class Opal::Nodes::JSReturnNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/logic.rb#112
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def value; end
end

# source://opal//lib/opal/nodes/logic.rb#118
class Opal::Nodes::JSTempNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/logic.rb#123
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def value; end
end

# recvr.JS[:prop] = value
# => recvr.prop = value
#
# source://opal//lib/opal/nodes/call_special.rb#21
class Opal::Nodes::JsAttrAsgnNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/call_special.rb#26
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def property; end

  # source://opal//lib/opal/nodes/base.rb#24
  def recvr; end

  # source://opal//lib/opal/nodes/base.rb#24
  def value; end
end

# recvr.JS[:prop]
# => recvr.prop
#
# source://opal//lib/opal/nodes/call_special.rb#10
class Opal::Nodes::JsAttrNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/call_special.rb#14
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def property; end

  # source://opal//lib/opal/nodes/base.rb#24
  def recvr; end
end

# source://opal//lib/opal/nodes/call_special.rb#31
class Opal::Nodes::JsCallNode < ::Opal::Nodes::CallNode
  # @return [JsCallNode] a new instance of JsCallNode
  #
  # source://opal//lib/opal/nodes/call_special.rb#34
  def initialize(*_arg0); end

  # source://opal//lib/opal/nodes/call_special.rb#45
  def compile; end

  # source://opal//lib/opal/nodes/call_special.rb#53
  def compile_using_send; end

  # source://opal//lib/opal/nodes/call_special.rb#49
  def method_jsid; end
end

# source://opal//lib/opal/nodes/definitions.rb#106
class Opal::Nodes::KwBeginNode < ::Opal::Nodes::BeginNode; end

# source://opal//lib/opal/nodes/hash.rb#98
class Opal::Nodes::KwSplatNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/hash.rb#102
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def value; end
end

# source://opal//lib/opal/nodes/lambda.rb#7
class Opal::Nodes::LambdaNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/lambda.rb#11
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def iter; end
end

# source://opal//lib/opal/nodes/variables.rb#26
class Opal::Nodes::LocalAssignNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/variables.rb#35
  def compile; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/variables.rb#31
  def using_irb?; end

  # source://opal//lib/opal/nodes/base.rb#24
  def value; end

  # source://opal//lib/opal/nodes/base.rb#24
  def var_name; end
end

# source://opal//lib/opal/nodes/variables.rb#50
class Opal::Nodes::LocalDeclareNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/variables.rb#55
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def var_name; end
end

# source://opal//lib/opal/nodes/variables.rb#7
class Opal::Nodes::LocalVariableNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/variables.rb#16
  def compile; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/variables.rb#12
  def using_irb?; end

  # source://opal//lib/opal/nodes/base.rb#24
  def var_name; end
end

# source://opal//lib/opal/nodes/masgn.rb#7
class Opal::Nodes::MassAssignNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/masgn.rb#13
  def compile; end

  # source://opal//lib/opal/nodes/masgn.rb#76
  def compile_assignment(child, array, idx, len = T.unsafe(nil)); end

  # 'len' is how many rhs items are we sure we have
  #
  # source://opal//lib/opal/nodes/masgn.rb#33
  def compile_masgn(lhs_items, array, len = T.unsafe(nil)); end

  # source://opal//lib/opal/nodes/base.rb#24
  def lhs; end

  # source://opal//lib/opal/nodes/base.rb#24
  def rhs; end
end

# source://opal//lib/opal/nodes/masgn.rb#8
Opal::Nodes::MassAssignNode::SIMPLE_ASSIGNMENT = T.let(T.unsafe(nil), Array)

# Handles match_with_lvasgn nodes which represent matching a regular expression
# with a right-hand side value and assigning the match result to a left-hand side variable.
#
# source://opal//lib/opal/nodes/call_special.rb#65
class Opal::Nodes::Match3Node < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/call_special.rb#70
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def lhs; end

  # source://opal//lib/opal/nodes/base.rb#24
  def rhs; end

  private

  # source://opal//lib/opal/nodes/call_special.rb#94
  def extract_names(regexp_node); end

  # source://opal//lib/opal/nodes/call_special.rb#110
  def generate_names_assignments(names); end

  # source://opal//lib/opal/nodes/call_special.rb#99
  def generate_names_definition; end

  # source://opal//lib/opal/nodes/call_special.rb#133
  def handle_non_statement(sexp, names_def, names_assignments); end

  # source://opal//lib/opal/nodes/call_special.rb#123
  def handle_statement(sexp, names_def, names_assignments); end
end

# $_ = 'foo'; call if /foo/
# s(:if, s(:match_current_line, /foo/, true))
#
# source://opal//lib/opal/nodes/literal.rb#243
class Opal::Nodes::MatchCurrentLineNode < ::Opal::Nodes::Base
  # Here we just convert it to
  # ($_ =~ regexp)
  # and let :send node to handle it
  #
  # source://opal//lib/opal/nodes/literal.rb#251
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def regexp; end
end

# source://opal//lib/opal/nodes/module.rb#7
class Opal::Nodes::ModuleNode < ::Opal::Nodes::ScopeNode
  # source://opal//lib/opal/nodes/base.rb#24
  def body; end

  # source://opal//lib/opal/nodes/base.rb#24
  def cid; end

  # source://opal//lib/opal/nodes/module.rb#12
  def compile; end

  private

  # source://opal//lib/opal/nodes/module.rb#59
  def compile_body; end

  # cid is always s(:const, scope_sexp_or_nil, :ConstName)
  #
  # source://opal//lib/opal/nodes/module.rb#49
  def name_and_base; end
end

# source://opal//lib/opal/nodes/logic.rb#7
class Opal::Nodes::NextNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/logic.rb#10
  def compile; end

  # source://opal//lib/opal/nodes/logic.rb#14
  def value; end
end

# source://opal//lib/opal/nodes/node_with_args/shortcuts.rb#5
class Opal::Nodes::NodeWithArgs < ::Opal::Nodes::ScopeNode
  # @return [NodeWithArgs] a new instance of NodeWithArgs
  #
  # source://opal//lib/opal/nodes/node_with_args.rb#14
  def initialize(*_arg0); end

  # Returns the value of attribute arity.
  #
  # source://opal//lib/opal/nodes/node_with_args.rb#11
  def arity; end

  # Sets the attribute arity
  #
  # @param value the value to set the attribute arity to.
  #
  # source://opal//lib/opal/nodes/node_with_args.rb#11
  def arity=(_arg0); end

  # source://opal//lib/opal/nodes/node_with_args.rb#22
  def arity_check_node; end

  # Returns code used in debug mode to check arity of method call
  #
  # source://opal//lib/opal/nodes/node_with_args.rb#27
  def compile_arity_check; end

  # source://opal//lib/opal/nodes/node_with_args.rb#31
  def compile_block_arg; end

  # source://opal//lib/opal/nodes/node_with_args/shortcuts.rb#32
  def compile_body_or_shortcut; end

  # Returns the value of attribute original_args.
  #
  # source://opal//lib/opal/nodes/node_with_args.rb#12
  def original_args; end

  # source://opal//lib/opal/nodes/node_with_args.rb#37
  def parameters_code; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/node_with_args/shortcuts.rb#61
  def simple_value?(node = T.unsafe(nil)); end

  # Returns the value of attribute used_kwargs.
  #
  # source://opal//lib/opal/nodes/node_with_args.rb#10
  def used_kwargs; end

  class << self
    # source://opal//lib/opal/nodes/node_with_args/shortcuts.rb#20
    def define_shortcut(name, **kwargs, &block); end

    # source://opal//lib/opal/nodes/node_with_args/shortcuts.rb#25
    def shortcuts_for(node_type); end
  end
end

# Shortcuts for the simplest kinds of methods
#
# source://opal//lib/opal/nodes/node_with_args/shortcuts.rb#7
class Opal::Nodes::NodeWithArgs::Shortcut < ::Struct
  # source://opal//lib/opal/nodes/node_with_args/shortcuts.rb#12
  def compile(node); end

  # Returns the value of attribute for
  #
  # @return [Object] the current value of for
  def for; end

  # Sets the attribute for
  #
  # @param value [Object] the value to set the attribute for to.
  # @return [Object] the newly set value
  def for=(_); end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/node_with_args/shortcuts.rb#8
  def match?(node); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  # Returns the value of attribute transform
  #
  # @return [Object] the current value of transform
  def transform; end

  # Sets the attribute transform
  #
  # @param value [Object] the value to set the attribute transform to.
  # @return [Object] the newly set value
  def transform=(_); end

  # Returns the value of attribute when
  #
  # @return [Object] the current value of when
  def when; end

  # Sets the attribute when
  #
  # @param value [Object] the value to set the attribute when to.
  # @return [Object] the newly set value
  def when=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# $1 => s(:nth_ref, 1)
#
# source://opal//lib/opal/nodes/variables.rb#177
class Opal::Nodes::NthrefNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/variables.rb#182
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def index; end
end

# source://opal//lib/opal/nodes/literal.rb#27
class Opal::Nodes::NumericNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/literal.rb#32
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def value; end

  class << self
    # @return [Boolean]
    #
    # source://opal//lib/opal/nodes/literal.rb#37
    def truthy_optimize?; end
  end
end

# source://opal//lib/opal/nodes/literal.rb#290
class Opal::Nodes::RangeNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/literal.rb#295
  def compile; end

  # @raise [NotImplementedError]
  #
  # source://opal//lib/opal/nodes/literal.rb#312
  def compile_inline; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/literal.rb#304
  def compile_inline?; end

  # @raise [NotImplementedError]
  #
  # source://opal//lib/opal/nodes/literal.rb#316
  def compile_range_initialize; end

  # source://opal//lib/opal/nodes/base.rb#24
  def finish; end

  # source://opal//lib/opal/nodes/base.rb#24
  def start; end
end

# source://opal//lib/opal/nodes/literal.rb#293
Opal::Nodes::RangeNode::SIMPLE_CHILDREN_TYPES = T.let(T.unsafe(nil), Array)

# 0b1111r -> s(:rational, (15/1))
# -0b1111r -> s(:rational, (-15/1))
#
# source://opal//lib/opal/nodes/literal.rb#347
class Opal::Nodes::RationalNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/literal.rb#352
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def value; end
end

# source://opal//lib/opal/nodes/logic.rb#36
class Opal::Nodes::RedoNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/logic.rb#39
  def compile; end

  # source://opal//lib/opal/nodes/logic.rb#54
  def compile_iter; end

  # source://opal//lib/opal/nodes/logic.rb#49
  def compile_while; end
end

# source://opal//lib/opal/nodes/literal.rb#117
class Opal::Nodes::RegexpNode < ::Opal::Nodes::Base
  # @return [RegexpNode] a new instance of RegexpNode
  #
  # source://opal//lib/opal/nodes/literal.rb#125
  def initialize(*_arg0); end

  # source://opal//lib/opal/nodes/literal.rb#130
  def compile; end

  # source://opal//lib/opal/nodes/literal.rb#147
  def compile_dynamic_regexp; end

  # source://opal//lib/opal/nodes/literal.rb#160
  def compile_static_regexp; end

  # source://opal//lib/opal/nodes/literal.rb#190
  def extract_flags_and_value; end

  # Returns the value of attribute flags.
  #
  # source://opal//lib/opal/nodes/literal.rb#120
  def flags; end

  # Sets the attribute flags
  #
  # @param value the value to set the attribute flags to.
  #
  # source://opal//lib/opal/nodes/literal.rb#120
  def flags=(_arg0); end

  # source://opal//lib/opal/nodes/literal.rb#226
  def raw_value; end

  # source://opal//lib/opal/nodes/literal.rb#180
  def static_as_dynamic(value); end

  # Returns the value of attribute value.
  #
  # source://opal//lib/opal/nodes/literal.rb#120
  def value; end

  # Sets the attribute value
  #
  # @param value the value to set the attribute value to.
  #
  # source://opal//lib/opal/nodes/literal.rb#120
  def value=(_arg0); end

  private

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/literal.rb#232
  def single_line?(values); end
end

# https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp
#
# source://opal//lib/opal/nodes/literal.rb#123
Opal::Nodes::RegexpNode::SUPPORTED_FLAGS = T.let(T.unsafe(nil), Regexp)

# source://opal//lib/opal/nodes/rescue.rb#195
class Opal::Nodes::ResBodyNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/base.rb#24
  def body; end

  # source://opal//lib/opal/nodes/rescue.rb#200
  def compile; end

  # source://opal//lib/opal/nodes/rescue.rb#219
  def klasses; end

  # source://opal//lib/opal/nodes/base.rb#24
  def klasses_sexp; end

  # source://opal//lib/opal/nodes/base.rb#24
  def lvar; end

  # source://opal//lib/opal/nodes/rescue.rb#223
  def rescue_body; end
end

# source://opal//lib/opal/nodes/rescue.rb#92
class Opal::Nodes::RescueNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/base.rb#24
  def body; end

  # source://opal//lib/opal/nodes/rescue.rb#171
  def body_code; end

  # source://opal//lib/opal/nodes/rescue.rb#97
  def compile; end

  # Returns true when there's no 'ensure' statement
  #  wrapping current rescue.
  #
  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/rescue.rb#186
  def handle_rescue_else_manually?; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/rescue.rb#190
  def has_retry?; end

  # source://opal//lib/opal/nodes/rescue.rb#177
  def rescue_else_code; end
end

# source://opal//lib/opal/nodes/logic.rb#79
class Opal::Nodes::RetryNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/logic.rb#82
  def compile; end
end

# source://opal//lib/opal/nodes/logic.rb#87
class Opal::Nodes::ReturnNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/logic.rb#102
  def compile; end

  # source://opal//lib/opal/nodes/logic.rb#92
  def return_val; end

  # source://opal//lib/opal/nodes/base.rb#24
  def value; end
end

# Created by `#returns()` for when a yield statement should return
# it's value (its last in a block etc).
#
# source://opal//lib/opal/nodes/yield.rb#61
class Opal::Nodes::ReturnableYieldNode < ::Opal::Nodes::BaseYieldNode
  # source://opal//lib/opal/nodes/yield.rb#64
  def compile; end
end

# source://opal//lib/opal/nodes/scope.rb#7
class Opal::Nodes::ScopeNode < ::Opal::Nodes::Base
  # @return [ScopeNode] a new instance of ScopeNode
  #
  # source://opal//lib/opal/nodes/scope.rb#34
  def initialize(*_arg0); end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/scope.rb#365
  def accepts_using?; end

  # source://opal//lib/opal/nodes/scope.rb#172
  def add_arg(arg); end

  # source://opal//lib/opal/nodes/scope.rb#168
  def add_proto_ivar(ivar); end

  # source://opal//lib/opal/nodes/scope.rb#164
  def add_scope_gvar(gvar); end

  # source://opal//lib/opal/nodes/scope.rb#156
  def add_scope_ivar(ivar); end

  # source://opal//lib/opal/nodes/scope.rb#177
  def add_scope_local(local); end

  # source://opal//lib/opal/nodes/scope.rb#194
  def add_scope_temp(tmp); end

  # Returns the value of attribute await_encountered.
  #
  # source://opal//lib/opal/nodes/scope.rb#419
  def await_encountered; end

  # Sets the attribute await_encountered
  #
  # @param value the value to set the attribute await_encountered to.
  #
  # source://opal//lib/opal/nodes/scope.rb#419
  def await_encountered=(_arg0); end

  # The given block name for a def scope
  #
  # source://opal//lib/opal/nodes/scope.rb#15
  def block_name; end

  # The given block name for a def scope
  #
  # source://opal//lib/opal/nodes/scope.rb#15
  def block_name=(_arg0); end

  # Returns the value of attribute catch_return.
  #
  # source://opal//lib/opal/nodes/scope.rb#30
  def catch_return; end

  # Sets the attribute catch_return
  #
  # @param value the value to set the attribute catch_return to.
  #
  # source://opal//lib/opal/nodes/scope.rb#30
  def catch_return=(_arg0); end

  # Returns true if this is strictly a class scope
  #
  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/scope.rb#73
  def class?; end

  # Returns true if this scope is a class/module body scope
  #
  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/scope.rb#68
  def class_scope?; end

  # source://opal//lib/opal/nodes/scope.rb#371
  def collect_refinements_temps(temps = T.unsafe(nil)); end

  # source://opal//lib/opal/nodes/scope.rb#328
  def current_rescue; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/scope.rb#96
  def def?; end

  # Is this a normal def method directly inside a class? This is
  # used for optimizing ivars as we can set them to nil in the
  # class body
  #
  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/scope.rb#121
  def def_in_class?; end

  # source://opal//lib/opal/nodes/scope.rb#108
  def defines_lambda; end

  # true if singleton def, false otherwise
  #
  # source://opal//lib/opal/nodes/scope.rb#25
  def defs; end

  # true if singleton def, false otherwise
  #
  # source://opal//lib/opal/nodes/scope.rb#25
  def defs=(_arg0); end

  # source://opal//lib/opal/nodes/scope.rb#279
  def find_parent_def; end

  # source://opal//lib/opal/nodes/scope.rb#360
  def gen_retry_id; end

  # Returns the value of attribute gvars.
  #
  # source://opal//lib/opal/nodes/scope.rb#20
  def gvars; end

  # Returns the value of attribute has_break.
  #
  # source://opal//lib/opal/nodes/scope.rb#30
  def has_break; end

  # Sets the attribute has_break
  #
  # @param value the value to set the attribute has_break to.
  #
  # source://opal//lib/opal/nodes/scope.rb#30
  def has_break=(_arg0); end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/scope.rb#183
  def has_local?(local); end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/scope.rb#314
  def has_rescue_else?; end

  # Returns the value of attribute has_retry.
  #
  # source://opal//lib/opal/nodes/scope.rb#30
  def has_retry; end

  # Sets the attribute has_retry
  #
  # @param value the value to set the attribute has_retry to.
  #
  # source://opal//lib/opal/nodes/scope.rb#30
  def has_retry=(_arg0); end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/scope.rb#206
  def has_temp?(tmp); end

  # source://opal//lib/opal/nodes/scope.rb#255
  def identify!(name = T.unsafe(nil)); end

  # Returns the value of attribute identity.
  #
  # source://opal//lib/opal/nodes/scope.rb#277
  def identity; end

  # source://opal//lib/opal/nodes/scope.rb#346
  def in_ensure; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/scope.rb#356
  def in_ensure?; end

  # source://opal//lib/opal/nodes/scope.rb#332
  def in_resbody; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/scope.rb#342
  def in_resbody?; end

  # source://opal//lib/opal/nodes/scope.rb#318
  def in_rescue(node); end

  # source://opal//lib/opal/nodes/scope.rb#58
  def in_scope; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/scope.rb#242
  def in_while?; end

  # source://opal//lib/opal/nodes/scope.rb#104
  def is_lambda!; end

  # True if a block/iter scope
  #
  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/scope.rb#92
  def iter?; end

  # Returns the value of attribute ivars.
  #
  # source://opal//lib/opal/nodes/scope.rb#19
  def ivars; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/scope.rb#100
  def lambda?; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/scope.rb#114
  def lambda_definition?; end

  # Returns the value of attribute locals.
  #
  # source://opal//lib/opal/nodes/scope.rb#18
  def locals; end

  # used by modules to know what methods to donate to includees
  #
  # source://opal//lib/opal/nodes/scope.rb#28
  def methods; end

  # Returns the value of attribute mid.
  #
  # source://opal//lib/opal/nodes/scope.rb#22
  def mid; end

  # Sets the attribute mid
  #
  # @param value the value to set the attribute mid to.
  #
  # source://opal//lib/opal/nodes/scope.rb#22
  def mid=(_arg0); end

  # True if this is a module scope
  #
  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/scope.rb#78
  def module?; end

  # The class or module name if this scope is a class scope
  #
  # source://opal//lib/opal/nodes/scope.rb#12
  def name; end

  # The class or module name if this scope is a class scope
  #
  # source://opal//lib/opal/nodes/scope.rb#12
  def name=(_arg0); end

  # Returns '$nesting', but also ensures we compile the nesting chain
  #
  # source://opal//lib/opal/nodes/scope.rb#396
  def nesting; end

  # source://opal//lib/opal/nodes/scope.rb#377
  def new_refinements_temp; end

  # source://opal//lib/opal/nodes/scope.rb#210
  def new_temp; end

  # source://opal//lib/opal/nodes/scope.rb#218
  def next_temp; end

  # Every scope can have a parent scope
  #
  # source://opal//lib/opal/nodes/scope.rb#9
  def parent; end

  # Every scope can have a parent scope
  #
  # source://opal//lib/opal/nodes/scope.rb#9
  def parent=(_arg0); end

  # source://opal//lib/opal/nodes/scope.rb#238
  def pop_while; end

  # source://opal//lib/opal/nodes/scope.rb#407
  def prepare_block(block_name = T.unsafe(nil)); end

  # source://opal//lib/opal/nodes/scope.rb#200
  def prepend_scope_temp(tmp); end

  # source://opal//lib/opal/nodes/scope.rb#232
  def push_while; end

  # source://opal//lib/opal/nodes/scope.rb#228
  def queue_temp(name); end

  # source://opal//lib/opal/nodes/scope.rb#383
  def refinements_temp; end

  # Returns '$$', but also ensures we compile it
  #
  # source://opal//lib/opal/nodes/scope.rb#402
  def relative_access; end

  # Returns the value of attribute rescue_else_sexp.
  #
  # source://opal//lib/opal/nodes/scope.rb#32
  def rescue_else_sexp; end

  # Sets the attribute rescue_else_sexp
  #
  # @param value the value to set the attribute rescue_else_sexp to.
  #
  # source://opal//lib/opal/nodes/scope.rb#32
  def rescue_else_sexp=(_arg0); end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/scope.rb#82
  def sclass?; end

  # source://opal//lib/opal/nodes/scope.rb#189
  def scope_locals; end

  # Returns the value of attribute scope_name.
  #
  # source://opal//lib/opal/nodes/scope.rb#17
  def scope_name; end

  # Returns 'self', but also ensures that the self variable is set
  #
  # source://opal//lib/opal/nodes/scope.rb#390
  def self; end

  # source://opal//lib/opal/nodes/scope.rb#290
  def super_chain; end

  # Vars to use inside each scope
  #
  # source://opal//lib/opal/nodes/scope.rb#127
  def to_vars; end

  # Returns true if this is a top scope (main file body)
  #
  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/scope.rb#87
  def top?; end

  # source://opal//lib/opal/nodes/scope.rb#246
  def uses_block!; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/scope.rb#310
  def uses_block?; end
end

# source://opal//lib/opal/nodes/literal.rb#19
class Opal::Nodes::SelfNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/literal.rb#22
  def compile; end
end

# source://opal//lib/opal/nodes/singleton_class.rb#7
class Opal::Nodes::SingletonClassNode < ::Opal::Nodes::ScopeNode
  # source://opal//lib/opal/nodes/base.rb#24
  def body; end

  # source://opal//lib/opal/nodes/singleton_class.rb#12
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def object; end
end

# source://opal//lib/opal/nodes/logic.rb#60
class Opal::Nodes::SplatNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/logic.rb#69
  def compile; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/logic.rb#65
  def empty_splat?; end

  # source://opal//lib/opal/nodes/base.rb#24
  def value; end
end

# source://opal//lib/opal/nodes/literal.rb#42
class Opal::Nodes::StringNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/literal.rb#64
  def compile; end

  # http://www.2ality.com/2013/09/javascript-unicode.html
  #
  # source://opal//lib/opal/nodes/literal.rb#89
  def to_utf16(code_point); end

  # source://opal//lib/opal/nodes/literal.rb#54
  def translate_escape_chars(inspect_string); end

  # source://opal//lib/opal/nodes/base.rb#24
  def value; end
end

# source://opal//lib/opal/nodes/literal.rb#47
Opal::Nodes::StringNode::ESCAPE_CHARS = T.let(T.unsafe(nil), Hash)

# source://opal//lib/opal/nodes/literal.rb#52
Opal::Nodes::StringNode::ESCAPE_REGEX = T.let(T.unsafe(nil), Regexp)

# super with explicit args
#
# source://opal//lib/opal/nodes/super.rb#124
class Opal::Nodes::SuperNode < ::Opal::Nodes::BaseSuperNode
  # @return [SuperNode] a new instance of SuperNode
  #
  # source://opal//lib/opal/nodes/super.rb#127
  def initialize(*_arg0); end

  # source://opal//lib/opal/nodes/super.rb#135
  def compile; end
end

# source://opal//lib/opal/nodes/literal.rb#107
class Opal::Nodes::SymbolNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/literal.rb#112
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def value; end
end

# Generates code for an entire file, i.e. the base sexp
#
# source://opal//lib/opal/nodes/top.rb#11
class Opal::Nodes::TopNode < ::Opal::Nodes::ScopeNode
  # Returns '$$$', but also ensures that the '$$$' variable is set
  #
  # source://opal//lib/opal/nodes/top.rb#117
  def absolute_const; end

  # source://opal//lib/opal/nodes/top.rb#152
  def add_file_source_embed; end

  # source://opal//lib/opal/nodes/top.rb#128
  def add_used_helpers; end

  # source://opal//lib/opal/nodes/base.rb#24
  def body; end

  # source://opal//lib/opal/nodes/top.rb#94
  def closing; end

  # source://opal//lib/opal/nodes/top.rb#16
  def compile; end

  # Any special __END__ content in code
  #
  # source://opal//lib/opal/nodes/top.rb#141
  def compile_end_construct; end

  # source://opal//lib/opal/nodes/top.rb#122
  def compile_irb_vars; end

  # source://opal//lib/opal/nodes/top.rb#132
  def compile_method_stubs; end

  # source://opal//lib/opal/nodes/top.rb#74
  def definition; end

  # source://opal//lib/opal/nodes/top.rb#70
  def module_name; end

  # source://opal//lib/opal/nodes/top.rb#82
  def opening; end

  # source://opal//lib/opal/nodes/top.rb#112
  def stmts; end

  # source://opal//lib/opal/nodes/top.rb#148
  def version_comment; end
end

# source://opal//lib/opal/nodes/definitions.rb#7
class Opal::Nodes::UndefNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/definitions.rb#12
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def value; end
end

# source://opal//lib/opal/nodes/while.rb#83
class Opal::Nodes::UntilNode < ::Opal::Nodes::WhileNode
  private

  # source://opal//lib/opal/nodes/while.rb#96
  def while_close; end

  # source://opal//lib/opal/nodes/while.rb#88
  def while_open; end
end

# source://opal//lib/opal/nodes/while.rb#117
class Opal::Nodes::UntilPostNode < ::Opal::Nodes::WhilePostNode
  private

  # source://opal//lib/opal/nodes/while.rb#130
  def while_close; end

  # source://opal//lib/opal/nodes/while.rb#122
  def while_open; end
end

# source://opal//lib/opal/nodes/literal.rb#7
class Opal::Nodes::ValueNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/literal.rb#10
  def compile; end

  class << self
    # @return [Boolean]
    #
    # source://opal//lib/opal/nodes/literal.rb#14
    def truthy_optimize?; end
  end
end

# source://opal//lib/opal/nodes/while.rb#7
class Opal::Nodes::WhileNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/base.rb#24
  def body; end

  # source://opal//lib/opal/nodes/while.rb#12
  def compile; end

  # source://opal//lib/opal/nodes/base.rb#24
  def test; end

  private

  # source://opal//lib/opal/nodes/while.rb#55
  def compile_while(test_code, redo_code = T.unsafe(nil)); end

  # source://opal//lib/opal/nodes/while.rb#47
  def compile_with_redo(test_code); end

  # source://opal//lib/opal/nodes/while.rb#51
  def compile_without_redo(test_code); end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/while.rb#74
  def uses_redo?; end

  # source://opal//lib/opal/nodes/while.rb#70
  def while_close; end

  # source://opal//lib/opal/nodes/while.rb#62
  def while_open; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/nodes/while.rb#78
  def wrap_in_closure?; end
end

# source://opal//lib/opal/nodes/while.rb#101
class Opal::Nodes::WhilePostNode < ::Opal::Nodes::WhileNode
  private

  # source://opal//lib/opal/nodes/while.rb#106
  def compile_while(test_code, redo_code = T.unsafe(nil)); end

  # source://opal//lib/opal/nodes/while.rb#112
  def while_close; end
end

# source://opal//lib/opal/nodes/x_string.rb#5
class Opal::Nodes::XStringNode < ::Opal::Nodes::Base
  # source://opal//lib/opal/nodes/x_string.rb#8
  def compile; end

  # source://opal//lib/opal/nodes/x_string.rb#21
  def compile_javascript; end

  # source://opal//lib/opal/nodes/x_string.rb#16
  def compile_send; end

  private

  # source://opal//lib/opal/nodes/x_string.rb#74
  def compile_child(child); end

  # source://opal//lib/opal/nodes/x_string.rb#87
  def compile_single_line(children); end

  # Will drop the trailing semicolon if all conditions are met
  #
  # source://opal//lib/opal/nodes/x_string.rb#120
  def extract_last_value(last_child); end

  # A case for manually created :js_return statement in Compiler#returns
  # Since we need to take original source of :str we have to use raw source
  # so we need to combine "return" with "raw_source"
  #
  # source://opal//lib/opal/nodes/x_string.rb#141
  def unpack_return(children); end

  class << self
    # Check if there's only one child or if they're all part of
    # the same line (e.g. because of interpolations)
    #
    # @return [Boolean]
    #
    # source://opal//lib/opal/nodes/x_string.rb#48
    def single_line?(children); end

    # Will remove empty :str lines coming from cosmetic newlines in x-strings
    #
    # @example
    #   # this will generate two additional empty
    #   # children before and after `foo()`
    #   %x{
    #   foo()
    #   }
    #
    # source://opal//lib/opal/nodes/x_string.rb#62
    def strip_empty_children(children); end
  end
end

# source://opal//lib/opal/nodes/yield.rb#51
class Opal::Nodes::YieldNode < ::Opal::Nodes::BaseYieldNode
  # source://opal//lib/opal/nodes/yield.rb#54
  def compile; end
end

# super with implicit args
#
# source://opal//lib/opal/nodes/super.rb#141
class Opal::Nodes::ZsuperNode < ::Opal::Nodes::SuperNode
  # @return [ZsuperNode] a new instance of ZsuperNode
  #
  # source://opal//lib/opal/nodes/super.rb#148
  def initialize(*_arg0); end

  # source://opal//lib/opal/nodes/super.rb#203
  def block_name; end

  # source://opal//lib/opal/nodes/super.rb#160
  def compile; end

  # source://opal//lib/opal/nodes/super.rb#176
  def implicit_arglist; end

  # source://opal//lib/opal/nodes/super.rb#144
  def implicit_arguments_param; end
end

# source://opal//lib/opal/os.rb#4
module Opal::OS
  private

  # source://opal//lib/opal/os.rb#39
  def bash_c(*commands); end

  # source://opal//lib/opal/os.rb#31
  def cmd_sep; end

  # source://opal//lib/opal/os.rb#35
  def dev_null; end

  # source://opal//lib/opal/os.rb#23
  def env_sep; end

  # source://opal//lib/opal/os.rb#11
  def macos?; end

  # source://opal//lib/opal/os.rb#27
  def path_sep; end

  # source://opal//lib/opal/os.rb#15
  def shellescape(str); end

  # source://opal//lib/opal/os.rb#7
  def windows?; end

  class << self
    # source://opal//lib/opal/os.rb#39
    def bash_c(*commands); end

    # source://opal//lib/opal/os.rb#31
    def cmd_sep; end

    # source://opal//lib/opal/os.rb#35
    def dev_null; end

    # source://opal//lib/opal/os.rb#23
    def env_sep; end

    # @return [Boolean]
    #
    # source://opal//lib/opal/os.rb#11
    def macos?; end

    # source://opal//lib/opal/os.rb#27
    def path_sep; end

    # source://opal//lib/opal/os.rb#15
    def shellescape(str); end

    # @return [Boolean]
    #
    # source://opal//lib/opal/os.rb#7
    def windows?; end
  end
end

# Loosely compatible with Thread::Backtrace::Location
#
# source://opal//lib/opal/errors.rb#49
class Opal::OpalBacktraceLocation
  # @return [OpalBacktraceLocation] a new instance of OpalBacktraceLocation
  #
  # source://opal//lib/opal/errors.rb#52
  def initialize(path = T.unsafe(nil), lineno = T.unsafe(nil), label = T.unsafe(nil)); end

  # source://opal//lib/opal/errors.rb#70
  def diagnostic=(diagnostic); end

  # Returns the value of attribute label.
  #
  # source://opal//lib/opal/errors.rb#50
  def label; end

  # Sets the attribute label
  #
  # @param value the value to set the attribute label to.
  #
  # source://opal//lib/opal/errors.rb#50
  def label=(_arg0); end

  # Returns the value of attribute lineno.
  #
  # source://opal//lib/opal/errors.rb#50
  def line; end

  # Returns the value of attribute lineno.
  #
  # source://opal//lib/opal/errors.rb#50
  def lineno; end

  # Sets the attribute lineno
  #
  # @param value the value to set the attribute lineno to.
  #
  # source://opal//lib/opal/errors.rb#50
  def lineno=(_arg0); end

  # source://opal//lib/opal/errors.rb#75
  def location=(location); end

  # Returns the value of attribute path.
  #
  # source://opal//lib/opal/errors.rb#50
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  #
  # source://opal//lib/opal/errors.rb#50
  def path=(_arg0); end

  # source://opal//lib/opal/errors.rb#56
  def to_s; end
end

# source://opal//lib/opal/parser/source_buffer.rb#4
module Opal::Parser
  class << self
    # source://opal//lib/opal/parser/default_config.rb#46
    def default_parser; end

    # Returns the value of attribute default_parser_class.
    #
    # source://opal//lib/opal/parser/default_config.rb#44
    def default_parser_class; end

    # Sets the attribute default_parser_class
    #
    # @param value the value to set the attribute default_parser_class to.
    #
    # source://opal//lib/opal/parser/default_config.rb#44
    def default_parser_class=(_arg0); end
  end
end

# source://opal//lib/opal/parser/default_config.rb#5
module Opal::Parser::DefaultConfig
  mixes_in_class_methods ::Opal::Parser::DefaultConfig::ClassMethods

  # source://opal//lib/opal/parser/default_config.rb#27
  def initialize(*_arg0); end

  # source://opal//lib/opal/parser/default_config.rb#31
  def parse(source_buffer); end

  # source://opal//lib/opal/parser/default_config.rb#38
  def rewrite(node); end

  class << self
    # @private
    #
    # source://opal//lib/opal/parser/default_config.rb#18
    def included(klass); end
  end
end

# source://opal//lib/opal/parser/default_config.rb#6
module Opal::Parser::DefaultConfig::ClassMethods
  # source://opal//lib/opal/parser/default_config.rb#9
  def default_parser; end

  # Returns the value of attribute diagnostics_consumer.
  #
  # source://opal//lib/opal/parser/default_config.rb#7
  def diagnostics_consumer; end

  # Sets the attribute diagnostics_consumer
  #
  # @param value the value to set the attribute diagnostics_consumer to.
  #
  # source://opal//lib/opal/parser/default_config.rb#7
  def diagnostics_consumer=(_arg0); end
end

# source://opal//lib/opal/parser/source_buffer.rb#5
class Opal::Parser::SourceBuffer < ::Parser::Source::Buffer
  class << self
    # source://opal//lib/opal/parser/source_buffer.rb#6
    def recognize_encoding(string); end
  end
end

# source://opal//lib/opal/parser/with_ruby_lexer.rb#3
class Opal::Parser::WithRubyLexer < ::Parser::Ruby32
  include ::Opal::Parser::DefaultConfig
  extend ::Opal::Parser::DefaultConfig::ClassMethods
end

# source://opal//lib/opal/errors.rb#24
class Opal::ParsingError < ::Opal::CompilationError; end

# source://opal//lib/opal/path_reader.rb#7
class Opal::PathReader
  # @return [PathReader] a new instance of PathReader
  #
  # source://opal//lib/opal/path_reader.rb#11
  def initialize(paths = T.unsafe(nil), extensions = T.unsafe(nil)); end

  # source://opal//lib/opal/path_reader.rb#39
  def append_paths(*paths); end

  # source://opal//lib/opal/path_reader.rb#23
  def expand(path); end

  # source://opal//lib/opal/path_reader.rb#35
  def extensions; end

  # source://opal//lib/opal/path_reader.rb#31
  def paths; end

  # source://opal//lib/opal/path_reader.rb#17
  def read(path); end

  private

  # Returns the value of attribute file_finder.
  #
  # source://opal//lib/opal/path_reader.rb#51
  def file_finder; end

  # source://opal//lib/opal/path_reader.rb#45
  def find_path(path); end
end

# source://opal//lib/opal/path_reader.rb#9
Opal::PathReader::DEFAULT_EXTENSIONS = T.let(T.unsafe(nil), Array)

# source://opal//lib/opal/path_reader.rb#8
Opal::PathReader::RELATIVE_PATH_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://opal//lib/opal/regexp_anchors.rb#5
Opal::REGEXP_END = T.let(T.unsafe(nil), String)

# source://opal//lib/opal/regexp_anchors.rb#4
Opal::REGEXP_START = T.let(T.unsafe(nil), String)

# source://opal//lib/opal/rewriter.rb#23
class Opal::Rewriter
  # @return [Rewriter] a new instance of Rewriter
  #
  # source://opal//lib/opal/rewriter.rb#76
  def initialize(sexp); end

  # source://opal//lib/opal/rewriter.rb#80
  def process; end

  class << self
    # source://opal//lib/opal/rewriter.rb#35
    def delete(rewriter); end

    # source://opal//lib/opal/rewriter.rb#39
    def disable(except: T.unsafe(nil)); end

    # @return [Boolean]
    #
    # source://opal//lib/opal/rewriter.rb#47
    def disabled?; end

    # source://opal//lib/opal/rewriter.rb#27
    def list; end

    # @return [Boolean]
    #
    # source://opal//lib/opal/rewriter.rb#51
    def rewritter_disabled?(rewriter); end

    # source://opal//lib/opal/rewriter.rb#31
    def use(rewriter); end
  end
end

# source://opal//lib/opal/rewriters/base.rb#7
module Opal::Rewriters; end

# source://opal//lib/opal/rewriters/arguments.rb#5
class Opal::Rewriters::Arguments
  # @return [Arguments] a new instance of Arguments
  #
  # source://opal//lib/opal/rewriters/arguments.rb#10
  def initialize(args); end

  # Returns the value of attribute args.
  #
  # source://opal//lib/opal/rewriters/arguments.rb#6
  def args; end

  # Returns the value of attribute blockarg.
  #
  # source://opal//lib/opal/rewriters/arguments.rb#6
  def blockarg; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/rewriters/arguments.rb#56
  def can_inline_kwargs?; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/rewriters/arguments.rb#52
  def has_any_kwargs?; end

  # @return [Boolean]
  #
  # source://opal//lib/opal/rewriters/arguments.rb#48
  def has_post_args?; end

  # Returns the value of attribute kwargs.
  #
  # source://opal//lib/opal/rewriters/arguments.rb#6
  def kwargs; end

  # Returns the value of attribute kwnilarg.
  #
  # source://opal//lib/opal/rewriters/arguments.rb#6
  def kwnilarg; end

  # Returns the value of attribute kwoptargs.
  #
  # source://opal//lib/opal/rewriters/arguments.rb#6
  def kwoptargs; end

  # Returns the value of attribute kwrestarg.
  #
  # source://opal//lib/opal/rewriters/arguments.rb#6
  def kwrestarg; end

  # Returns the value of attribute optargs.
  #
  # source://opal//lib/opal/rewriters/arguments.rb#6
  def optargs; end

  # Returns the value of attribute postargs.
  #
  # source://opal//lib/opal/rewriters/arguments.rb#6
  def postargs; end

  # Returns the value of attribute restarg.
  #
  # source://opal//lib/opal/rewriters/arguments.rb#6
  def restarg; end

  # Returns the value of attribute shadowargs.
  #
  # source://opal//lib/opal/rewriters/arguments.rb#6
  def shadowargs; end
end

# source://opal//lib/opal/rewriters/base.rb#8
class Opal::Rewriters::Base < ::Parser::AST::Processor
  # Appends given +node+ to +body+ node.
  #
  # Supports +body+ to be one of:
  # 1. nil                     - empty body
  # 2. s(:begin) / s(:kwbegin) - multiline body
  # 3. s(:anything_else)       - singleline body
  #
  # Returns a new body with +node+ injected as a last statement.
  #
  # source://opal//lib/opal/rewriters/base.rb#83
  def append_to_body(body, node); end

  # source://opal//lib/opal/rewriters/base.rb#98
  def begin_with_stmts(stmts); end

  # Store the current node for reporting.
  #
  # source://opal//lib/opal/rewriters/base.rb#110
  def current_node; end

  # Store the current node for reporting.
  #
  # source://opal//lib/opal/rewriters/base.rb#110
  def current_node=(_arg0); end

  # Called when a given transformation is deemed to be dynamic, so
  # that cache is conditionally disabled for a given file.
  #
  # source://opal//lib/opal/rewriters/base.rb#135
  def dynamic!; end

  # This is called when a rewriting error occurs.
  #
  # source://opal//lib/opal/rewriters/base.rb#121
  def error(msg); end

  # source://parser/3.3.4.0/lib/parser/ast/processor.rb#12
  def on_iter(node); end

  # source://parser/3.3.4.0/lib/parser/ast/processor.rb#12
  def on_jsattr(node); end

  # source://parser/3.3.4.0/lib/parser/ast/processor.rb#12
  def on_jsattrasgn(node); end

  # source://parser/3.3.4.0/lib/parser/ast/processor.rb#181
  def on_jscall(node); end

  # source://parser/3.3.4.0/lib/parser/ast/processor.rb#12
  def on_kwsplat(node); end

  # source://opal//lib/opal/rewriters/base.rb#127
  def on_top(node); end

  # source://parser/3.3.4.0/lib/parser/ast/processor.rb#12
  def on_zsuper(node); end

  # Prepends given +node+ to +body+ node.
  #
  # Supports +body+ to be one of:
  # 1. nil                     - empty body
  # 2. s(:begin) / s(:kwbegin) - multiline body
  # 3. s(:anything_else)       - singleline body
  #
  # Returns a new body with +node+ injected as a first statement.
  #
  # source://opal//lib/opal/rewriters/base.rb#69
  def prepend_to_body(body, node); end

  # Intercept the main call and assign current node.
  #
  # source://opal//lib/opal/rewriters/base.rb#113
  def process(node); end

  # source://opal//lib/opal/rewriters/base.rb#44
  def s(type, *children); end

  # source://opal//lib/opal/rewriters/base.rb#88
  def stmts_of(node); end

  class << self
    # source://opal//lib/opal/rewriters/base.rb#49
    def s(type, *children); end
  end
end

# source://opal//lib/opal/rewriters/base.rb#42
Opal::Rewriters::Base::DUMMY_LOCATION = T.let(T.unsafe(nil), Opal::Rewriters::Base::DummyLocation)

# source://opal//lib/opal/rewriters/base.rb#9
class Opal::Rewriters::Base::DummyLocation
  # source://opal//lib/opal/rewriters/base.rb#18
  def begin_pos; end

  # source://opal//lib/opal/rewriters/base.rb#34
  def column; end

  # source://opal//lib/opal/rewriters/base.rb#22
  def end_pos; end

  # source://opal//lib/opal/rewriters/base.rb#14
  def expression; end

  # source://opal//lib/opal/rewriters/base.rb#38
  def last_line; end

  # source://opal//lib/opal/rewriters/base.rb#30
  def line; end

  # source://opal//lib/opal/rewriters/base.rb#10
  def node=(*_arg0); end

  # source://opal//lib/opal/rewriters/base.rb#26
  def source; end
end

# source://opal//lib/opal/rewriters/binary_operator_assignment.rb#7
class Opal::Rewriters::BinaryOperatorAssignment < ::Opal::Rewriters::Base
  # Rewrites any or_asgn and and_asgn node like
  #   `defined?(a ||= 1)`
  # and
  #   `defined?(a &&= 1)`
  # to a static "assignment" string node
  #
  # @return [Boolean]
  #
  # source://opal//lib/opal/rewriters/binary_operator_assignment.rb#131
  def on_defined?(node); end

  # lhs += rhs
  #
  # source://opal//lib/opal/rewriters/binary_operator_assignment.rb#114
  def on_op_asgn(node); end

  class << self
    # source://opal//lib/opal/rewriters/binary_operator_assignment.rb#12
    def new_temp; end

    # source://opal//lib/opal/rewriters/binary_operator_assignment.rb#8
    def reset_tmp_counter!; end
  end
end

# source://opal//lib/opal/rewriters/binary_operator_assignment.rb#124
Opal::Rewriters::BinaryOperatorAssignment::ASSIGNMENT_STRING_NODE = T.let(T.unsafe(nil), Opal::AST::Node)

# Takes    `@@lhs += rhs`
# Produces `@@lhs = @@lhs + rhs`
#
# source://opal//lib/opal/rewriters/binary_operator_assignment.rb#45
Opal::Rewriters::BinaryOperatorAssignment::ClassVariableHandler = T.let(T.unsafe(nil), Proc)

# Takes    `recvr.meth += rhs`
# Produces `recvr.nil? ? nil : recvr.meth += rhs`
#   NOTE: Later output of this handler gets post-processed by this rewriter again
#   using SendHandler to `recvr.nil? ? nil : (recvr.meth = recvr.meth + rhs)`
#
# source://opal//lib/opal/rewriters/binary_operator_assignment.rb#80
class Opal::Rewriters::BinaryOperatorAssignment::ConditionalSendHandler < ::Opal::Rewriters::BinaryOperatorAssignment
  class << self
    # source://opal//lib/opal/rewriters/binary_operator_assignment.rb#81
    def call(node, lhs, operation, rhs); end
  end
end

# Takes    `LHS += rhs`
# Produces `LHS = LHS + rhs`
#
# source://opal//lib/opal/rewriters/binary_operator_assignment.rb#37
Opal::Rewriters::BinaryOperatorAssignment::ConstantHandler = T.let(T.unsafe(nil), Proc)

# source://opal//lib/opal/rewriters/binary_operator_assignment.rb#18
Opal::Rewriters::BinaryOperatorAssignment::GET_SET = T.let(T.unsafe(nil), Proc)

# Takes    `$lhs += rhs`
# Produces `$lhs = $lhs + rhs`
#
# source://opal//lib/opal/rewriters/binary_operator_assignment.rb#41
Opal::Rewriters::BinaryOperatorAssignment::GlobalVariableHandler = T.let(T.unsafe(nil), Proc)

# source://opal//lib/opal/rewriters/binary_operator_assignment.rb#103
Opal::Rewriters::BinaryOperatorAssignment::HANDLERS = T.let(T.unsafe(nil), Hash)

# Takes    `@lhs += rhs`
# Produces `@lhs = @lhs + rhs`
#
# source://opal//lib/opal/rewriters/binary_operator_assignment.rb#33
Opal::Rewriters::BinaryOperatorAssignment::InstanceVariableHandler = T.let(T.unsafe(nil), Proc)

# Takes    `lhs += rhs`
# Produces `lhs = lhs + rhs`
#
# source://opal//lib/opal/rewriters/binary_operator_assignment.rb#29
Opal::Rewriters::BinaryOperatorAssignment::LocalVariableHandler = T.let(T.unsafe(nil), Proc)

# Takes    `recvr.meth += rhs`
# Produces `recvr.meth = recvr.meth + rhs`
# (lhs is a recvr.meth, op is :+)
#
# source://opal//lib/opal/rewriters/binary_operator_assignment.rb#50
class Opal::Rewriters::BinaryOperatorAssignment::SendHandler < ::Opal::Rewriters::BinaryOperatorAssignment
  class << self
    # source://opal//lib/opal/rewriters/binary_operator_assignment.rb#51
    def call(node, lhs, operation, rhs); end
  end
end

# source://opal//lib/opal/rewriters/block_to_iter.rb#7
class Opal::Rewriters::BlockToIter < ::Opal::Rewriters::Base
  # source://opal//lib/opal/rewriters/block_to_iter.rb#8
  def on_block(node); end
end

# Ruby allows for args with the same name, if the arg starts with a '_', like:
#   def funny_method_name(_, _)
#     puts _
#   end
# but JavaScript in strict mode does not allow for args with the same name
# Ruby assigns the value of the first arg given
#   funny_method_name(1, 2) => 1
# leave the first appearance as it is and rename the other ones
# compiler result:
#   function $$funny_method_name(_, __$2)
#
# source://opal//lib/opal/rewriters/deduplicate_arg_name.rb#15
class Opal::Rewriters::DeduplicateArgName < ::Opal::Rewriters::Base
  # source://opal//lib/opal/rewriters/deduplicate_arg_name.rb#16
  def on_args(node); end

  # source://opal//lib/opal/rewriters/deduplicate_arg_name.rb#26
  def rename_arg(arg); end

  # source://opal//lib/opal/rewriters/deduplicate_arg_name.rb#42
  def unique_name(name); end
end

# source://opal//lib/opal/rewriters/dot_js_syntax.rb#7
class Opal::Rewriters::DotJsSyntax < ::Opal::Rewriters::Base
  # source://opal//lib/opal/rewriters/dot_js_syntax.rb#8
  def on_send(node); end

  # @param recv [AST::Node] receiver of .JS[]= method
  # @param property [AST::Node] property passed to brackets
  # @param value [AST::Node] value of assignment
  #
  # source://opal//lib/opal/rewriters/dot_js_syntax.rb#56
  def to_js_attr_assign_call(recv, property, value); end

  # @param recv [AST::Node] receiver of .JS[] method
  # @param property [AST::Node] argument passed to .JS[] method
  #
  # source://opal//lib/opal/rewriters/dot_js_syntax.rb#49
  def to_js_attr_call(recv, property); end

  # @param recv [AST::Node] receiver of .JS. method
  # @param meth [Symbol] name of the JS method
  # @param args [Array<AST::Node>] list of the arguments passed to JS method
  #
  # source://opal//lib/opal/rewriters/dot_js_syntax.rb#43
  def to_native_js_call(recv, meth, args); end
end

# source://opal//lib/opal/rewriters/dump_args.rb#7
class Opal::Rewriters::DumpArgs < ::Opal::Rewriters::Base
  # source://opal//lib/opal/rewriters/dump_args.rb#8
  def on_def(node); end

  # source://opal//lib/opal/rewriters/dump_args.rb#14
  def on_defs(node); end

  # source://opal//lib/opal/rewriters/dump_args.rb#21
  def on_iter(node); end
end

# source://opal//lib/opal/rewriters/for_rewriter.rb#7
class Opal::Rewriters::ForRewriter < ::Opal::Rewriters::Base
  # Handles
  #   for i in 0..3; j = i + 1; end
  #
  # The problem here is that in Ruby for loop makes its
  # loop variable + all local variables available outside.
  # I.e. after this loop variable `i` is 3 and `j` is 4
  #
  # This class rewrites it to the following code:
  #   j = nil
  #   i = nil
  #   (0..3).each { |__jstmp| i = __jstmp; j = i + 1 }
  #
  # Complex stuff with multiple loop variables:
  #   for i, j in [[1, 2], [3, 4]]; end
  # Becomes multiple left-hand assignment:
  #   i = nil
  #   j = nil
  #   [[1, 2], [3, 4]].each { |__jstmp| i, j = __jstmp }
  #
  # source://opal//lib/opal/rewriters/for_rewriter.rb#38
  def on_for(node); end

  private

  # source://opal//lib/opal/rewriters/for_rewriter.rb#66
  def assign_loop_variable(loop_variable, tmp_loop_variable); end

  # source://opal//lib/opal/rewriters/for_rewriter.rb#59
  def generate_outer_assignments(loop_variable, loop_body); end

  # source://opal//lib/opal/rewriters/for_rewriter.rb#76
  def transform_for_to_each_loop(node, loop_range, tmp_loop_variable, loop_body); end

  class << self
    # source://opal//lib/opal/rewriters/for_rewriter.rb#12
    def next_tmp; end

    # source://opal//lib/opal/rewriters/for_rewriter.rb#8
    def reset_tmp_counter!; end
  end
end

# source://opal//lib/opal/rewriters/for_rewriter.rb#84
class Opal::Rewriters::ForRewriter::LocalVariableAssigns < ::Opal::Rewriters::Base
  # @return [LocalVariableAssigns] a new instance of LocalVariableAssigns
  #
  # source://opal//lib/opal/rewriters/for_rewriter.rb#93
  def initialize; end

  # source://opal//lib/opal/rewriters/for_rewriter.rb#97
  def on_lvasgn(node); end

  # Returns the value of attribute result.
  #
  # source://opal//lib/opal/rewriters/for_rewriter.rb#85
  def result; end

  class << self
    # source://opal//lib/opal/rewriters/for_rewriter.rb#87
    def find(node); end
  end
end

# source://opal//lib/opal/rewriters/forward_args.rb#7
class Opal::Rewriters::ForwardArgs < ::Opal::Rewriters::Base
  # source://opal//lib/opal/rewriters/forward_args.rb#38
  def on_args(node); end

  # source://opal//lib/opal/rewriters/forward_args.rb#26
  def on_block_pass(node); end

  # source://opal//lib/opal/rewriters/forward_args.rb#70
  def on_blockarg(node); end

  # source://opal//lib/opal/rewriters/forward_args.rb#8
  def on_forward_args(_node); end

  # source://opal//lib/opal/rewriters/forward_args.rb#20
  def on_forwarded_kwrestarg(_node); end

  # source://opal//lib/opal/rewriters/forward_args.rb#14
  def on_forwarded_restarg(_node); end

  # source://opal//lib/opal/rewriters/forward_args.rb#62
  def on_kwrestarg(node); end

  # source://opal//lib/opal/rewriters/forward_args.rb#54
  def on_restarg(node); end

  # source://opal//lib/opal/rewriters/forward_args.rb#78
  def on_send(node); end
end

# source://opal//lib/opal/rewriters/hashes/key_duplicates_rewriter.rb#8
module Opal::Rewriters::Hashes; end

# source://opal//lib/opal/rewriters/hashes/key_duplicates_rewriter.rb#9
class Opal::Rewriters::Hashes::KeyDuplicatesRewriter < ::Opal::Rewriters::Base
  # @return [KeyDuplicatesRewriter] a new instance of KeyDuplicatesRewriter
  #
  # source://opal//lib/opal/rewriters/hashes/key_duplicates_rewriter.rb#10
  def initialize; end

  # source://opal//lib/opal/rewriters/hashes/key_duplicates_rewriter.rb#14
  def on_hash(node); end

  # source://opal//lib/opal/rewriters/hashes/key_duplicates_rewriter.rb#31
  def on_kwsplat(node); end

  # source://opal//lib/opal/rewriters/hashes/key_duplicates_rewriter.rb#21
  def on_pair(node); end
end

# source://opal//lib/opal/rewriters/hashes/key_duplicates_rewriter.rb#41
class Opal::Rewriters::Hashes::KeyDuplicatesRewriter::UniqKeysSet
  # @return [UniqKeysSet] a new instance of UniqKeysSet
  #
  # source://opal//lib/opal/rewriters/hashes/key_duplicates_rewriter.rb#42
  def initialize; end

  # source://opal//lib/opal/rewriters/hashes/key_duplicates_rewriter.rb#46
  def <<(element); end
end

# Converts
#
#   def m( a, b = 1, *c, d, e:, f: 1, **g, &blk )
#   end
#
# To something like
#
#   def m( a, <fake b>, <fake c>, <fake d>, <fake kwargs>)
#     blk = <extract block>
#     $post_args = arguments[1..-1]
#     $kwargs = $post_args.pop
#     a = <enough args> ? $post_args.shift : 1
#     c = <enough args> ? $post_args[0..-1] : []
#     d = $post_args.last
#     e = $kwargs.delete(:e)
#     f = $kwargs.delete(:f) || 1
#     g = $kwargs.except(:e, :f)
#   end
#
# source://opal//lib/opal/rewriters/inline_args.rb#27
class Opal::Rewriters::InlineArgs < ::Opal::Rewriters::Base
  # source://opal//lib/opal/rewriters/inline_args.rb#28
  def on_def(node); end

  # source://opal//lib/opal/rewriters/inline_args.rb#41
  def on_defs(node); end

  # source://opal//lib/opal/rewriters/inline_args.rb#54
  def on_iter(node); end
end

# source://opal//lib/opal/rewriters/inline_args.rb#67
class Opal::Rewriters::InlineArgs::Initializer < ::Opal::Rewriters::Base
  # @return [Initializer] a new instance of Initializer
  #
  # source://opal//lib/opal/rewriters/inline_args.rb#87
  def initialize(args, type:); end

  # source://opal//lib/opal/rewriters/inline_args.rb#202
  def args_to_keep; end

  # source://opal//lib/opal/rewriters/inline_args.rb#118
  def extract_args; end

  # source://opal//lib/opal/rewriters/inline_args.rb#106
  def extract_blockarg; end

  # source://opal//lib/opal/rewriters/inline_args.rb#152
  def extract_kwargs; end

  # source://opal//lib/opal/rewriters/inline_args.rb#158
  def extract_kwoptargs; end

  # source://opal//lib/opal/rewriters/inline_args.rb#164
  def extract_kwrestarg; end

  # source://opal//lib/opal/rewriters/inline_args.rb#178
  def extract_optargs; end

  # source://opal//lib/opal/rewriters/inline_args.rb#170
  def extract_post_args; end

  # source://opal//lib/opal/rewriters/inline_args.rb#194
  def extract_restarg; end

  # Returns the value of attribute initialization.
  #
  # source://opal//lib/opal/rewriters/inline_args.rb#68
  def initialization; end

  # source://opal//lib/opal/rewriters/inline_args.rb#112
  def initialize_shadowargs; end

  # Returns the value of attribute inline.
  #
  # source://opal//lib/opal/rewriters/inline_args.rb#68
  def inline; end

  # source://opal//lib/opal/rewriters/inline_args.rb#139
  def prepare_kwargs; end

  # source://opal//lib/opal/rewriters/inline_args.rb#133
  def prepare_post_args; end
end

# source://opal//lib/opal/rewriters/inline_args.rb#70
Opal::Rewriters::InlineArgs::Initializer::STEPS = T.let(T.unsafe(nil), Array)

# source://opal//lib/opal/rewriters/js_reserved_words.rb#8
class Opal::Rewriters::JsReservedWords < ::Opal::Rewriters::Base
  # source://opal//lib/opal/rewriters/js_reserved_words.rb#47
  def fix_ivar_name(name); end

  # source://opal//lib/opal/rewriters/js_reserved_words.rb#43
  def fix_var_name(name); end

  # source://opal//lib/opal/rewriters/js_reserved_words.rb#104
  def on_argument(node); end

  # source://opal//lib/opal/rewriters/js_reserved_words.rb#70
  def on_ivar(node); end

  # source://opal//lib/opal/rewriters/js_reserved_words.rb#76
  def on_ivasgn(node); end

  # Restarg and kwrestarg are special cases
  # because they may have no name
  # def m(*, **); end
  #
  # source://opal//lib/opal/rewriters/js_reserved_words.rb#92
  def on_kwrestarg(node); end

  # source://opal//lib/opal/rewriters/js_reserved_words.rb#51
  def on_lvar(node); end

  # source://opal//lib/opal/rewriters/js_reserved_words.rb#57
  def on_lvasgn(node); end

  # Restarg and kwrestarg are special cases
  # because they may have no name
  # def m(*, **); end
  #
  # source://opal//lib/opal/rewriters/js_reserved_words.rb#92
  def on_restarg(node); end

  class << self
    # @return [Boolean]
    #
    # source://opal//lib/opal/rewriters/js_reserved_words.rb#39
    def valid_ivar_name?(name); end

    # @return [Boolean]
    #
    # source://opal//lib/opal/rewriters/js_reserved_words.rb#31
    def valid_name?(name); end
  end
end

# Doesn't take in account utf8
#
# source://opal//lib/opal/rewriters/js_reserved_words.rb#26
Opal::Rewriters::JsReservedWords::BASIC_IDENTIFIER_RULES = T.let(T.unsafe(nil), Regexp)

# ES3 reserved words that arent ES5.1 reserved words
#
# source://opal//lib/opal/rewriters/js_reserved_words.rb#14
Opal::Rewriters::JsReservedWords::ES3_RESERVED_WORD_EXCLUSIVE = T.let(T.unsafe(nil), Regexp)

# Reserved javascript keywords - we cannot create variables with the
# same name (ref: http://stackoverflow.com/a/9337272/601782)
#
# source://opal//lib/opal/rewriters/js_reserved_words.rb#11
Opal::Rewriters::JsReservedWords::ES51_RESERVED_WORD = T.let(T.unsafe(nil), Regexp)

# Immutable properties of the global object
#
# source://opal//lib/opal/rewriters/js_reserved_words.rb#23
Opal::Rewriters::JsReservedWords::IMMUTABLE_PROPS = T.let(T.unsafe(nil), Regexp)

# Prototype special methods.
#
# source://opal//lib/opal/rewriters/js_reserved_words.rb#20
Opal::Rewriters::JsReservedWords::PROTO_SPECIAL_METHODS = T.let(T.unsafe(nil), Regexp)

# Prototype special properties.
#
# source://opal//lib/opal/rewriters/js_reserved_words.rb#17
Opal::Rewriters::JsReservedWords::PROTO_SPECIAL_PROPS = T.let(T.unsafe(nil), Regexp)

# Defining a local function like Array may break everything
#
# source://opal//lib/opal/rewriters/js_reserved_words.rb#29
Opal::Rewriters::JsReservedWords::RESERVED_FUNCTION_NAMES = T.let(T.unsafe(nil), Regexp)

# source://opal//lib/opal/rewriters/logical_operator_assignment.rb#7
class Opal::Rewriters::LogicalOperatorAssignment < ::Opal::Rewriters::Base
  # lhs &&= rhs
  #
  # source://opal//lib/opal/rewriters/logical_operator_assignment.rb#140
  def on_and_asgn(node); end

  # Rewrites any or_asgn and and_asgn node like
  #   `defined?(a ||= 1)`
  # and
  #   `defined?(a &&= 1)`
  # to a static "assignment" string node
  #
  # @return [Boolean]
  #
  # source://opal//lib/opal/rewriters/logical_operator_assignment.rb#157
  def on_defined?(node); end

  # lhs ||= rhs
  #
  # source://opal//lib/opal/rewriters/logical_operator_assignment.rb#129
  def on_or_asgn(node); end

  class << self
    # source://opal//lib/opal/rewriters/logical_operator_assignment.rb#12
    def new_temp; end

    # source://opal//lib/opal/rewriters/logical_operator_assignment.rb#8
    def reset_tmp_counter!; end
  end
end

# source://opal//lib/opal/rewriters/logical_operator_assignment.rb#150
Opal::Rewriters::LogicalOperatorAssignment::ASSIGNMENT_STRING_NODE = T.let(T.unsafe(nil), Opal::AST::Node)

# Takes    `@@lhs ||= rhs`
# Produces `@@lhs = defined?(@@lhs) ? (@@lhs || rhs) : rhs`
#
# Takes    `@@lhs &&= rhs`
# Produces `@@lhs = @@lhs && rhs`
#
# source://opal//lib/opal/rewriters/logical_operator_assignment.rb#58
Opal::Rewriters::LogicalOperatorAssignment::ClassVariableHandler = T.let(T.unsafe(nil), Proc)

# Takes    `recvr&.meth ||= rhs`
# Produces `recvr.nil? ? nil : recvr.meth ||= rhs`
#   NOTE: Later output of this handler gets post-processed by this rewriter again
#   using SendHandler to `recvr.nil? ? nil : (recvr.meth || recvr.meth = rhs)`
#
# source://opal//lib/opal/rewriters/logical_operator_assignment.rb#93
class Opal::Rewriters::LogicalOperatorAssignment::ConditionalSendHandler < ::Opal::Rewriters::LogicalOperatorAssignment
  class << self
    # source://opal//lib/opal/rewriters/logical_operator_assignment.rb#94
    def call(lhs, rhs, root_type); end
  end
end

# Takes    `LHS ||= rhs`
# Produces `LHS = defined?(LHS) ? (LHS || rhs) : rhs`
#
# Takes    `LHS &&= rhs`
# Produces `LHS = LHS && rhs`
#
# source://opal//lib/opal/rewriters/logical_operator_assignment.rb#47
Opal::Rewriters::LogicalOperatorAssignment::ConstantHandler = T.let(T.unsafe(nil), Proc)

# source://opal//lib/opal/rewriters/logical_operator_assignment.rb#18
Opal::Rewriters::LogicalOperatorAssignment::GET_SET = T.let(T.unsafe(nil), Proc)

# Takes    `$lhs ||= rhs`
# Produces `$lhs = $lhs || rhs`
#
# source://opal//lib/opal/rewriters/logical_operator_assignment.rb#51
Opal::Rewriters::LogicalOperatorAssignment::GlobalVariableHandler = T.let(T.unsafe(nil), Proc)

# source://opal//lib/opal/rewriters/logical_operator_assignment.rb#118
Opal::Rewriters::LogicalOperatorAssignment::HANDLERS = T.let(T.unsafe(nil), Hash)

# Takes    `@lhs ||= rhs`
# Produces `@lhs = @lhs || rhs`
#
# source://opal//lib/opal/rewriters/logical_operator_assignment.rb#40
Opal::Rewriters::LogicalOperatorAssignment::InstanceVariableHandler = T.let(T.unsafe(nil), Proc)

# Takes    `lhs ||= rhs`
# Produces `lhs = lhs || rhs`
#
# source://opal//lib/opal/rewriters/logical_operator_assignment.rb#36
Opal::Rewriters::LogicalOperatorAssignment::LocalVariableHandler = T.let(T.unsafe(nil), Proc)

# Takes    `recvr.meth ||= rhs`
# Produces `recvr.meth || recvr.meth = rhs`
# (lhs is a recvr.meth)
#
# source://opal//lib/opal/rewriters/logical_operator_assignment.rb#63
class Opal::Rewriters::LogicalOperatorAssignment::SendHandler < ::Opal::Rewriters::LogicalOperatorAssignment
  class << self
    # source://opal//lib/opal/rewriters/logical_operator_assignment.rb#64
    def call(lhs, rhs, root_type); end
  end
end

# Rewrites
#
# def m( (a, b), (c, d) )
#   body
# end
#
# To
#
# def m($mlhs_tmp1, $mlhs_tmp2)
#   (a, b) = $mlhs_tmp1
#   (c, d) = $mlhs_tmp2
#   body
# end
#
# source://opal//lib/opal/rewriters/mlhs_args.rb#21
class Opal::Rewriters::MlhsArgs < ::Opal::Rewriters::Base
  # source://opal//lib/opal/rewriters/mlhs_args.rb#22
  def on_def(node); end

  # source://opal//lib/opal/rewriters/mlhs_args.rb#37
  def on_defs(node); end

  # source://opal//lib/opal/rewriters/mlhs_args.rb#52
  def on_iter(node); end
end

# source://opal//lib/opal/rewriters/mlhs_args.rb#67
class Opal::Rewriters::MlhsArgs::Arguments < ::Opal::Rewriters::Base
  # @return [Arguments] a new instance of Arguments
  #
  # source://opal//lib/opal/rewriters/mlhs_args.rb#70
  def initialize(args); end

  # Returns the value of attribute initialization.
  #
  # source://opal//lib/opal/rewriters/mlhs_args.rb#68
  def initialization; end

  # source://opal//lib/opal/rewriters/mlhs_args.rb#83
  def new_mlhs_tmp; end

  # source://opal//lib/opal/rewriters/mlhs_args.rb#79
  def reset_tmp_counter!; end

  # Returns the value of attribute rewritten.
  #
  # source://opal//lib/opal/rewriters/mlhs_args.rb#68
  def rewritten; end

  # source://opal//lib/opal/rewriters/mlhs_args.rb#89
  def split!; end
end

# source://opal//lib/opal/rewriters/mlhs_args.rb#112
class Opal::Rewriters::MlhsArgs::MlhsRewriter < ::Opal::Rewriters::Base
  # source://opal//lib/opal/rewriters/mlhs_args.rb#113
  def on_arg(node); end

  # source://opal//lib/opal/rewriters/mlhs_args.rb#117
  def on_restarg(node); end
end

# This rewriter transforms the Ruby 2.7 numblocks to regular blocks:
#
# proc { _1 }
#      v
# proc { |_1| _1 }
#
# source://opal//lib/opal/rewriters/numblocks.rb#12
class Opal::Rewriters::Numblocks < ::Opal::Rewriters::Base
  # source://opal//lib/opal/rewriters/numblocks.rb#24
  def gen_args(arg_count); end

  # source://opal//lib/opal/rewriters/numblocks.rb#13
  def on_numblock(node); end
end

# source://opal//lib/opal/rewriters/opal_engine_check.rb#7
class Opal::Rewriters::OpalEngineCheck < ::Opal::Rewriters::Base
  # source://opal//lib/opal/rewriters/opal_engine_check.rb#8
  def on_if(node); end

  # @return [Boolean]
  #
  # source://opal//lib/opal/rewriters/opal_engine_check.rb#20
  def skip_check_present?(test); end

  # @return [Boolean]
  #
  # source://opal//lib/opal/rewriters/opal_engine_check.rb#24
  def skip_check_present_not?(test); end
end

# source://opal//lib/opal/rewriters/opal_engine_check.rb#28
Opal::Rewriters::OpalEngineCheck::RUBY_ENGINE_CHECK = T.let(T.unsafe(nil), Opal::AST::Node)

# source://opal//lib/opal/rewriters/opal_engine_check.rb#32
Opal::Rewriters::OpalEngineCheck::RUBY_ENGINE_CHECK_NOT = T.let(T.unsafe(nil), Opal::AST::Node)

# source://opal//lib/opal/rewriters/opal_engine_check.rb#36
Opal::Rewriters::OpalEngineCheck::RUBY_PLATFORM_CHECK = T.let(T.unsafe(nil), Opal::AST::Node)

# source://opal//lib/opal/rewriters/opal_engine_check.rb#40
Opal::Rewriters::OpalEngineCheck::RUBY_PLATFORM_CHECK_NOT = T.let(T.unsafe(nil), Opal::AST::Node)

# source://opal//lib/opal/rewriters/pattern_matching.rb#7
class Opal::Rewriters::PatternMatching < ::Opal::Rewriters::Base
  # @return [PatternMatching] a new instance of PatternMatching
  #
  # source://opal//lib/opal/rewriters/pattern_matching.rb#8
  def initialize; end

  # case a; in b; end
  #
  # source://opal//lib/opal/rewriters/pattern_matching.rb#39
  def on_case_match(node); end

  # a => b
  #
  # source://opal//lib/opal/rewriters/pattern_matching.rb#14
  def on_match_pattern(node); end

  # a in b
  #
  # source://opal//lib/opal/rewriters/pattern_matching.rb#28
  def on_match_pattern_p(node); end

  private

  # source://opal//lib/opal/rewriters/pattern_matching.rb#95
  def convert_full_pattern(from, pat); end

  # raise NoMatchingPatternError, from
  #
  # source://opal//lib/opal/rewriters/pattern_matching.rb#61
  def raise_no_matching_pattern_error(from); end

  # in b
  #
  # source://opal//lib/opal/rewriters/pattern_matching.rb#69
  def single_case_match(from, *cases, els); end
end

# source://opal//lib/opal/rewriters/pattern_matching.rb#117
class Opal::Rewriters::PatternMatching::PatternConverter < ::Opal::Rewriters::Base
  # @return [PatternConverter] a new instance of PatternConverter
  #
  # source://opal//lib/opal/rewriters/pattern_matching.rb#118
  def initialize(pat); end

  # source://opal//lib/opal/rewriters/pattern_matching.rb#152
  def on_array(node); end

  # [0, 1, 2] or [*, 0, 1] or [0, 1, *]
  #
  # source://opal//lib/opal/rewriters/pattern_matching.rb#197
  def on_array_pattern(node, tail = T.unsafe(nil)); end

  # [0, 1, 2,]
  #
  # source://opal//lib/opal/rewriters/pattern_matching.rb#222
  def on_array_pattern_with_tail(node); end

  # source://opal//lib/opal/rewriters/pattern_matching.rb#152
  def on_begin(node); end

  # source://opal//lib/opal/rewriters/pattern_matching.rb#152
  def on_complex(node); end

  # source://opal//lib/opal/rewriters/pattern_matching.rb#152
  def on_const(node); end

  # MyStructName
  #
  # source://opal//lib/opal/rewriters/pattern_matching.rb#192
  def on_const_pattern(node); end

  # source://opal//lib/opal/rewriters/pattern_matching.rb#152
  def on_dstr(node); end

  # source://opal//lib/opal/rewriters/pattern_matching.rb#152
  def on_erange(node); end

  # [*, a, b, *]
  #
  # source://opal//lib/opal/rewriters/pattern_matching.rb#256
  def on_find_pattern(node); end

  # source://opal//lib/opal/rewriters/pattern_matching.rb#152
  def on_float(node); end

  # {a:, b:}
  #
  # source://opal//lib/opal/rewriters/pattern_matching.rb#227
  def on_hash_pattern(node); end

  # source://opal//lib/opal/rewriters/pattern_matching.rb#152
  def on_int(node); end

  # source://opal//lib/opal/rewriters/pattern_matching.rb#152
  def on_irange(node); end

  # source://opal//lib/opal/rewriters/pattern_matching.rb#152
  def on_lambda(node); end

  # source://opal//lib/opal/rewriters/pattern_matching.rb#152
  def on_literal(node); end

  # {} | []
  #
  # source://opal//lib/opal/rewriters/pattern_matching.rb#187
  def on_match_alt(node); end

  # [...] => a
  #
  # source://opal//lib/opal/rewriters/pattern_matching.rb#145
  def on_match_as(node); end

  # *
  #
  # source://opal//lib/opal/rewriters/pattern_matching.rb#178
  def on_match_rest(node); end

  # a
  #
  # source://opal//lib/opal/rewriters/pattern_matching.rb#136
  def on_match_var(node); end

  # ^a
  #
  # source://opal//lib/opal/rewriters/pattern_matching.rb#173
  def on_pin(node); end

  # source://opal//lib/opal/rewriters/pattern_matching.rb#152
  def on_rational(node); end

  # source://opal//lib/opal/rewriters/pattern_matching.rb#152
  def on_regexp(node); end

  # source://opal//lib/opal/rewriters/pattern_matching.rb#152
  def on_str(node); end

  # source://opal//lib/opal/rewriters/pattern_matching.rb#152
  def on_sym(node); end

  # source://opal//lib/opal/rewriters/pattern_matching.rb#152
  def on_xstr(node); end

  # source://opal//lib/opal/rewriters/pattern_matching.rb#127
  def pattern; end

  # source://opal//lib/opal/rewriters/pattern_matching.rb#123
  def run!; end

  # source://opal//lib/opal/rewriters/pattern_matching.rb#131
  def variables; end

  private

  # source://opal//lib/opal/rewriters/pattern_matching.rb#266
  def array(*args); end

  # source://opal//lib/opal/rewriters/pattern_matching.rb#270
  def to_ast(val); end
end

# source://opal//lib/opal/rewriters/returnable_logic.rb#7
class Opal::Rewriters::ReturnableLogic < ::Opal::Rewriters::Base
  # source://opal//lib/opal/rewriters/returnable_logic.rb#14
  def free_tmp; end

  # source://opal//lib/opal/rewriters/returnable_logic.rb#8
  def next_tmp; end

  # `a && b` / `a and b`
  #
  # source://opal//lib/opal/rewriters/returnable_logic.rb#63
  def on_and(node); end

  # Parser sometimes generates parentheses as a begin node. If it's a single node begin value, then
  # let's forward the if_test metadata.
  #
  # source://opal//lib/opal/rewriters/returnable_logic.rb#81
  def on_begin(node); end

  # source://opal//lib/opal/rewriters/returnable_logic.rb#33
  def on_case(node); end

  # source://opal//lib/opal/rewriters/returnable_logic.rb#22
  def on_if(node); end

  # `a || b` / `a or b`
  #
  # source://opal//lib/opal/rewriters/returnable_logic.rb#44
  def on_or(node); end

  # source://opal//lib/opal/rewriters/returnable_logic.rb#18
  def reset_tmp_counter!; end

  private

  # source://opal//lib/opal/rewriters/returnable_logic.rb#98
  def build_if_from_when(node, lhs, lhs_tmp, whens, els); end

  # source://opal//lib/opal/rewriters/returnable_logic.rb#108
  def build_rule_from_parts(node, lhs, lhs_tmp, parts); end

  # source://opal//lib/opal/rewriters/returnable_logic.rb#91
  def check_control_flow!(node); end
end

# This module attempts to run some optimizations or compatibility
# improvements against some libraries used with Opal.
#
# This should be a last resort and must not break functionality in
# existing applications.
#
# source://opal//lib/opal/rewriters/targeted_patches.rb#12
class Opal::Rewriters::TargetedPatches < ::Opal::Rewriters::Base
  # source://opal//lib/opal/rewriters/targeted_patches.rb#49
  def on_array(node); end

  # source://opal//lib/opal/rewriters/targeted_patches.rb#13
  def on_def(node); end
end

# ThrowerFinder attempts to track the presence of throwers, like
# break, redo, so we can make an informed guess in the early
# compilation phase before traversing other nodes whether we
# want to track a closure. Tracking a closure is often a deoptimizing
# step, so we want to get that knowledge earlier.
#
# source://opal//lib/opal/rewriters/thrower_finder.rb#11
class Opal::Rewriters::ThrowerFinder < ::Opal::Rewriters::Base
  # @return [ThrowerFinder] a new instance of ThrowerFinder
  #
  # source://opal//lib/opal/rewriters/thrower_finder.rb#12
  def initialize; end

  # source://opal//lib/opal/rewriters/thrower_finder.rb#19
  def on_break(node); end

  # ignore throwers inside defined
  #
  # source://opal//lib/opal/rewriters/thrower_finder.rb#49
  def on_defined(node); end

  # In Opal we handle rescue-else either in ensure or in
  # rescue. If ensure is present, we handle it in ensure.
  # Otherwise we handle it in rescue. ensure is always
  # above a rescue. This logic is about tracking if a given
  # ensure node should expect a rescue-else inside a
  # rescue node.
  #
  # source://opal//lib/opal/rewriters/thrower_finder.rb#63
  def on_ensure(node); end

  # source://opal//lib/opal/rewriters/thrower_finder.rb#42
  def on_for(node); end

  # source://opal//lib/opal/rewriters/thrower_finder.rb#34
  def on_iter(node); end

  # source://opal//lib/opal/rewriters/thrower_finder.rb#38
  def on_loop(node, &block); end

  # source://opal//lib/opal/rewriters/thrower_finder.rb#24
  def on_redo(node); end

  # source://opal//lib/opal/rewriters/thrower_finder.rb#67
  def on_rescue(node); end

  # source://opal//lib/opal/rewriters/thrower_finder.rb#29
  def on_retry(node); end

  # source://opal//lib/opal/rewriters/thrower_finder.rb#45
  def on_until(node); end

  # source://opal//lib/opal/rewriters/thrower_finder.rb#46
  def on_until_post(node); end

  # source://opal//lib/opal/rewriters/thrower_finder.rb#43
  def on_while(node); end

  # source://opal//lib/opal/rewriters/thrower_finder.rb#44
  def on_while_post(node); end

  private

  # source://opal//lib/opal/rewriters/thrower_finder.rb#77
  def pushing(*stacks); end

  # source://opal//lib/opal/rewriters/thrower_finder.rb#84
  def tracking(breaker, stack); end
end

# source://opal//lib/opal/errors.rb#27
class Opal::RewritingError < ::Opal::ParsingError; end

# Opal::SimpleServer is a very basic Rack server for Opal assets, it relies on
# Opal::Builder and Ruby corelib/stdlib. It's meant to be used just for local
# development.
#
# For a more complete implementation see opal-sprockets (Rubygems) or
# opal-webpack (NPM).
#
# @example (CLI)
#   rackup -ropal -ropal/simple_server -b 'Opal.append_path("app"); run Opal::SimpleServer.new'
#   ... or use the Server runner ...
#   opal -Rserver app.rb
#
# source://opal//lib/opal/simple_server.rb#16
class Opal::SimpleServer
  # @return [SimpleServer] a new instance of SimpleServer
  # @yield [_self]
  # @yieldparam _self [Opal::SimpleServer] the object that the method was called on
  #
  # source://opal//lib/opal/simple_server.rb#22
  def initialize(options = T.unsafe(nil)); end

  # It's here for compatibility with Opal::Sprockets::Server
  #
  # @deprecated
  #
  # source://opal//lib/opal/simple_server.rb#34
  def append_path(path); end

  # source://opal//lib/opal/simple_server.rb#59
  def builder(path); end

  # source://opal//lib/opal/simple_server.rb#81
  def cache_invalidator; end

  # source://opal//lib/opal/simple_server.rb#39
  def call(env); end

  # source://opal//lib/opal/simple_server.rb#85
  def call_index; end

  # source://opal//lib/opal/simple_server.rb#50
  def call_js(path); end

  # source://opal//lib/opal/simple_server.rb#64
  def fetch_asset(path); end

  # Returns the value of attribute index_path.
  #
  # source://opal//lib/opal/simple_server.rb#30
  def index_path; end

  # Sets the attribute index_path
  #
  # @param value the value to set the attribute index_path to.
  #
  # source://opal//lib/opal/simple_server.rb#30
  def index_path=(_arg0); end

  # source://opal//lib/opal/simple_server.rb#72
  def javascript_include_tag(path); end

  # Returns the value of attribute main.
  #
  # source://opal//lib/opal/simple_server.rb#30
  def main; end

  # Sets the attribute main
  #
  # @param value the value to set the attribute main to.
  #
  # source://opal//lib/opal/simple_server.rb#30
  def main=(_arg0); end
end

# source://opal//lib/opal/simple_server.rb#20
class Opal::SimpleServer::NotFound < ::StandardError; end

# To generate the source map for a single file use Opal::SourceMap::File.
# To combine multiple files the Opal::SourceMap::Index should be used.
#
# source://opal//lib/opal/source_map.rb#6
module Opal::SourceMap; end

# source://opal//lib/opal/source_map/file.rb#3
class Opal::SourceMap::File
  include ::Opal::SourceMap::Map

  # @return [File] a new instance of File
  #
  # source://opal//lib/opal/source_map/file.rb#10
  def initialize(fragments, file, source, generated_code = T.unsafe(nil)); end

  # The mappings data is broken down as follows:
  #
  # each group representing a line in the generated file is separated by a ;
  # each segment is separated by a ,
  # each segment is made up of 1,4 or 5 variable length fields.
  #
  # source://opal//lib/opal/source_map/file.rb#160
  def absolute_mappings; end

  # Returns the value of attribute file.
  #
  # source://opal//lib/opal/source_map/file.rb#7
  def file; end

  # Returns the value of attribute fragments.
  #
  # source://opal//lib/opal/source_map/file.rb#6
  def fragments; end

  # source://opal//lib/opal/source_map/file.rb#19
  def generated_code; end

  # Proposed Format
  # 1: {
  # 2: "version" : 3,
  # 3: "file": "out.js",
  # 4: "sourceRoot": "",
  # 5: "sources": ["foo.js", "bar.js"],
  # 6: "sourcesContent": [null, null],
  # 7: "names": ["src", "maps", "are", "fun"],
  # 8: "mappings": "A,AAAB;;ABCDE;"
  # 9: }
  #
  # Line 1: The entire file is a single JSON object
  # Line 2: File version (always the first entry in the object) and must be a
  #         positive integer.
  # Line 3: An optional name of the generated code that this source map is
  #         associated with.
  # Line 4: An optional source root, useful for relocating source files on a server
  #         or removing repeated values in the sources entry. This value is prepended to
  #         the individual entries in the source field.
  # Line 5: A list of original sources used by the mappings entry.
  # Line 6: An optional list of source content, useful when the source cant be
  #         hosted. The contents are listed in the same order as the sources in line 5.
  #         null may be used if some original sources should be retrieved by name.
  # Line 7: A list of symbol names used by the mappings entry.
  # Line 8: A string with the encoded mapping data.
  #
  # source://opal//lib/opal/source_map/file.rb#48
  def map(source_root: T.unsafe(nil)); end

  # source://opal//lib/opal/source_map/file.rb#62
  def names; end

  # source://opal//lib/opal/source_map/file.rb#126
  def relative_mappings; end

  # The fields in each segment are:
  #
  # 1. The zero-based starting column of the line in the generated code that
  #    the segment represents. If this is the first field of the first segment, or
  #    the first segment following a new generated line (;), then this field
  #    holds the whole base 64 VLQ. Otherwise, this field contains a base 64 VLQ
  #    that is relative to the previous occurrence of this field. Note that this
  #    is different than the fields below because the previous value is reset
  #    after every generated line.
  #
  # 2. If present, an zero-based index into the sources list. This field is
  #    a base 64 VLQ relative to the previous occurrence of this field, unless
  #    this is the first occurrence of this field, in which case the whole value
  #    is represented.
  #
  # 3. If present, the zero-based starting line in the original source
  #    represented. This field is a base 64 VLQ relative to the previous
  #    occurrence of this field, unless this is the first occurrence of this
  #    field, in which case the whole value is represented. Always present if
  #    there is a source field.
  #
  # 4. If present, the zero-based starting column of the line in the source
  #    represented. This field is a base 64 VLQ relative to the previous
  #    occurrence of this field, unless this is the first occurrence of this
  #    field, in which case the whole value is represented. Always present if
  #    there is a source field.
  #
  # 5. If present, the zero-based index into the names list associated with
  #    this segment. This field is a base 64 VLQ relative to the previous
  #    occurrence of this field, unless this is the first occurrence of this
  #    field, in which case the whole value is represented.
  #
  # source://opal//lib/opal/source_map/file.rb#100
  def segment_from_fragment(fragment, generated_column); end

  # Returns the value of attribute source.
  #
  # source://opal//lib/opal/source_map/file.rb#8
  def source; end

  private

  # source://opal//lib/opal/source_map/file.rb#182
  def fragments_by_line; end
end

# source://opal//lib/opal/source_map/index.rb#3
class Opal::SourceMap::Index
  include ::Opal::SourceMap::Map

  # @param source_maps [Opal::SourceMap::File]
  # @param join: the string used to join the sources, empty by default, Opal::Builder uses "\n"
  # @return [Index] a new instance of Index
  #
  # source://opal//lib/opal/source_map/index.rb#10
  def initialize(source_maps, join: T.unsafe(nil)); end

  # To support concatenating generated code and other common post processing, an
  # alternate representation of a map is supported:
  #
  #  1: {
  #  2: version : 3,
  #  3: file: app.js,
  #  4: sections: [
  #  5:  { offset: {line:0, column:0}, url: url_for_part1.map }
  #  6:  { offset: {line:100, column:10}, map:
  #  7:    {
  #  8:      version : 3,
  #  9:      file: section.js,
  # 10:      sources: ["foo.js", "bar.js"],
  # 11:      names: ["src", "maps", "are", "fun"],
  # 12:      mappings: "AAAA,E;;ABCDE;"
  # 13:    }
  # 14:  }
  # 15: ],
  # 16: }
  #
  # The index map follow the form of the standard map
  #
  # Line 1: The entire file is an JSON object.
  # Line 2: The version field. See the description of the standard map.
  # Line 3: The name field. See the description of the standard map.
  # Line 4: The sections field.
  #
  # The sections field is an array of JSON objects that itself has two fields
  # offset and a source map reference. offset is an object with two fields,
  # line and column, that represent the offset into generated code that the
  # referenced source map represents.
  #
  # The other field must be either url or map. A url entry must be a URL
  # where a source map can be found for this section and the url is resolved in the
  # same way as the sources fields in the standard map. A map entry must be an
  # embedded complete source map object. An embedded map does not inherit any
  # values from the containing index map.
  #
  # The sections must be sorted by starting position and the represented sections
  # may not overlap.
  #
  # source://opal//lib/opal/source_map/index.rb#56
  def map; end

  # Returns the value of attribute source_maps.
  #
  # source://opal//lib/opal/source_map/index.rb#6
  def source_maps; end
end

# source://opal//lib/opal/source_map/map.rb#6
module Opal::SourceMap::Map
  # source://opal//lib/opal/source_map/map.rb#23
  def as_json(*_arg0); end

  # Marshaling for cache shortpath
  #
  # source://opal//lib/opal/source_map/map.rb#36
  def cache; end

  # source://opal//lib/opal/source_map/map.rb#41
  def marshal_dump; end

  # source://opal//lib/opal/source_map/map.rb#45
  def marshal_load(value); end

  # source://opal//lib/opal/source_map/map.rb#31
  def to_data_uri_comment; end

  # source://opal//lib/opal/source_map/map.rb#7
  def to_h; end

  # source://opal//lib/opal/source_map/map.rb#11
  def to_json; end

  # source://opal//lib/opal/source_map/map.rb#27
  def to_s; end
end

# Ported from http://github.com/maccman/sourcemap
#
# Adopted from ConradIrwin/ruby-source_map
#   https://github.com/ConradIrwin/ruby-source_map/blob/master/lib/source_map/vlq.rb
#
# Resources
#
#   http://en.wikipedia.org/wiki/Variable-length_quantity
#   https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit
#   https://github.com/mozilla/source-map/blob/master/lib/source-map/base64-vlq.js
#
# source://opal//lib/opal/source_map/vlq.rb#12
module Opal::SourceMap::VLQ
  class << self
    # Public: Decode a VLQ string.
    #
    # str - VLQ encoded String
    #
    # Returns an Array of Integers.
    #
    # source://opal//lib/opal/source_map/vlq.rb#47
    def decode(str); end

    # Public: Decode a VLQ string into mapping numbers.
    #
    # str - VLQ encoded String
    #
    # Returns an two dimensional Array of Integers.
    #
    # source://opal//lib/opal/source_map/vlq.rb#86
    def decode_mappings(str); end

    # Public: Encode a list of numbers into a compact VLQ string.
    #
    # ary - An Array of Integers
    #
    # Returns a VLQ String.
    #
    # source://opal//lib/opal/source_map/vlq.rb#26
    def encode(ary); end

    # Public: Encode a mapping array into a compact VLQ string.
    #
    # ary - Two dimensional Array of Integers.
    #
    # Returns a VLQ encoded String seperated by , and ;.
    #
    # source://opal//lib/opal/source_map/vlq.rb#73
    def encode_mappings(ary); end
  end
end

# source://opal//lib/opal/source_map/vlq.rb#18
Opal::SourceMap::VLQ::BASE64_DIGITS = T.let(T.unsafe(nil), Array)

# source://opal//lib/opal/source_map/vlq.rb#19
Opal::SourceMap::VLQ::BASE64_VALUES = T.let(T.unsafe(nil), Hash)

# source://opal//lib/opal/source_map/vlq.rb#14
Opal::SourceMap::VLQ::VLQ_BASE = T.let(T.unsafe(nil), Integer)

# source://opal//lib/opal/source_map/vlq.rb#15
Opal::SourceMap::VLQ::VLQ_BASE_MASK = T.let(T.unsafe(nil), Integer)

# source://opal//lib/opal/source_map/vlq.rb#13
Opal::SourceMap::VLQ::VLQ_BASE_SHIFT = T.let(T.unsafe(nil), Integer)

# source://opal//lib/opal/source_map/vlq.rb#16
Opal::SourceMap::VLQ::VLQ_CONTINUATION_BIT = T.let(T.unsafe(nil), Integer)

# source://opal//lib/opal/errors.rb#30
class Opal::SyntaxError < ::SyntaxError
  # Returns the value of attribute location.
  #
  # source://opal//lib/opal/errors.rb#31
  def location; end

  # Sets the attribute location
  #
  # @param value the value to set the attribute location to.
  #
  # source://opal//lib/opal/errors.rb#31
  def location=(_arg0); end
end

# source://opal//lib/opal/paths.rb#47
module Opal::UseGem
  # Adds the "require_paths" (usually `lib/`) of gem with the given name to
  # Opal paths. By default will include the "require_paths" from all the
  # dependent gems.
  #
  # @param gem_name [String] the name of the gem
  # @param include_dependencies [Boolean] whether or not to add recursively
  #   the gem's dependencies
  # @raise [Opal::GemNotFound] if gem or any of its runtime dependencies not found
  #
  # source://opal//lib/opal/paths.rb#57
  def use_gem(gem_name, include_dependencies = T.unsafe(nil)); end

  private

  # @raise [GemNotFound]
  #
  # source://opal//lib/opal/paths.rb#63
  def require_paths_for_gem(gem_name, include_dependencies); end
end

# WHEN RELEASING:
# Remember to update RUBY_ENGINE_VERSION in opal/corelib/constants.rb too!
#
# source://opal//lib/opal/version.rb#6
Opal::VERSION = T.let(T.unsafe(nil), String)

module Parser; end
module Parser::Builders; end

# source://opal//lib/opal/parser/patch.rb#161
class Parser::Builders::Default
  # source://parser/3.3.4.0/lib/parser/builders/default.rb#243
  def initialize; end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#703
  def __ENCODING__(__ENCODING__t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#348
  def __FILE__(__FILE__t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#312
  def __LINE__(__LINE__t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#622
  def accessible(node); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#878
  def alias(alias_t, to, from); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#917
  def arg(name_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1007
  def arg_expr(expr); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#887
  def args(begin_t, args, end_t, check_args = T.unsafe(nil)); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#440
  def array(begin_t, elements, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1590
  def array_pattern(lbrack_t, elements, rbrack_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#767
  def assign(lhs, eql_t, rhs); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#712
  def assignable(node); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#540
  def associate(begin_t, pairs, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1171
  def attr_asgn(receiver, dot_t, selector_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#612
  def back_ref(token); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1435
  def begin(begin_t, body, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1377
  def begin_body(compound_stmt, rescue_bodies = T.unsafe(nil), else_t = T.unsafe(nil), else_ = T.unsafe(nil), ensure_t = T.unsafe(nil), ensure_ = T.unsafe(nil)); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1453
  def begin_keyword(begin_t, body, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1205
  def binary_op(receiver, operator_t, arg); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1122
  def block(method_call, begin_t, args, body, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1157
  def block_pass(amper_t, arg); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#982
  def blockarg(amper_t, name_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1027
  def blockarg_expr(amper_t, expr); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1113
  def call_lambda(lambda_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1096
  def call_method(receiver, dot_t, selector_t, lparen_t = T.unsafe(nil), args = T.unsafe(nil), rparen_t = T.unsafe(nil)); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1068
  def call_type_for_dot(dot_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1310
  def case(case_t, expr, when_bodies, else_t, else_body, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1473
  def case_match(case_t, expr, in_bodies, else_t, else_body, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#343
  def character(char_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#284
  def complex(complex_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1423
  def compstmt(statements); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1286
  def condition(cond_t, cond, then_t, if_true, else_t, if_false, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1292
  def condition_mod(if_true, if_false, cond_t, cond); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#686
  def const(name_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#698
  def const_fetch(scope, t_colon2, name_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#691
  def const_global(t_colon3, name_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#763
  def const_op_assignable(node); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1620
  def const_pattern(const, ldelim_t, pattern, rdelim_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#607
  def cvar(token); end

  # Taken From:
  # https://github.com/whitequark/parser/blob/a7c638b7b205db9213a56897b41a8e5620df766e/lib/parser/builders/default.rb#L388
  #
  # source://parser/3.3.4.0/lib/parser/builders/default.rb#388
  def dedent_string(node, dedent_level); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#814
  def def_class(class_t, name, lt_t, superclass, body, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#845
  def def_endless_method(def_t, name_t, args, assignment_t, body); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#863
  def def_endless_singleton(def_t, definee, dot_t, name_t, args, assignment_t, body); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#837
  def def_method(def_t, name_t, args, body, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#827
  def def_module(module_t, name, body, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#821
  def def_sclass(class_t, lshft_t, expr, body, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#853
  def def_singleton(def_t, definee, dot_t, name_t, args, body, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#237
  def emit_file_line_as_literals; end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#237
  def emit_file_line_as_literals=(_arg0); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#265
  def false(false_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1611
  def find_pattern(lbrack_t, elements, rbrack_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#276
  def float(float_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1331
  def for(for_t, iterator, in_t, iteratee, do_t, body, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#913
  def forward_arg(dots_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#903
  def forward_only_args(begin_t, dots_t, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1084
  def forwarded_args(dots_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1092
  def forwarded_kwrestarg(dstar_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1088
  def forwarded_restarg(star_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#596
  def gvar(token); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1584
  def hash_pattern(lbrace_t, kwargs, rbrace_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#586
  def ident(token); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1500
  def if_guard(if_t, if_body); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1479
  def in_match(lhs, in_t, rhs); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1494
  def in_pattern(in_t, pattern, guard, then_t, body); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1180
  def index(receiver, lbrack_t, indexes, rbrack_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1194
  def index_asgn(receiver, lbrack_t, indexes, rbrack_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#272
  def integer(integer_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#591
  def ivar(token); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1339
  def keyword_cmd(type, keyword_t, lparen_t = T.unsafe(nil), args = T.unsafe(nil), rparen_t = T.unsafe(nil)); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#944
  def kwarg(name_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#970
  def kwnilarg(dstar_t, nil_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#951
  def kwoptarg(name_t, value); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#958
  def kwrestarg(dstar_t, name_t = T.unsafe(nil)); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#535
  def kwsplat(dstar_t, arg); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1279
  def logical_op(type, lhs, op_t, rhs); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1317
  def loop(type, keyword_t, cond, do_t, body, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1322
  def loop_mod(type, body, keyword_t, cond); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1634
  def match_alt(left, pipe_t, right); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1641
  def match_as(value, assoc_t, as); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1520
  def match_hash_var(name_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1534
  def match_hash_var_from_str(begin_t, strings, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1672
  def match_label(label_type, label); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1648
  def match_nil_pattern(dstar_t, nil_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1227
  def match_op(receiver, match_t, arg); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1653
  def match_pair(label_type, label, value); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1484
  def match_pattern(lhs, match_t, rhs); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1489
  def match_pattern_p(lhs, match_t, rhs); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1573
  def match_rest(star_t, name_t = T.unsafe(nil)); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1508
  def match_var(name_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1616
  def match_with_trailing_comma(match, comma_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#805
  def multi_assign(lhs, eql_t, rhs); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#800
  def multi_lhs(begin_t, items, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#255
  def nil(nil_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1255
  def not_op(not_t, begin_t = T.unsafe(nil), receiver = T.unsafe(nil), end_t = T.unsafe(nil)); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#617
  def nth_ref(token); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#899
  def numargs(max_numparam); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1038
  def objc_kwarg(kwname_t, assoc_t, name_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1052
  def objc_restarg(star_t, name = T.unsafe(nil)); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1162
  def objc_varargs(pair, rest_of_varargs); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#774
  def op_assign(lhs, op_t, rhs); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#924
  def optarg(name_t, eql_t, value); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#488
  def pair(key, assoc_t, value); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#505
  def pair_keyword(key_t, value); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#521
  def pair_label(key_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#493
  def pair_list_18(list); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#513
  def pair_quoted(begin_t, parts, end_t, value); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#225
  def parser; end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#225
  def parser=(_arg0); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1629
  def pin(pin_t, var); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1362
  def postexe(postexe_t, lbrace_t, compstmt, rbrace_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1357
  def preexe(preexe_t, lbrace_t, compstmt, rbrace_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#992
  def procarg0(arg); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#572
  def range_exclusive(lhs, dot3_t, rhs); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#567
  def range_inclusive(lhs, dot2_t, rhs); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#280
  def rational(rational_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#426
  def regexp_compose(begin_t, parts, end_t, options); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#417
  def regexp_options(regopt_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1369
  def rescue_body(rescue_t, exc_list, assoc_t, exc_var, then_t, compound_stmt); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#933
  def restarg(star_t, name_t = T.unsafe(nil)); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1016
  def restarg_expr(star_t, expr = T.unsafe(nil)); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#581
  def self(token); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#975
  def shadowarg(name_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#445
  def splat(star_t, arg = T.unsafe(nil)); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#319
  def string(string_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#329
  def string_compose(begin_t, parts, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#324
  def string_internal(string_t); end

  # source://opal//lib/opal/parser/patch.rb#165
  def string_value(token); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#355
  def symbol(symbol_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#365
  def symbol_compose(begin_t, parts, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#360
  def symbol_internal(symbol_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#469
  def symbols_compose(begin_t, parts, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1297
  def ternary(cond, question_t, if_true, colon_t, if_false); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#260
  def true(true_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#294
  def unary_num(unary_t, numeric); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1243
  def unary_op(op_t, receiver); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#873
  def undef_method(undef_t, names); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1504
  def unless_guard(unless_t, unless_body); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1304
  def when(when_t, patterns, then_t, body); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#455
  def word(parts); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#464
  def words_compose(begin_t, parts, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#381
  def xstring_compose(begin_t, parts, end_t); end

  private

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1821
  def arg_name_collides?(this_name, that_name); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2017
  def arg_prefix_map(op_t, name_t = T.unsafe(nil)); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1991
  def binary_op_map(left_e, op_t, right_e); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2119
  def block_map(receiver_l, begin_t, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1796
  def check_assignment_to_numparam(name, loc); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1688
  def check_condition(cond); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1767
  def check_duplicate_arg(this_arg, map = T.unsafe(nil)); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1742
  def check_duplicate_args(args, map = T.unsafe(nil)); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1854
  def check_duplicate_pattern_key(name, loc); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1844
  def check_duplicate_pattern_variable(name, loc); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1836
  def check_lvar_name(name, loc); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1811
  def check_reserved_for_numparam(name, loc); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2280
  def collapse_string_parts?(parts); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1942
  def collection_map(begin_t, parts, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2146
  def condition_map(keyword_t, cond_e, begin_t, body_e, else_t, else_e, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1977
  def constant_map(scope, colon2_t, name_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2050
  def definition_map(keyword_t, operator_t, name_t, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1883
  def delimited_string_map(string_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2302
  def diagnostic(type, reason, arguments, location, highlights = T.unsafe(nil)); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2190
  def eh_keyword_map(compstmt_e, keyword_t, body_es, else_t, else_e); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2056
  def endless_definition_map(keyword_t, operator_t, name_t, assignment_t, body_e); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1938
  def expr_map(loc); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2171
  def for_map(keyword_t, in_t, begin_t, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2218
  def guard_map(keyword_t, guard_body_e); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2108
  def index_map(receiver_e, lbrack_t, rbrack_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1874
  def join_exprs(left_expr, right_expr); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2124
  def keyword_map(keyword_t, begin_t, args, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2141
  def keyword_mod_map(pre_e, keyword_t, post_e); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2027
  def kwarg_map(name_t, value_e = T.unsafe(nil)); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2333
  def kwargs?(node); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2297
  def loc(token); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2040
  def module_definition_map(keyword_t, name_e, operator_t, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1866
  def n(type, children, source_map); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1870
  def n0(type, source_map); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#288
  def numeric(kind, token); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1908
  def pair_keyword_map(key_t, value_e); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1923
  def pair_quoted_map(begin_t, end_t, value_e); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1894
  def prefix_string_map(symbol); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2005
  def range_map(start_e, op_t, end_e); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1972
  def regexp_map(begin_t, end_t, options_e); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2177
  def rescue_body_map(keyword_t, exc_list_e, assoc_t, exc_var_e, then_t, compstmt_e); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2323
  def rewrite_hash_args_to_kwargs(args); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2090
  def send_binary_op_map(lhs_e, selector_t, rhs_e); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2113
  def send_index_map(receiver_e, lbrack_t, rbrack_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2064
  def send_map(receiver_e, dot_t, selector_t, begin_t = T.unsafe(nil), args = T.unsafe(nil), end_t = T.unsafe(nil)); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2096
  def send_unary_op_map(selector_t, arg_e); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2249
  def static_regexp(parts, options); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2269
  def static_regexp_node(node); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2232
  def static_string(nodes); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1958
  def string_map(begin_t, parts, end_t); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2166
  def ternary_map(begin_e, question_t, mid_e, colon_t, end_e); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1879
  def token_map(token); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1995
  def unary_op_map(op_t, arg_e = T.unsafe(nil)); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1903
  def unquoted_map(token); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2311
  def validate_definee(definee); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1781
  def validate_no_forward_arg_after_restarg(args); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2285
  def value(token); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#2084
  def var_send_map(variable_e); end

  # source://parser/3.3.4.0/lib/parser/builders/default.rb#1987
  def variable_map(name_t); end

  class << self
    # source://parser/3.3.4.0/lib/parser/builders/default.rb#97
    def emit_arg_inside_procarg0; end

    # source://parser/3.3.4.0/lib/parser/builders/default.rb#97
    def emit_arg_inside_procarg0=(_arg0); end

    # source://parser/3.3.4.0/lib/parser/builders/default.rb#58
    def emit_encoding; end

    # source://parser/3.3.4.0/lib/parser/builders/default.rb#58
    def emit_encoding=(_arg0); end

    # source://parser/3.3.4.0/lib/parser/builders/default.rb#126
    def emit_forward_arg; end

    # source://parser/3.3.4.0/lib/parser/builders/default.rb#126
    def emit_forward_arg=(_arg0); end

    # source://parser/3.3.4.0/lib/parser/builders/default.rb#80
    def emit_index; end

    # source://parser/3.3.4.0/lib/parser/builders/default.rb#80
    def emit_index=(_arg0); end

    # source://parser/3.3.4.0/lib/parser/builders/default.rb#174
    def emit_kwargs; end

    # source://parser/3.3.4.0/lib/parser/builders/default.rb#174
    def emit_kwargs=(_arg0); end

    # source://parser/3.3.4.0/lib/parser/builders/default.rb#22
    def emit_lambda; end

    # source://parser/3.3.4.0/lib/parser/builders/default.rb#22
    def emit_lambda=(_arg0); end

    # source://parser/3.3.4.0/lib/parser/builders/default.rb#203
    def emit_match_pattern; end

    # source://parser/3.3.4.0/lib/parser/builders/default.rb#203
    def emit_match_pattern=(_arg0); end

    # source://parser/3.3.4.0/lib/parser/builders/default.rb#40
    def emit_procarg0; end

    # source://parser/3.3.4.0/lib/parser/builders/default.rb#40
    def emit_procarg0=(_arg0); end

    # source://parser/3.3.4.0/lib/parser/builders/default.rb#211
    def modernize; end
  end
end
