# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/opal/all/opal.rbi
#
# opal-1.8.2

module Opal
  def self.add_opal_location_to_error(opal_location, error); end
  def self.append_path(path); end
  def self.append_paths(*paths); end
  def self.builder_scheduler; end
  def self.builder_scheduler=(arg0); end
  def self.cache; end
  def self.cache=(arg0); end
  def self.compile(source, options = nil); end
  def self.core_dir; end
  def self.dependent_files; end
  def self.gem_dir; end
  def self.opal_location_from_error(error); end
  def self.paths; end
  def self.reset_paths!; end
  def self.std_dir; end
  extend Opal::Deprecations
  extend Opal::UseGem
end
module Opal::Config
  def compiler_options; end
  def config; end
  def config_option(name, default_value, options = nil); end
  def config_options; end
  def default_config; end
  def reset!; end
  def self.arity_check_enabled; end
  def self.arity_check_enabled=(value); end
  def self.const_missing_enabled; end
  def self.const_missing_enabled=(value); end
  def self.dynamic_require_severity; end
  def self.dynamic_require_severity=(value); end
  def self.enable_file_source_embed; end
  def self.enable_file_source_embed=(value); end
  def self.enable_source_location; end
  def self.enable_source_location=(value); end
  def self.esm; end
  def self.esm=(value); end
  def self.freezing_stubs_enabled; end
  def self.freezing_stubs_enabled=(value); end
  def self.inline_operators_enabled; end
  def self.inline_operators_enabled=(value); end
  def self.irb_enabled; end
  def self.irb_enabled=(value); end
  def self.method_missing_enabled; end
  def self.method_missing_enabled=(value); end
  def self.missing_require_severity; end
  def self.missing_require_severity=(value); end
  def self.source_map_enabled; end
  def self.source_map_enabled=(value); end
  def self.stubbed_files; end
  def self.stubbed_files=(value); end
  extend Opal::Config
end
module Opal::AST
end
class Opal::AST::Node < Parser::AST::Node
  def assign_properties(properties); end
  def column; end
  def line; end
  def meta; end
end
class Opal::AST::Builder < Parser::Builders::Default
  def n(type, children, location); end
end
module Opal::Rewriters
end
class Opal::Rewriters::Base < Parser::AST::Processor
  def append_to_body(body, node); end
  def begin_with_stmts(stmts); end
  def current_node; end
  def current_node=(arg0); end
  def dynamic!; end
  def error(msg); end
  def on_iter(node); end
  def on_jsattr(node); end
  def on_jsattrasgn(node); end
  def on_jscall(node); end
  def on_kwsplat(node); end
  def on_top(node); end
  def on_zsuper(node); end
  def prepend_to_body(body, node); end
  def process(node); end
  def s(type, *children); end
  def self.s(type, *children); end
  def stmts_of(node); end
end
class Opal::Rewriters::Base::DummyLocation
  def begin_pos; end
  def column; end
  def end_pos; end
  def expression; end
  def last_line; end
  def line; end
  def node=(*); end
  def source; end
end
class Opal::Rewriters::OpalEngineCheck < Opal::Rewriters::Base
  def on_if(node); end
  def skip_check_present?(test); end
  def skip_check_present_not?(test); end
end
class Opal::Rewriters::TargetedPatches < Opal::Rewriters::Base
  def on_array(node); end
  def on_def(node); end
end
class Opal::Rewriters::ForRewriter < Opal::Rewriters::Base
  def assign_loop_variable(loop_variable, tmp_loop_variable); end
  def generate_outer_assignments(loop_variable, loop_body); end
  def on_for(node); end
  def self.next_tmp; end
  def self.reset_tmp_counter!; end
  def transform_for_to_each_loop(node, loop_range, tmp_loop_variable, loop_body); end
end
class Opal::Rewriters::ForRewriter::LocalVariableAssigns < Opal::Rewriters::Base
  def initialize; end
  def on_lvasgn(node); end
  def result; end
  def self.find(node); end
end
class Opal::Rewriters::JsReservedWords < Opal::Rewriters::Base
  def fix_ivar_name(name); end
  def fix_var_name(name); end
  def on_argument(node); end
  def on_ivar(node); end
  def on_ivasgn(node); end
  def on_kwrestarg(node); end
  def on_lvar(node); end
  def on_lvasgn(node); end
  def on_restarg(node); end
  def self.valid_ivar_name?(name); end
  def self.valid_name?(name); end
end
class Opal::Rewriters::BlockToIter < Opal::Rewriters::Base
  def on_block(node); end
end
class Opal::Rewriters::DotJsSyntax < Opal::Rewriters::Base
  def on_send(node); end
  def to_js_attr_assign_call(recv, property, value); end
  def to_js_attr_call(recv, property); end
  def to_native_js_call(recv, meth, args); end
end
class Opal::Rewriters::PatternMatching < Opal::Rewriters::Base
  def convert_full_pattern(from, pat); end
  def initialize; end
  def on_case_match(node); end
  def on_match_pattern(node); end
  def on_match_pattern_p(node); end
  def raise_no_matching_pattern_error(from); end
  def single_case_match(from, *cases, els); end
end
class Opal::Rewriters::PatternMatching::PatternConverter < Opal::Rewriters::Base
  def array(*args); end
  def initialize(pat); end
  def on_array(node); end
  def on_array_pattern(node, tail = nil); end
  def on_array_pattern_with_tail(node); end
  def on_begin(node); end
  def on_complex(node); end
  def on_const(node); end
  def on_const_pattern(node); end
  def on_dstr(node); end
  def on_erange(node); end
  def on_find_pattern(node); end
  def on_float(node); end
  def on_hash_pattern(node); end
  def on_int(node); end
  def on_irange(node); end
  def on_lambda(node); end
  def on_literal(node); end
  def on_match_alt(node); end
  def on_match_as(node); end
  def on_match_rest(node); end
  def on_match_var(node); end
  def on_pin(node); end
  def on_rational(node); end
  def on_regexp(node); end
  def on_str(node); end
  def on_sym(node); end
  def on_xstr(node); end
  def pattern; end
  def run!; end
  def to_ast(val); end
  def variables; end
end
class Opal::Rewriters::LogicalOperatorAssignment < Opal::Rewriters::Base
  def on_and_asgn(node); end
  def on_defined?(node); end
  def on_or_asgn(node); end
  def self.new_temp; end
  def self.reset_tmp_counter!; end
end
class Opal::Rewriters::LogicalOperatorAssignment::SendHandler < Opal::Rewriters::LogicalOperatorAssignment
  def self.call(lhs, rhs, root_type); end
end
class Opal::Rewriters::LogicalOperatorAssignment::ConditionalSendHandler < Opal::Rewriters::LogicalOperatorAssignment
  def self.call(lhs, rhs, root_type); end
end
class Opal::Rewriters::BinaryOperatorAssignment < Opal::Rewriters::Base
  def on_defined?(node); end
  def on_op_asgn(node); end
  def self.new_temp; end
  def self.reset_tmp_counter!; end
end
class Opal::Rewriters::BinaryOperatorAssignment::SendHandler < Opal::Rewriters::BinaryOperatorAssignment
  def self.call(node, lhs, operation, rhs); end
end
class Opal::Rewriters::BinaryOperatorAssignment::ConditionalSendHandler < Opal::Rewriters::BinaryOperatorAssignment
  def self.call(node, lhs, operation, rhs); end
end
module Opal::Rewriters::Hashes
end
class Opal::Rewriters::Hashes::KeyDuplicatesRewriter < Opal::Rewriters::Base
  def initialize; end
  def on_hash(node); end
  def on_kwsplat(node); end
  def on_pair(node); end
end
class Opal::Rewriters::Hashes::KeyDuplicatesRewriter::UniqKeysSet
  def <<(element); end
  def initialize; end
end
class Opal::Rewriters::DumpArgs < Opal::Rewriters::Base
  def on_def(node); end
  def on_defs(node); end
  def on_iter(node); end
end
class Opal::Rewriters::DeduplicateArgName < Opal::Rewriters::Base
  def on_args(node); end
  def rename_arg(arg); end
  def unique_name(name); end
end
class Opal::Rewriters::MlhsArgs < Opal::Rewriters::Base
  def on_def(node); end
  def on_defs(node); end
  def on_iter(node); end
end
class Opal::Rewriters::MlhsArgs::Arguments < Opal::Rewriters::Base
  def initialization; end
  def initialize(args); end
  def new_mlhs_tmp; end
  def reset_tmp_counter!; end
  def rewritten; end
  def split!; end
end
class Opal::Rewriters::MlhsArgs::MlhsRewriter < Opal::Rewriters::Base
  def on_arg(node); end
  def on_restarg(node); end
end
class Opal::Rewriters::Arguments
  def args; end
  def blockarg; end
  def can_inline_kwargs?; end
  def has_any_kwargs?; end
  def has_post_args?; end
  def initialize(args); end
  def kwargs; end
  def kwnilarg; end
  def kwoptargs; end
  def kwrestarg; end
  def optargs; end
  def postargs; end
  def restarg; end
  def shadowargs; end
end
class Opal::Rewriters::InlineArgs < Opal::Rewriters::Base
  def on_def(node); end
  def on_defs(node); end
  def on_iter(node); end
end
class Opal::Rewriters::InlineArgs::Initializer < Opal::Rewriters::Base
  def args_to_keep; end
  def extract_args; end
  def extract_blockarg; end
  def extract_kwargs; end
  def extract_kwoptargs; end
  def extract_kwrestarg; end
  def extract_optargs; end
  def extract_post_args; end
  def extract_restarg; end
  def initialization; end
  def initialize(args, type:); end
  def initialize_shadowargs; end
  def inline; end
  def prepare_kwargs; end
  def prepare_post_args; end
end
class Opal::Rewriters::Numblocks < Opal::Rewriters::Base
  def gen_args(arg_count); end
  def on_numblock(node); end
end
class Opal::Rewriters::ReturnableLogic < Opal::Rewriters::Base
  def build_if_from_when(node, lhs, lhs_tmp, whens, els); end
  def build_rule_from_parts(node, lhs, lhs_tmp, parts); end
  def check_control_flow!(node); end
  def free_tmp; end
  def next_tmp; end
  def on_and(node); end
  def on_begin(node); end
  def on_case(node); end
  def on_if(node); end
  def on_or(node); end
  def reset_tmp_counter!; end
end
class Opal::Rewriters::ForwardArgs < Opal::Rewriters::Base
  def on_args(node); end
  def on_block_pass(node); end
  def on_blockarg(node); end
  def on_forward_args(_node); end
  def on_forwarded_kwrestarg(_node); end
  def on_forwarded_restarg(_node); end
  def on_kwrestarg(node); end
  def on_restarg(node); end
  def on_send(node); end
end
class Opal::Rewriters::ThrowerFinder < Opal::Rewriters::Base
  def initialize; end
  def on_break(node); end
  def on_defined(node); end
  def on_ensure(node); end
  def on_for(node); end
  def on_iter(node); end
  def on_loop(node, &block); end
  def on_redo(node); end
  def on_rescue(node); end
  def on_retry(node); end
  def on_until(node); end
  def on_until_post(node); end
  def on_while(node); end
  def on_while_post(node); end
  def pushing(*stacks); end
  def tracking(breaker, stack); end
end
class Opal::Rewriter
  def initialize(sexp); end
  def process; end
  def self.delete(rewriter); end
  def self.disable(except: nil); end
  def self.disabled?; end
  def self.list; end
  def self.rewritter_disabled?(rewriter); end
  def self.use(rewriter); end
end
module Opal::Parser
  def self.default_parser; end
  def self.default_parser_class; end
  def self.default_parser_class=(arg0); end
end
class Opal::Parser::SourceBuffer < Parser::Source::Buffer
  def self.recognize_encoding(string); end
end
module Opal::Parser::DefaultConfig
  def initialize(*); end
  def parse(source_buffer); end
  def rewrite(node); end
  def self.included(klass); end
end
module Opal::Parser::DefaultConfig::ClassMethods
  def default_parser; end
  def diagnostics_consumer; end
  def diagnostics_consumer=(arg0); end
end
class Opal::Parser::WithRubyLexer < Parser::Ruby32
  extend Opal::Parser::DefaultConfig::ClassMethods
  include Opal::Parser::DefaultConfig
end
module AST::Processor::Mixin
end
class Parser::Builders::Default
end
class Opal::Fragment
  def code; end
  def column; end
  def initialize(code, scope, sexp = nil); end
  def inspect; end
  def line; end
  def location; end
  def skip_source_map?; end
  def source_map_name; end
  def source_map_name_for(sexp); end
end
module Opal::Nodes
end
class Opal::Nodes::Closure
  def catchers; end
  def catchers=(arg0); end
  def initialize(node, type, parent); end
  def inspect; end
  def is?(type); end
  def node; end
  def node=(arg0); end
  def parent; end
  def parent=(arg0); end
  def register_catcher(type = nil); end
  def register_thrower(type, id); end
  def self.add_type(name, value); end
  def self.type_inspect(type); end
  def throwers; end
  def throwers=(arg0); end
  def type; end
  def type=(arg0); end
end
module Opal::Nodes::Closure::NodeSupport
  def closure; end
  def closure=(arg0); end
  def closure_is?(type); end
  def compile_catcher; end
  def generate_thrower(type, closure, value); end
  def generate_thrower_without_catcher(type, closure, value); end
  def in_closure(type = nil); end
  def pop_closure; end
  def push_closure(type = nil); end
  def select_closure(type = nil, break_after: nil); end
  def thrower(type, value = nil); end
end
module Opal::Nodes::Closure::CompilerSupport
  def closure_stack; end
end
module Opal::Nodes::Helpers
  def current_indent; end
  def empty_line; end
  def indent(&block); end
  def js_truthy(sexp); end
  def js_truthy_optimize(sexp); end
  def line(*strs); end
  def mid_to_jsid(mid); end
  def property(name); end
  def valid_name?(name); end
end
class Opal::Nodes::Base
  def add_gvar(name); end
  def add_ivar(name); end
  def add_local(name); end
  def add_temp(temp); end
  def children; end
  def class_variable_owner; end
  def class_variable_owner_nesting_level; end
  def comments; end
  def compile; end
  def compile_to_fragments; end
  def compiler; end
  def error(msg); end
  def expr(sexp); end
  def expr?; end
  def expr_or_empty(sexp); end
  def expr_or_nil(sexp); end
  def fragment(str, loc: nil); end
  def has_rescue_else?; end
  def helper(name); end
  def in_ensure(&block); end
  def in_ensure?; end
  def in_resbody(&block); end
  def in_resbody?; end
  def in_rescue(node, &block); end
  def in_while?; end
  def initialize(sexp, level, compiler); end
  def process(sexp, level = nil); end
  def push(*strs); end
  def recv(sexp); end
  def recv?; end
  def s(type, *children); end
  def scope; end
  def self.children(*names); end
  def self.handle(*types); end
  def self.handlers; end
  def self.truthy_optimize?; end
  def sexp; end
  def source_location; end
  def stmt(sexp); end
  def stmt?; end
  def top_scope; end
  def type; end
  def unshift(*strs); end
  def while_loop; end
  def with_temp(&block); end
  def wrap(pre, post); end
  include Opal::Nodes::Closure::NodeSupport
  include Opal::Nodes::Helpers
end
class Opal::Nodes::ValueNode < Opal::Nodes::Base
  def compile; end
  def self.truthy_optimize?; end
end
class Opal::Nodes::SelfNode < Opal::Nodes::Base
  def compile; end
end
class Opal::Nodes::NumericNode < Opal::Nodes::Base
  def compile; end
  def self.truthy_optimize?; end
  def value; end
end
class Opal::Nodes::StringNode < Opal::Nodes::Base
  def compile; end
  def to_utf16(code_point); end
  def translate_escape_chars(inspect_string); end
  def value; end
end
class Opal::Nodes::SymbolNode < Opal::Nodes::Base
  def compile; end
  def value; end
end
class Opal::Nodes::RegexpNode < Opal::Nodes::Base
  def compile; end
  def compile_dynamic_regexp; end
  def compile_static_regexp; end
  def extract_flags_and_value; end
  def flags; end
  def flags=(arg0); end
  def initialize(*); end
  def raw_value; end
  def single_line?(values); end
  def static_as_dynamic(value); end
  def value; end
  def value=(arg0); end
end
class Opal::Nodes::MatchCurrentLineNode < Opal::Nodes::Base
  def compile; end
  def regexp; end
end
class Opal::Nodes::DynamicStringNode < Opal::Nodes::Base
  def compile; end
end
class Opal::Nodes::DynamicSymbolNode < Opal::Nodes::DynamicStringNode
end
class Opal::Nodes::RangeNode < Opal::Nodes::Base
  def compile; end
  def compile_inline; end
  def compile_inline?; end
  def compile_range_initialize; end
  def finish; end
  def start; end
end
class Opal::Nodes::InclusiveRangeNode < Opal::Nodes::RangeNode
  def compile_inline; end
  def compile_range_initialize; end
end
class Opal::Nodes::ExclusiveRangeNode < Opal::Nodes::RangeNode
  def compile_inline; end
  def compile_range_initialize; end
end
class Opal::Nodes::RationalNode < Opal::Nodes::Base
  def compile; end
  def value; end
end
class Opal::Nodes::ComplexNode < Opal::Nodes::Base
  def compile; end
  def value; end
end
class Opal::Nodes::LocalVariableNode < Opal::Nodes::Base
  def compile; end
  def using_irb?; end
  def var_name; end
end
class Opal::Nodes::LocalAssignNode < Opal::Nodes::Base
  def compile; end
  def using_irb?; end
  def value; end
  def var_name; end
end
class Opal::Nodes::LocalDeclareNode < Opal::Nodes::Base
  def compile; end
  def var_name; end
end
class Opal::Nodes::InstanceVariableNode < Opal::Nodes::Base
  def compile; end
  def name; end
  def var_name; end
end
class Opal::Nodes::InstanceAssignNode < Opal::Nodes::Base
  def compile; end
  def name; end
  def value; end
  def var_name; end
end
class Opal::Nodes::GlobalVariableNode < Opal::Nodes::Base
  def compile; end
  def name; end
  def var_name; end
end
class Opal::Nodes::BackRefNode < Opal::Nodes::GlobalVariableNode
  def compile; end
  def handle_global_match; end
  def handle_post_match; end
  def handle_pre_match; end
end
class Opal::Nodes::GlobalAssignNode < Opal::Nodes::Base
  def compile; end
  def name; end
  def value; end
  def var_name; end
end
class Opal::Nodes::NthrefNode < Opal::Nodes::Base
  def compile; end
  def index; end
end
class Opal::Nodes::ClassVariableNode < Opal::Nodes::Base
  def compile; end
  def name; end
end
class Opal::Nodes::ClassVarAssignNode < Opal::Nodes::Base
  def compile; end
  def name; end
  def value; end
end
class Opal::Nodes::ConstNode < Opal::Nodes::Base
  def compile; end
  def const_scope; end
  def magical_data_const?; end
  def name; end
  def optimized_access?; end
end
class Opal::Nodes::CbaseNode < Opal::Nodes::Base
  def compile; end
end
class Opal::Nodes::ConstAssignNode < Opal::Nodes::Base
  def base; end
  def compile; end
  def name; end
  def value; end
end
class Opal::Nodes::CallNode < Opal::Nodes::Base
  def arglist; end
  def auto_await?; end
  def call_is_writer_that_needs_handling?; end
  def compile; end
  def compile_arguments(skip_comma = nil); end
  def compile_block_pass; end
  def compile_eval_var; end
  def compile_irb_var; end
  def compile_method_name; end
  def compile_receiver; end
  def compile_refinements; end
  def compile_simple_call_chain; end
  def compile_using_refined_send; end
  def compile_using_send; end
  def csend?; end
  def default_compile; end
  def handle___OPAL_COMPILER_CONFIG__; end
  def handle___await__(compile_default); end
  def handle___callee__; end
  def handle___dir__; end
  def handle___method__; end
  def handle_autoload(compile_default); end
  def handle_binding(compile_default); end
  def handle_block_given?; end
  def handle_conditional_send; end
  def handle_constants(compile_default); end
  def handle_debugger; end
  def handle_eval(compile_default); end
  def handle_lambda(compile_default); end
  def handle_local_variables(compile_default); end
  def handle_nesting(compile_default); end
  def handle_require(compile_default); end
  def handle_require_relative; end
  def handle_require_tree(compile_default); end
  def handle_special(&compile_default); end
  def handle_using(compile_default); end
  def handle_writer; end
  def initialize(*); end
  def invoke_using_refinement?; end
  def invoke_using_send?; end
  def iter; end
  def iter_has_break?; end
  def meth; end
  def method_jsid; end
  def push_nesting?; end
  def receiver_sexp; end
  def recvr; end
  def self.add_special(name, options = nil, &handler); end
  def sexp_with_arglist; end
  def splat?; end
  def using_eval?; end
  def using_irb?; end
  def using_refinement(arg); end
  def variable_like?; end
  def with_wrapper(&block); end
end
class Opal::Nodes::CallNode::DependencyResolver
  def expand_path(path, base = nil); end
  def handle_part(sexp, missing_dynamic_require = nil); end
  def initialize(compiler, sexp, missing_dynamic_require = nil); end
  def resolve; end
end
class Opal::Nodes::JsAttrNode < Opal::Nodes::Base
  def compile; end
  def property; end
  def recvr; end
end
class Opal::Nodes::JsAttrAsgnNode < Opal::Nodes::Base
  def compile; end
  def property; end
  def recvr; end
  def value; end
end
class Opal::Nodes::JsCallNode < Opal::Nodes::CallNode
  def compile; end
  def compile_using_send; end
  def initialize(*); end
  def method_jsid; end
end
class Opal::Nodes::Match3Node < Opal::Nodes::Base
  def compile; end
  def extract_names(regexp_node); end
  def generate_names_assignments(names); end
  def generate_names_definition; end
  def handle_non_statement(sexp, names_def, names_assignments); end
  def handle_statement(sexp, names_def, names_assignments); end
  def lhs; end
  def rhs; end
end
class Opal::Nodes::ScopeNode < Opal::Nodes::Base
  def accepts_using?; end
  def add_arg(arg); end
  def add_proto_ivar(ivar); end
  def add_scope_gvar(gvar); end
  def add_scope_ivar(ivar); end
  def add_scope_local(local); end
  def add_scope_temp(tmp); end
  def await_encountered; end
  def await_encountered=(arg0); end
  def block_name; end
  def block_name=(arg0); end
  def catch_return; end
  def catch_return=(arg0); end
  def class?; end
  def class_scope?; end
  def collect_refinements_temps(temps = nil); end
  def current_rescue; end
  def def?; end
  def def_in_class?; end
  def defines_lambda; end
  def defs; end
  def defs=(arg0); end
  def find_parent_def; end
  def gen_retry_id; end
  def gvars; end
  def has_break; end
  def has_break=(arg0); end
  def has_local?(local); end
  def has_rescue_else?; end
  def has_retry; end
  def has_retry=(arg0); end
  def has_temp?(tmp); end
  def identify!(name = nil); end
  def identity; end
  def in_ensure; end
  def in_ensure?; end
  def in_resbody; end
  def in_resbody?; end
  def in_rescue(node); end
  def in_scope; end
  def in_while?; end
  def initialize(*); end
  def is_lambda!; end
  def iter?; end
  def ivars; end
  def lambda?; end
  def lambda_definition?; end
  def locals; end
  def methods; end
  def mid; end
  def mid=(arg0); end
  def module?; end
  def name; end
  def name=(arg0); end
  def nesting; end
  def new_refinements_temp; end
  def new_temp; end
  def next_temp; end
  def parent; end
  def parent=(arg0); end
  def pop_while; end
  def prepare_block(block_name = nil); end
  def prepend_scope_temp(tmp); end
  def push_while; end
  def queue_temp(name); end
  def refinements_temp; end
  def relative_access; end
  def rescue_else_sexp; end
  def rescue_else_sexp=(arg0); end
  def sclass?; end
  def scope_locals; end
  def scope_name; end
  def self; end
  def super_chain; end
  def to_vars; end
  def top?; end
  def uses_block!; end
  def uses_block?; end
end
class Opal::Nodes::ModuleNode < Opal::Nodes::ScopeNode
  def body; end
  def cid; end
  def compile; end
  def compile_body; end
  def name_and_base; end
end
class Opal::Nodes::ClassNode < Opal::Nodes::ModuleNode
  def body; end
  def cid; end
  def compile; end
  def sup; end
  def super_code; end
end
class Opal::Nodes::SingletonClassNode < Opal::Nodes::ScopeNode
  def body; end
  def compile; end
  def object; end
end
module Opal::Nodes::Args
end
class Opal::Nodes::Args::ArgNode < Opal::Nodes::Base
  def compile; end
  def name; end
end
class Opal::Nodes::ArityCheckNode < Opal::Nodes::Base
  def all_args; end
  def args_node; end
  def arity; end
  def arity_checks; end
  def compile; end
  def has_only_optional_kwargs?; end
  def has_required_kwargs?; end
  def initialize(*); end
  def kwargs; end
  def negative_arity; end
  def positive_arity; end
end
class Opal::Nodes::IterArityCheckNode < Opal::Nodes::ArityCheckNode
  def compile; end
end
class Opal::Nodes::Args::EnsureKwargsAreKwargs < Opal::Nodes::Base
  def compile; end
end
class Opal::Nodes::Args::ExtractBlockarg < Opal::Nodes::Base
  def compile; end
  def name; end
end
class Opal::Nodes::Args::ExtractKwarg < Opal::Nodes::Base
  def compile; end
  def lvar_name; end
end
class Opal::Nodes::Args::ExtractKwargs < Opal::Nodes::Base
  def compile; end
end
class Opal::Nodes::Args::ExtractKwoptarg < Opal::Nodes::Base
  def compile; end
  def default_value; end
  def lvar_name; end
end
class Opal::Nodes::Args::ExtractKwrestarg < Opal::Nodes::Base
  def compile; end
  def name; end
  def used_kwargs; end
end
class Opal::Nodes::Args::ExtractOptargNode < Opal::Nodes::Base
  def compile; end
  def default_value; end
  def name; end
end
class Opal::Nodes::Args::ExtractPostArg < Opal::Nodes::Base
  def compile; end
  def name; end
end
class Opal::Nodes::Args::ExtractPostOptarg < Opal::Nodes::Base
  def args_to_keep; end
  def compile; end
  def default_value; end
  def name; end
end
class Opal::Nodes::Args::ExtractRestarg < Opal::Nodes::Base
  def args_to_keep; end
  def compile; end
  def name; end
end
class Opal::Nodes::Args::FakeArgNode < Opal::Nodes::Base
  def compile; end
end
class Opal::Nodes::Args::InitializeIterarg < Opal::Nodes::Base
  def compile; end
  def name; end
end
class Opal::Nodes::Args::InitializeShadowarg < Opal::Nodes::Base
  def compile; end
  def name; end
end
class Opal::Nodes::Args::Parameters
  def initialize(args); end
  def on_arg(arg); end
  def on_blockarg(arg); end
  def on_kwarg(arg); end
  def on_kwnilarg(_arg); end
  def on_kwoptarg(arg); end
  def on_kwrestarg(arg); end
  def on_mlhs(_arg); end
  def on_optarg(arg); end
  def on_restarg(arg); end
  def on_shadowarg(_arg); end
  def to_code; end
end
class Opal::Nodes::Args::PreparePostArgs < Opal::Nodes::Base
  def compile; end
  def offset; end
end
class Opal::Nodes::ArgsNode < Opal::Nodes::Base
  def compile; end
end
class Opal::Nodes::NodeWithArgs < Opal::Nodes::ScopeNode
  def arity; end
  def arity=(arg0); end
  def arity_check_node; end
  def compile_arity_check; end
  def compile_block_arg; end
  def compile_body_or_shortcut; end
  def initialize(*); end
  def original_args; end
  def parameters_code; end
  def self.define_shortcut(name, **kwargs, &block); end
  def self.shortcuts_for(node_type); end
  def simple_value?(node = nil); end
  def used_kwargs; end
end
class Opal::Nodes::NodeWithArgs::Shortcut < Struct
  def compile(node); end
  def for; end
  def for=(_); end
  def match?(node); end
  def name; end
  def name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def transform; end
  def transform=(_); end
  def when; end
  def when=(_); end
end
class Opal::Nodes::IterNode < Opal::Nodes::NodeWithArgs
  def arity_check_node; end
  def compile; end
  def compile_block_arg; end
  def compile_body; end
  def extract_underscore_args; end
  def has_top_level_mlhs_arg?; end
  def has_trailing_comma_in_args?; end
  def inline_args; end
  def returned_body; end
  def stmts; end
end
class Opal::Nodes::DefNode < Opal::Nodes::NodeWithArgs
  def comments_code; end
  def compile; end
  def compile_body; end
  def inline_args; end
  def mid; end
  def stmts; end
  def wrap_with_definition; end
end
class Opal::Nodes::DefsNode < Opal::Nodes::DefNode
  def inline_args; end
  def mid; end
  def recvr; end
  def stmts; end
  def wrap_with_definition; end
end
class Opal::AST::Matcher
  def cap(capture); end
  def captures; end
  def captures=(arg0); end
  def initialize(&block); end
  def inspect; end
  def match(ast); end
  def s(type, *children); end
end
class Opal::AST::Matcher::Node < Struct
  def children; end
  def children=(_); end
  def inspect; end
  def match(ast, matcher); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def type; end
  def type=(_); end
end
class Opal::Nodes::IfNode < Opal::Nodes::Base
  def compile; end
  def compile_switch_case(test); end
  def compile_switch_default; end
  def compile_with_binary_and; end
  def compile_with_binary_or; end
  def compile_with_if; end
  def compile_with_switch; end
  def compile_with_ternary; end
  def could_become_switch?; end
  def could_become_switch_branch?(body); end
  def expects_expression?; end
  def false_body; end
  def falsy; end
  def handle_additional_switch_rules(additional_rules); end
  def returnify(body); end
  def returning?(body); end
  def returning_if?; end
  def should_compile_as_simple_expression?; end
  def simple?(body); end
  def test; end
  def true_body; end
  def truthy; end
  def valid_switch_body?(body, check_variable = nil); end
end
class Opal::Nodes::BaseFlipFlop < Opal::Nodes::Base
  def compile; end
  def end_condition; end
  def start_condition; end
end
class Opal::Nodes::IFlipFlop < Opal::Nodes::BaseFlipFlop
  def excl; end
end
class Opal::Nodes::EFlipFlop < Opal::Nodes::BaseFlipFlop
  def excl; end
end
class Opal::Nodes::NextNode < Opal::Nodes::Base
  def compile; end
  def value; end
end
class Opal::Nodes::BreakNode < Opal::Nodes::Base
  def compile; end
  def value; end
end
class Opal::Nodes::RedoNode < Opal::Nodes::Base
  def compile; end
  def compile_iter; end
  def compile_while; end
end
class Opal::Nodes::SplatNode < Opal::Nodes::Base
  def compile; end
  def empty_splat?; end
  def value; end
end
class Opal::Nodes::RetryNode < Opal::Nodes::Base
  def compile; end
end
class Opal::Nodes::ReturnNode < Opal::Nodes::Base
  def compile; end
  def return_val; end
  def value; end
end
class Opal::Nodes::JSReturnNode < Opal::Nodes::Base
  def compile; end
  def value; end
end
class Opal::Nodes::JSTempNode < Opal::Nodes::Base
  def compile; end
  def value; end
end
class Opal::Nodes::BlockPassNode < Opal::Nodes::Base
  def compile; end
  def value; end
end
class Opal::Nodes::UndefNode < Opal::Nodes::Base
  def compile; end
  def value; end
end
class Opal::Nodes::AliasNode < Opal::Nodes::Base
  def compile; end
  def new_name; end
  def old_name; end
end
class Opal::Nodes::BeginNode < Opal::Nodes::ScopeNode
  def compile; end
  def compile_children(children, level); end
  def compile_inline_children(children, level); end
  def returned_children; end
  def simple_children?; end
end
class Opal::Nodes::KwBeginNode < Opal::Nodes::BeginNode
end
class Opal::Nodes::BaseYieldNode < Opal::Nodes::Base
  def compile_call; end
  def find_yielding_scope; end
  def uses_splat?(children); end
  def yields_single_arg?(children); end
end
class Opal::Nodes::YieldNode < Opal::Nodes::BaseYieldNode
  def compile; end
end
class Opal::Nodes::ReturnableYieldNode < Opal::Nodes::BaseYieldNode
  def compile; end
end
class Opal::Nodes::EnsureNode < Opal::Nodes::Base
  def begn; end
  def body_sexp; end
  def compile; end
  def ensr; end
  def ensr_sexp; end
  def has_rescue_else?; end
  def rescue_else_code; end
  def wrap_in_closure?; end
end
class Opal::Nodes::RescueNode < Opal::Nodes::Base
  def body; end
  def body_code; end
  def compile; end
  def handle_rescue_else_manually?; end
  def has_retry?; end
  def rescue_else_code; end
end
class Opal::Nodes::ResBodyNode < Opal::Nodes::Base
  def body; end
  def compile; end
  def klasses; end
  def klasses_sexp; end
  def lvar; end
  def rescue_body; end
end
class Opal::Nodes::BaseSuperNode < Opal::Nodes::CallNode
  def allow_stubs; end
  def compile_method_body; end
  def compile_method_name; end
  def compile_using_send; end
  def def_scope; end
  def def_scope_identity; end
  def defined_check_param; end
  def implicit_arguments_param; end
  def initialize(*); end
  def method_id; end
  def super_block_invocation; end
  def super_method_invocation; end
end
class Opal::Nodes::DefinedSuperNode < Opal::Nodes::BaseSuperNode
  def allow_stubs; end
  def compile; end
  def defined_check_param; end
end
class Opal::Nodes::SuperNode < Opal::Nodes::BaseSuperNode
  def compile; end
  def initialize(*); end
end
class Opal::Nodes::ZsuperNode < Opal::Nodes::SuperNode
  def block_name; end
  def compile; end
  def implicit_arglist; end
  def implicit_arguments_param; end
  def initialize(*); end
end
class Opal::Nodes::TopNode < Opal::Nodes::ScopeNode
  def absolute_const; end
  def add_file_source_embed; end
  def add_used_helpers; end
  def body; end
  def closing; end
  def compile; end
  def compile_end_construct; end
  def compile_irb_vars; end
  def compile_method_stubs; end
  def definition; end
  def module_name; end
  def opening; end
  def stmts; end
  def version_comment; end
end
class Opal::Nodes::WhileNode < Opal::Nodes::Base
  def body; end
  def compile; end
  def compile_while(test_code, redo_code = nil); end
  def compile_with_redo(test_code); end
  def compile_without_redo(test_code); end
  def test; end
  def uses_redo?; end
  def while_close; end
  def while_open; end
  def wrap_in_closure?; end
end
class Opal::Nodes::UntilNode < Opal::Nodes::WhileNode
  def while_close; end
  def while_open; end
end
class Opal::Nodes::WhilePostNode < Opal::Nodes::WhileNode
  def compile_while(test_code, redo_code = nil); end
  def while_close; end
end
class Opal::Nodes::UntilPostNode < Opal::Nodes::WhilePostNode
  def while_close; end
  def while_open; end
end
class Opal::Nodes::HashNode < Opal::Nodes::Base
  def compile; end
  def compile_hash; end
  def compile_merge; end
  def has_kwsplat; end
  def has_kwsplat=(arg0); end
  def initialize(*); end
  def keys; end
  def keys=(arg0); end
  def simple_keys?; end
  def values; end
  def values=(arg0); end
end
class Opal::Nodes::KwSplatNode < Opal::Nodes::Base
  def compile; end
  def value; end
end
class Opal::Nodes::ArrayNode < Opal::Nodes::Base
  def compile; end
end
class Opal::Nodes::DefinedNode < Opal::Nodes::Base
  def compile; end
  def compile_defined(node); end
  def compile_defined_array(node); end
  def compile_defined_back_ref; end
  def compile_defined_const(node); end
  def compile_defined_cvar(node); end
  def compile_defined_gvar(node); end
  def compile_defined_ivar(node); end
  def compile_defined_nth_ref; end
  def compile_defined_send(node); end
  def compile_defined_super; end
  def compile_defined_xstr(node); end
  def compile_defined_yield; end
  def compile_send_recv_doesnt_raise(recv_code); end
  def value; end
  def wrap_with_try_catch(code); end
end
class Opal::Nodes::MassAssignNode < Opal::Nodes::Base
  def compile; end
  def compile_assignment(child, array, idx, len = nil); end
  def compile_masgn(lhs_items, array, len = nil); end
  def lhs; end
  def rhs; end
end
class Opal::Nodes::ArglistNode < Opal::Nodes::Base
  def compile; end
end
class Opal::Nodes::XStringNode < Opal::Nodes::Base
  def compile; end
  def compile_child(child); end
  def compile_javascript; end
  def compile_send; end
  def compile_single_line(children); end
  def extract_last_value(last_child); end
  def self.single_line?(children); end
  def self.strip_empty_children(children); end
  def unpack_return(children); end
end
class Opal::Nodes::LambdaNode < Opal::Nodes::Base
  def compile; end
  def iter; end
end
class Opal::EofContent
  def eof; end
  def initialize(tokens, source); end
  def last_token_position; end
end
class Opal::Error < StandardError
end
class Opal::GemNotFound < Opal::Error
  def gem_name; end
  def initialize(gem_name); end
end
class Opal::CompilationError < Opal::Error
  def location; end
  def location=(arg0); end
end
class Opal::ParsingError < Opal::CompilationError
end
class Opal::RewritingError < Opal::ParsingError
end
class Opal::SyntaxError < SyntaxError
  def location; end
  def location=(arg0); end
end
class Opal::OpalBacktraceLocation
  def diagnostic=(diagnostic); end
  def initialize(path = nil, lineno = nil, label = nil); end
  def label; end
  def label=(arg0); end
  def line; end
  def lineno; end
  def lineno=(arg0); end
  def location=(location); end
  def path; end
  def path=(arg0); end
  def to_s; end
end
module Opal::MagicComments
  def self.parse(sexp, comments); end
end
module Opal::SourceMap
end
class Opal::Compiler
  def arity_check?; end
  def async_await; end
  def async_await_before_typecasting; end
  def async_await_set_to_regexp(set); end
  def autoloads; end
  def backtick_javascript?; end
  def backtick_javascript_or_warn?; end
  def case_stmt; end
  def comments; end
  def compile; end
  def dynamic_cache_result; end
  def dynamic_cache_result=(arg0); end
  def dynamic_require_severity; end
  def enable_file_source_embed?; end
  def enable_source_location?; end
  def eof_content; end
  def error(msg, line = nil); end
  def esm?; end
  def eval?; end
  def file; end
  def fragment(str, scope, sexp = nil); end
  def fragments; end
  def freezing?; end
  def handle_block_given_call(sexp); end
  def handlers; end
  def helper(name); end
  def helpers; end
  def in_case; end
  def in_while; end
  def in_while?; end
  def indent; end
  def initialize(source, options = nil); end
  def inline_operators?; end
  def irb?; end
  def load?; end
  def magic_comments; end
  def marshal_dump; end
  def marshal_load(src); end
  def method_calls; end
  def method_missing?; end
  def no_export?; end
  def option_value(name, config); end
  def parse; end
  def parse_comments?; end
  def parser_indent; end
  def process(sexp, level = nil); end
  def re_raise_with_location; end
  def record_method_call(mid); end
  def requirable?; end
  def required_trees; end
  def requires; end
  def result; end
  def returns(sexp); end
  def s(type, *children); end
  def scope; end
  def scope=(arg0); end
  def scope_variables; end
  def self.compiler_option(name, config = nil); end
  def self.module_name(path); end
  def source; end
  def source_map; end
  def top_scope; end
  def top_scope=(arg0); end
  def unique_temp(name); end
  def use_strict?; end
  def warning(msg, line = nil); end
  def with_temp; end
  include Opal::Nodes::Closure::CompilerSupport
end
module Opal::Hike
end
class Opal::Hike::Index
  def build_pattern_for(basename); end
  def entries(path); end
  def extensions; end
  def extract_options!(arguments); end
  def find(logical_path); end
  def find_in_base_path(logical_path, base_path, &block); end
  def find_in_paths(logical_path, &block); end
  def index; end
  def initialize(root, paths, extensions); end
  def match(dirname, basename); end
  def paths; end
  def paths_contain?(dirname); end
  def pattern_for(basename); end
  def root; end
  def sort_matches(matches, basename); end
  def stat(path); end
end
class Opal::Hike::Trail
  def append_extensions(*extensions); end
  def append_paths(*paths); end
  def entries(path); end
  def extensions; end
  def find(*args, &block); end
  def index; end
  def initialize(root = nil); end
  def normalize_extension(ext); end
  def normalize_path(path); end
  def paths; end
  def root; end
  def stat(path); end
end
class Opal::PathReader
  def append_paths(*paths); end
  def expand(path); end
  def extensions; end
  def file_finder; end
  def find_path(path); end
  def initialize(paths = nil, extensions = nil); end
  def paths; end
  def read(path); end
end
module Opal::UseGem
  def require_paths_for_gem(gem_name, include_dependencies); end
  def use_gem(gem_name, include_dependencies = nil); end
end
module Opal::Cache
  def digest(string); end
  def fetch(cache, key, &block); end
  def runtime_key; end
  def self.digest(string); end
  def self.fetch(cache, key, &block); end
  def self.runtime_key; end
end
class Opal::Cache::FileCache
  def cache_filename_for(key); end
  def get(key); end
  def initialize(dir: nil, max_size: nil); end
  def self.dir_writable?(*paths); end
  def self.find_dir; end
  def set(key, data); end
  def tidy_up_cache; end
end
class Opal::Cache::NullCache
  def fetch(*); end
end
module Opal::OS
  def bash_c(*commands); end
  def cmd_sep; end
  def dev_null; end
  def env_sep; end
  def macos?; end
  def path_sep; end
  def self.bash_c(*commands); end
  def self.cmd_sep; end
  def self.dev_null; end
  def self.env_sep; end
  def self.macos?; end
  def self.path_sep; end
  def self.shellescape(str); end
  def self.windows?; end
  def shellescape(str); end
  def windows?; end
end
class Opal::BuilderScheduler
  def builder; end
  def builder=(arg0); end
  def initialize(builder); end
end
class Opal::BuilderScheduler::Prefork < Opal::BuilderScheduler
  def fork_count; end
  def fork_entrypoint(io); end
  def prefork; end
  def prefork_reactor(rel_path, requires, autoloads, options); end
  def process_requires(rel_path, requires, autoloads, options); end
end
module Opal::BuilderScheduler::Prefork::OrderCorrector
  def build_require_order_array(requires, requires_hash, built_for = nil); end
  def correct_order(processed, requires, builder); end
  def expand_requires(requires, builder); end
  def self.build_require_order_array(requires, requires_hash, built_for = nil); end
  def self.correct_order(processed, requires, builder); end
  def self.expand_requires(requires, builder); end
end
class Opal::BuilderScheduler::Prefork::ForkSet < Array
  def close; end
  def create_fork; end
  def from_io(io, type); end
  def get_events(queue_length); end
  def initialize(count, &block); end
  def wait; end
end
class Opal::BuilderScheduler::Prefork::Fork
  def close; end
  def eof?; end
  def fork?; end
  def goodbye; end
  def initialize(forkset); end
  def read_io; end
  def recv; end
  def recv_message(io); end
  def send(*msg); end
  def send_message(io, msg); end
  def wait; end
  def write_io; end
end
class Opal::Builder
  def already_processed; end
  def append_paths(*paths); end
  def build(path, options = nil); end
  def build_require(path, options = nil); end
  def build_str(source, rel_path, options = nil); end
  def cache; end
  def cache=(arg0); end
  def compiler_options; end
  def compiler_options=(arg0); end
  def dependent_files; end
  def esm?; end
  def expand_ext(path); end
  def expand_path(path); end
  def extensions; end
  def initialize(options = nil); end
  def initialize_copy(other); end
  def missing_require_severity; end
  def missing_require_severity=(arg0); end
  def output_extension; end
  def path_reader; end
  def path_reader=(arg0); end
  def preload; end
  def preload=(arg0); end
  def prerequired; end
  def prerequired=(arg0); end
  def process_require(rel_path, autoloads, options); end
  def process_require_threadsafely(rel_path, autoloads, options); end
  def process_requires(rel_path, requires, autoloads, options); end
  def processed; end
  def processor_for(source, rel_path, abs_path, autoload, options); end
  def processors; end
  def processors=(arg0); end
  def read(path, autoload); end
  def scheduler; end
  def scheduler=(arg0); end
  def self.build(*args, &block); end
  def self.extensions; end
  def self.processors; end
  def self.register_processor(processor, processor_extensions); end
  def source_for(path); end
  def source_map; end
  def stub?(path); end
  def stubs; end
  def stubs=(arg0); end
  def to_s; end
  def tree_requires(asset, asset_path); end
  include Opal::UseGem
end
class Opal::Builder::MissingRequire < LoadError
end
class Opal::Builder::ProcessorNotFound < LoadError
end
module Opal::ERB
  def self.compile(source, file_name = nil); end
end
class Opal::ERB::Compiler
  def compile; end
  def find_code(result); end
  def find_contents(result); end
  def fix_quotes(result); end
  def initialize(source, file_name = nil); end
  def prepared_source; end
  def require_erb(result); end
  def wrap_compiled(result); end
end
module Opal::BuilderProcessors
end
class Opal::BuilderProcessors::Processor
  def abs_path; end
  def autoloads; end
  def filename; end
  def initialize(source, filename, abs_path = nil, options = nil); end
  def mark_as_required(filename); end
  def options; end
  def required_trees; end
  def requires; end
  def self.extensions; end
  def self.handles(*extensions); end
  def self.match?(other); end
  def self.match_regexp; end
  def source; end
  def to_s; end
end
class Opal::BuilderProcessors::JsProcessor < Opal::BuilderProcessors::Processor
  def source; end
  def source_map; end
end
class Opal::BuilderProcessors::JsProcessor::ManualFragment < Struct
  def code; end
  def code=(_); end
  def column; end
  def column=(_); end
  def line; end
  def line=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def source_map_name; end
  def source_map_name=(_); end
end
class Opal::BuilderProcessors::RubyProcessor < Opal::BuilderProcessors::Processor
  def autoloads; end
  def cache_key; end
  def compiled; end
  def compiler_for(source, options = nil); end
  def required_trees; end
  def requires; end
  def self.match?(other); end
  def source; end
  def source_map; end
end
class Opal::BuilderProcessors::OpalERBProcessor < Opal::BuilderProcessors::RubyProcessor
  def initialize(*args); end
  def prepare(source, path); end
  def requires; end
end
class Opal::BuilderProcessors::RubyERBProcessor < Opal::BuilderProcessors::RubyProcessor
  def compiled; end
end
class Opal::BuilderProcessors::ERBProcessor < Opal::BuilderProcessors::Processor
  def source; end
end
module Opal::Deprecations
  def deprecation(message); end
  def raise_on_deprecation; end
  def raise_on_deprecation=(arg0); end
end
