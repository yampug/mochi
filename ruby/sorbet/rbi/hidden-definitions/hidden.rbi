# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class ArgumentError
  include ::ErrorHighlight::CoreExt
end

class Array
  def deconstruct(); end

  def to_h(); end
end

class Array
  def self.new(*arg); end

  def self.try_convert(arg); end
end

BasicObject::BasicObject = BasicObject

class Binding
  def clone(); end
end

class Bundler::APIResponseInvalidDependenciesError
  def status_code(); end
end

class Bundler::APIResponseInvalidDependenciesError
end

module Bundler::CIDetector
  ENV_DESCRIPTORS = ::T.let(nil, ::T.untyped)
  ENV_INDICATORS = ::T.let(nil, ::T.untyped)
end

module Bundler::CIDetector
  def self.ci?(); end

  def self.ci_strings(); end
end

class Bundler::CLI
  def add(*gems); end

  def binstubs(*gems); end

  def cache(); end

  def check(); end

  def clean(); end

  def cli_help(); end

  def config(*args); end

  def console(group=T.unsafe(nil)); end

  def doctor(); end

  def env(); end

  def exec(*args); end

  def fund(); end

  def help(cli=T.unsafe(nil)); end

  def info(gem_name); end

  def init(); end

  def initialize(*args); end

  def inject(name, version); end

  def install(); end

  def issue(); end

  def licenses(); end

  def list(); end

  def lock(); end

  def open(name); end

  def outdated(*gems); end

  def platform(); end

  def plugin(*args); end

  def pristine(*gems); end

  def remove(*gems); end

  def show(gem_name=T.unsafe(nil)); end

  def update(*gems); end

  def version(); end

  def viz(); end
  AUTO_INSTALL_CMDS = ::T.let(nil, ::T.untyped)
  COMMAND_ALIASES = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  PARSEABLE_COMMANDS = ::T.let(nil, ::T.untyped)
end

module Bundler::CLI::Common
end

module Bundler::CLI::Common
  def self.ask_for_spec_from(specs); end

  def self.clean_after_install?(); end

  def self.configure_gem_version_promoter(definition, options); end

  def self.default_gem_spec(name); end

  def self.ensure_all_gems_in_lockfile!(names, locked_gems=T.unsafe(nil)); end

  def self.gem_not_found_message(missing_gem_name, alternatives); end

  def self.output_fund_metadata_summary(); end

  def self.output_post_install_messages(messages); end

  def self.output_without_groups_message(command); end

  def self.patch_level_options(options); end

  def self.print_post_install_message(name, msg); end

  def self.select_spec(name, regex_match=T.unsafe(nil)); end

  def self.verbalize_groups(groups); end

  def self.without_groups_message(command); end
end

class Bundler::CLI::Config
  def base(name=T.unsafe(nil), *value); end

  def get(name); end

  def list(); end

  def set(name, value, *value_); end

  def unset(name); end
end

class Bundler::CLI::Config::Base
  def confirm(name); end

  def confirm_all(); end

  def explicit_scope?(); end

  def initialize(options, name, value, thor); end

  def message(); end

  def name(); end

  def new_value(); end

  def options(); end

  def run(); end

  def scope(); end

  def show_pretty_values_for(setting); end

  def thor(); end

  def validate_scope!(); end

  def value(); end

  def warn_unused_scope(msg); end
end

class Bundler::CLI::Config::Base
end

class Bundler::CLI::Config
end

class Bundler::CLI::Install
  def initialize(options); end

  def options(); end

  def run(); end
end

class Bundler::CLI::Install
end

class Bundler::CLI::Plugin
  def install(*plugins); end

  def list(); end

  def uninstall(*plugins); end
end

class Bundler::CLI::Plugin
end

class Bundler::CLI
  def self.aliases_for(command_name); end

  def self.all_aliases(); end

  def self.check_deprecated_ext_option(arguments); end

  def self.deprecated_ext_value?(arguments); end

  def self.dispatch(*arg); end

  def self.reformatted_help_args(args); end

  def self.source_root(); end

  def self.start(*arg); end
end

class Bundler::Checksum
  def ==(other); end

  def algo(); end

  def digest(); end

  def eql?(other); end

  def formatted_sources(); end

  def initialize(algo, digest, source); end

  def match?(other); end

  def merge!(other); end

  def removable?(); end

  def removal_instructions(); end

  def same_source?(other); end

  def sources(); end

  def to_lock(); end
  ALGO_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Bundler::Checksum::Source
  def ==(other); end

  def initialize(type, location); end

  def location(); end

  def removable?(); end

  def removal(); end

  def type(); end
end

class Bundler::Checksum::Source
end

class Bundler::Checksum::Store
  def merge!(other); end

  def register(spec, checksum); end

  def replace(spec, checksum); end

  def store(); end

  def to_lock(spec); end
end

class Bundler::Checksum::Store
end

class Bundler::Checksum
  def self.from_api(digest, source_uri, algo=T.unsafe(nil)); end

  def self.from_gem(io, pathname, algo=T.unsafe(nil)); end

  def self.from_gem_package(gem_package, algo=T.unsafe(nil)); end

  def self.from_lock(lock_checksum, lockfile_location); end

  def self.to_hexdigest(digest, algo=T.unsafe(nil)); end
end

class Bundler::ChecksumMismatchError
  def initialize(lock_name, existing, checksum); end

  def mismatch_resolution_instructions(); end
end

class Bundler::ChecksumMismatchError
end

class Bundler::CompactIndexClient
  def available?(); end

  def dependencies(names); end

  def info(name); end

  def initialize(directory, fetcher=T.unsafe(nil)); end

  def latest_version(name); end

  def names(); end

  def reset!(); end

  def versions(); end
  DEBUG_MUTEX = ::T.let(nil, ::T.untyped)
  INFO_DEPS = ::T.let(nil, ::T.untyped)
  INFO_NAME = ::T.let(nil, ::T.untyped)
  INFO_PLATFORM = ::T.let(nil, ::T.untyped)
  INFO_REQS = ::T.let(nil, ::T.untyped)
  INFO_VERSION = ::T.let(nil, ::T.untyped)
  SUPPORTED_DIGESTS = ::T.let(nil, ::T.untyped)
end

class Bundler::CompactIndexClient::Cache
  def directory(); end

  def info(name, remote_checksum=T.unsafe(nil)); end

  def initialize(directory, fetcher=T.unsafe(nil)); end

  def names(); end

  def reset!(); end

  def versions(); end
end

class Bundler::CompactIndexClient::Cache
end

class Bundler::CompactIndexClient::CacheFile
  def append(data); end

  def close(); end

  def commit(); end

  def commit!(); end

  def digests=(expected_digests); end

  def digests?(); end

  def initialize(original_path, &block); end

  def initialize_digests(keys=T.unsafe(nil)); end

  def md5(); end

  def open(write_mode=T.unsafe(nil), perm=T.unsafe(nil), &block); end

  def original_path(); end

  def path(); end

  def reset_digests(); end

  def size(); end

  def verify(); end

  def write(data); end
end

class Bundler::CompactIndexClient::CacheFile::ClosedError
end

class Bundler::CompactIndexClient::CacheFile::ClosedError
end

class Bundler::CompactIndexClient::CacheFile::DigestMismatchError
  def initialize(digests, expected_digests); end
end

class Bundler::CompactIndexClient::CacheFile::DigestMismatchError
end

class Bundler::CompactIndexClient::CacheFile::Error
end

class Bundler::CompactIndexClient::CacheFile::Error
end

class Bundler::CompactIndexClient::CacheFile
  def self.copy(path, &block); end

  def self.write(path, data, digests=T.unsafe(nil)); end
end

class Bundler::CompactIndexClient::Error
end

class Bundler::CompactIndexClient::Error
end

Bundler::CompactIndexClient::GemParser = Gem::Resolver::APISet::GemParser

class Bundler::CompactIndexClient::Parser
  def available?(); end

  def info(name); end

  def initialize(compact_index); end

  def names(); end

  def versions(); end
end

class Bundler::CompactIndexClient::Parser
end

class Bundler::CompactIndexClient::Updater
  def initialize(fetcher); end

  def update(remote_path, local_path, etag_path); end
end

class Bundler::CompactIndexClient::Updater::MismatchedChecksumError
  def initialize(path, message); end
end

class Bundler::CompactIndexClient::Updater::MismatchedChecksumError
end

class Bundler::CompactIndexClient::Updater
end

class Bundler::CompactIndexClient
  def self.debug(); end
end

class Bundler::ConnectionPool
  def auto_reload_after_fork(); end

  def available(); end

  def checkin(force: T.unsafe(nil)); end

  def checkout(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil), &block); end

  def reload(&block); end

  def shutdown(&block); end

  def size(); end

  def then(options=T.unsafe(nil)); end

  def with(options=T.unsafe(nil)); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::ConnectionPool::TimedStack
  def <<(obj, options=T.unsafe(nil)); end

  def empty?(); end

  def initialize(size=T.unsafe(nil), &block); end

  def length(); end

  def max(); end

  def pop(timeout=T.unsafe(nil), options=T.unsafe(nil)); end

  def push(obj, options=T.unsafe(nil)); end

  def shutdown(reload: T.unsafe(nil), &block); end
end

class Bundler::ConnectionPool::TimedStack
end

class Bundler::ConnectionPool
  def self.after_fork(); end

  def self.wrap(options, &block); end
end

class Bundler::CorruptBundlerInstallError
  def initialize(loaded_spec); end

  def status_code(); end
end

class Bundler::CorruptBundlerInstallError
end

class Bundler::CurrentRuby
  def jruby_30?(); end

  def jruby_31?(); end

  def jruby_32?(); end

  def jruby_33?(); end

  def jruby_3?(); end

  def maglev_30?(); end

  def maglev_31?(); end

  def maglev_32?(); end

  def maglev_33?(); end

  def maglev_3?(); end

  def mingw_30?(); end

  def mingw_31?(); end

  def mingw_32?(); end

  def mingw_33?(); end

  def mingw_3?(); end

  def mri_30?(); end

  def mri_31?(); end

  def mri_32?(); end

  def mri_33?(); end

  def mri_3?(); end

  def mswin64_30?(); end

  def mswin64_31?(); end

  def mswin64_32?(); end

  def mswin64_33?(); end

  def mswin64_3?(); end

  def mswin_30?(); end

  def mswin_31?(); end

  def mswin_32?(); end

  def mswin_33?(); end

  def mswin_3?(); end

  def on_30?(); end

  def on_31?(); end

  def on_32?(); end

  def on_33?(); end

  def on_3?(); end

  def rbx_30?(); end

  def rbx_31?(); end

  def rbx_32?(); end

  def rbx_33?(); end

  def rbx_3?(); end

  def ruby_30?(); end

  def ruby_31?(); end

  def ruby_32?(); end

  def ruby_33?(); end

  def ruby_3?(); end

  def truffleruby_30?(); end

  def truffleruby_31?(); end

  def truffleruby_32?(); end

  def truffleruby_33?(); end

  def truffleruby_3?(); end

  def windows?(); end

  def windows_18?(); end

  def windows_19?(); end

  def windows_1?(); end

  def windows_20?(); end

  def windows_21?(); end

  def windows_22?(); end

  def windows_23?(); end

  def windows_24?(); end

  def windows_25?(); end

  def windows_26?(); end

  def windows_27?(); end

  def windows_2?(); end

  def windows_30?(); end

  def windows_31?(); end

  def windows_32?(); end

  def windows_33?(); end

  def windows_3?(); end

  def x64_mingw_30?(); end

  def x64_mingw_31?(); end

  def x64_mingw_32?(); end

  def x64_mingw_33?(); end

  def x64_mingw_3?(); end
end

class Bundler::Definition
  def bundler_version_to_lock(); end

  def current_locked_dependencies(); end

  def deleted_deps(); end

  def dependencies_for(groups); end

  def filter_relevant(dependencies); end

  def locked_checksums(); end

  def locked_dependencies(); end

  def most_specific_locked_platform(); end

  def new_deps(); end

  def no_resolve_needed?(); end

  def prefer_local!(); end

  def requested_dependencies(); end

  def resolve_only_locally!(); end
end

class Bundler::Definition
  def self.no_lock(); end

  def self.no_lock=(no_lock); end
end

class Bundler::Dependency
  def branch(); end

  def expanded_platforms(); end

  def gemspec_dev_dep?(); end

  def git(); end

  def github(); end

  def glob(); end

  def path(); end

  def ref(); end
  ALL_RUBY_VERSIONS = ::T.let(nil, ::T.untyped)
end

Bundler::Deprecate = Gem::Deprecate

module Bundler::Digest
  SHA1_MASK = ::T.let(nil, ::T.untyped)
  SHA1_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Digest
  def self.sha1(string); end
end

class Bundler::DirectoryRemovalError
  def initialize(orig_exception, msg); end

  def status_code(); end
end

class Bundler::DirectoryRemovalError
end

class Bundler::Dsl
  def check_primary_source_safety(); end

  def gemfile(); end
  GITHUB_PULL_REQUEST_URL = ::T.let(nil, ::T.untyped)
  GITLAB_MERGE_REQUEST_URL = ::T.let(nil, ::T.untyped)
end

class Bundler::EndpointSpecification
  include ::Bundler::MatchRemoteMetadata
  include ::Bundler::FetchMetadata
end

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::EnvironmentPreserver
  def replace_with_backup(); end
end

class Bundler::EnvironmentPreserver
  def self.from_env(); end
end

module Bundler::FetchMetadata
  def matches_current_ruby?(); end

  def matches_current_rubygems?(); end
end

module Bundler::FetchMetadata
end

class Bundler::Fetcher
  def api_fetcher?(); end

  def fetch_spec(spec); end

  def gem_remote_fetcher(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationForbiddenError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::AuthenticationForbiddenError
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def gem_remote_fetcher(); end

  def initialize(downloader, remote, display_uri, gem_remote_fetcher); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end

  def self.ln_sr(src, dest, target_directory: T.unsafe(nil), force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
end

module Bundler::ForcePlatform
end

module Bundler::ForcePlatform
end

class Bundler::GemHelpers::PlatformMatch
  def self.specificity_score(spec_platform, user_platform); end
end

module Bundler::GemHelpers
  def self.force_ruby_platform(specs); end

  def self.generic_local_platform_is_ruby?(); end

  def self.local_platform(); end

  def self.same_deps(spec, exemplary_spec); end

  def self.same_specificity(platform, spec, exemplary_spec); end

  def self.sort_best_platform_match(matching, platform); end
end

class Bundler::GemVersionPromoter
  def filter_versions(package, specs); end

  def level(); end

  def level=(value); end

  def major?(); end

  def minor?(); end

  def pre(); end

  def pre=(pre); end

  def pre?(); end

  def sort_versions(package, specs); end

  def strict(); end

  def strict=(strict); end
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
  def add(spec); end

  def duplicates(); end

  def merge!(other); end

  def subset?(other); end
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::InsecureInstallPathError
  def initialize(path); end

  def status_code(); end
end

class Bundler::InsecureInstallPathError
end

class Bundler::Installer
  def definition(); end
end

class Bundler::LazySpecification
  include ::Bundler::ForcePlatform
  def dependencies=(dependencies); end

  def eql?(other); end

  def force_ruby_platform(); end

  def force_ruby_platform!(); end

  def force_ruby_platform=(force_ruby_platform); end

  def lock_name(); end

  def materialize_for_installation(); end

  def name_tuple(); end

  def required_ruby_version(); end

  def required_ruby_version=(required_ruby_version); end

  def required_rubygems_version(); end

  def required_rubygems_version=(required_rubygems_version); end

  def runtime_dependencies(); end
end

class Bundler::LazySpecification
  def self.from_spec(s); end
end

class Bundler::LockfileParser
  def checksums(); end

  def may_include_redundant_platform_specific_gems?(); end
  CHECKSUMS = ::T.let(nil, ::T.untyped)
end

class Bundler::LockfileParser::Position
  def advance!(string); end

  def column(); end

  def initialize(line, column); end

  def line(); end
end

class Bundler::LockfileParser::Position
end

class Bundler::LockfileParser
  def self.bundled_with(); end
end

module Bundler::MatchMetadata
  def matches_current_metadata?(); end

  def matches_current_ruby?(); end

  def matches_current_rubygems?(); end
end

module Bundler::MatchMetadata
end

module Bundler::MatchRemoteMetadata
  include ::Bundler::MatchMetadata
  include ::Bundler::FetchMetadata
end

module Bundler::MatchRemoteMetadata
end

class Bundler::PermissionError
  def parent_folder(); end

  def permission_type(); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def add_dependency_names(names); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def checksum_store(); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*arg); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def identifier(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def local!(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def spec_names(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index
  def installed_in_plugin_root?(name); end

  def installed_plugins(); end

  def plugin_commands(plugin); end

  def unregister_plugin(name); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Path
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Path
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::PluginInstallError
end

class Bundler::Plugin::PluginInstallError
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  def self.from_lock(locked_opts); end

  def self.list(); end

  def self.loaded?(plugin); end

  def self.save_plugin(name, spec, optional_plugin=T.unsafe(nil)); end

  def self.uninstall(names, options); end
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::PubGrub::Incompatibility
  def cause(); end

  def conflict?(); end

  def eql?(other); end

  def external_incompatibilities(); end

  def failure?(); end

  def initialize(terms, cause:, custom_explanation: T.unsafe(nil)); end

  def terms(); end
end

class Bundler::PubGrub::Incompatibility
end

class Bundler::RemoteSpecification
  include ::Bundler::MatchRemoteMetadata
  include ::Bundler::MatchMetadata
  include ::Bundler::FetchMetadata
  def runtime_dependencies(); end
end

class Bundler::Resolver
  include ::Bundler::GemHelpers
  def all_versions_for(package); end

  def bundler_pinned_to_current_version?(); end

  def default_bundler_source(); end

  def find_names_to_relax(incompatibility); end

  def incompatibilities_for(package, version); end

  def no_versions_incompatibility_for(package, unsatisfied_term); end

  def parse_dependency(package, dependency); end

  def raise_not_found!(package); end

  def setup_solver(); end

  def solve_versions(root:, logger:); end

  def source_for(name); end

  def versions_for(package, range=T.unsafe(nil)); end
end

class Bundler::Resolver::Base
  def [](name); end

  def base_requirements(); end

  def delete(specs); end

  def get_package(name); end

  def include_prereleases(names); end

  def initialize(source_requirements, dependencies, base, platforms, options); end

  def packages(); end

  def requirements(); end

  def source_requirements(); end

  def unlock_names(names); end
end

class Bundler::Resolver::Base
end

class Bundler::Resolver::Candidate
  include ::Comparable
  def ==(other); end

  def dependencies(); end

  def eql?(other); end

  def generic!(); end

  def initialize(version, specs: T.unsafe(nil)); end

  def platform_specific!(); end

  def prerelease?(); end

  def segments(); end

  def sort_obj(); end

  def to_specs(package); end

  def version(); end
end

class Bundler::Resolver::Candidate
end

class Bundler::Resolver::Incompatibility
  def extended_explanation(); end

  def initialize(terms, cause:, custom_explanation: T.unsafe(nil), extended_explanation: T.unsafe(nil)); end
end

class Bundler::Resolver::Incompatibility
end

class Bundler::Resolver::Package
  def ==(other); end

  def consider_prereleases!(); end

  def current_platform?(); end

  def dependency(); end

  def force_ruby_platform?(); end

  def ignores_prereleases?(); end

  def initialize(name, platforms, locked_specs:, unlock:, prerelease: T.unsafe(nil), dependency: T.unsafe(nil)); end

  def locked_version(); end

  def meta?(); end

  def name(); end

  def platforms(); end

  def prerelease_specified?(); end

  def root?(); end

  def top_level?(); end

  def unlock?(); end
end

class Bundler::Resolver::Package
end

class Bundler::Resolver::Root
  def initialize(name); end
end

class Bundler::Resolver::Root
end

class Bundler::Resolver::SpecGroup
  def dependencies(); end

  def empty?(); end

  def sorted_spec_names(); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

module Bundler::RubyDsl
  def normalize_ruby_file(filename); end
end

class Bundler::RubygemsIntegration
  def add_default_gems_to(specs); end

  def all_specs(); end

  def default_specs(); end

  def default_stubs(); end

  def find_bundler(version); end

  def find_name(name); end

  def installed_specs(); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def stub_rubygems(specs); end

  def supports_bundler_trampolining?(); end
end

module Bundler::SafeMarshal
  ALLOWED_CLASSES = ::T.let(nil, ::T.untyped)
  ERROR = ::T.let(nil, ::T.untyped)
  PROC = ::T.let(nil, ::T.untyped)
end

module Bundler::SafeMarshal
end

class Bundler::SelfManager
  def install_locked_bundler_and_restart_with_it_if_needed(); end

  def restart_with_locked_bundler_if_needed(); end

  def update_bundler_and_restart_with_it_if_needed(target); end
end

class Bundler::SelfManager
end

class Bundler::Settings
  def processor_count(); end
  FALLBACK_TIMEOUT_URI_OPTION = ::T.let(nil, ::T.untyped)
  REMEMBERED_KEYS = ::T.let(nil, ::T.untyped)
  STRING_KEYS = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Path
  def self.keyword_init?(); end
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Settings
  def self.key_for(key); end

  def self.key_to_s(key); end
end

module Bundler::SharedHelpers
  def bundle_bin_path(); end

  def checksum_for_file(path, digest); end

  def relative_gemfile_path(); end

  def relative_lockfile_path(); end

  def relative_path_to(destination, from: T.unsafe(nil)); end
end

class Bundler::SolveFailure
  def status_code(); end
end

class Bundler::SolveFailure
end

class Bundler::Source
  def add_dependency_names(names); end

  def cached!(); end

  def checksum_store(); end

  def identifier(); end

  def local!(); end

  def local_only!(); end

  def remote!(); end

  def spec_names(); end
end

class Bundler::Source::Git
  def current_branch(); end

  def glob(); end

  def local?(); end

  def to_gemfile(); end

  def uri_with_specifiers(specifiers); end
end

class Bundler::Source::Rubygems
  def default_cache_path_for(dir); end

  def default_specs(); end

  def dependency_api_available?(); end

  def fetch_gem_if_possible(spec, previous_spec=T.unsafe(nil)); end

  def multiple_remotes?(); end

  def no_remotes?(); end

  def package_path(cache_path, spec); end

  def remote_fetchers(); end

  def remote_names(); end

  def remotes=(remotes); end

  def to_gemfile(); end
end

class Bundler::Source::RubygemsAggregate
  def identifier(); end

  def initialize(sources, source_map); end

  def source_map(); end

  def sources(); end

  def specs(); end
end

class Bundler::Source::RubygemsAggregate
end

class Bundler::SourceList
  def add_global_rubygems_remote(uri); end

  def aggregate_global_source?(); end

  def expired_sources?(replacement_sources); end

  def global_path_source(); end

  def implicit_global_source?(); end

  def local!(); end

  def local_mode?(); end

  def local_only!(); end

  def lock_other_sources(); end

  def lock_rubygems_sources(); end

  def merged_gem_lockfile_sections!(replacement_source); end

  def merged_gem_lockfile_sections?(); end

  def non_default_explicit_sources(); end

  def non_global_rubygems_sources(); end
end

class Bundler::SourceMap
  def all_requirements(); end

  def dependencies(); end

  def direct_requirements(); end

  def initialize(sources, dependencies, locked_specs); end

  def locked_requirements(); end

  def locked_specs(); end

  def pinned_spec_names(skip=T.unsafe(nil)); end

  def sources(); end
end

class Bundler::SourceMap
end

class Bundler::SpecSet
  include ::Enumerable
  include ::Bundler::TSort
  def -(other); end

  def add_extra_platforms!(platforms); end

  def complete_platforms!(platforms); end

  def delete(specs); end

  def delete_by_name(name); end

  def incomplete_for_platform?(deps, platform); end

  def incomplete_specs(); end

  def missing_specs(); end

  def names(); end

  def validate_deps(s); end
end

class Bundler::StubSpecification
  def checksum(); end

  def extensions(); end

  def full_gem_path=(path); end

  def gem_build_complete_path(); end

  def manually_installed?(); end
end

module Bundler::TSort
  def each_strongly_connected_component(&block); end

  def each_strongly_connected_component_from(node, id_map=T.unsafe(nil), stack=T.unsafe(nil), &block); end

  def strongly_connected_components(); end

  def tsort(); end

  def tsort_each(&block); end

  def tsort_each_child(node); end

  def tsort_each_node(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::TSort::Cyclic
end

class Bundler::TSort::Cyclic
end

module Bundler::TSort
  def self.each_strongly_connected_component(each_node, each_child); end

  def self.each_strongly_connected_component_from(node, each_child, id_map=T.unsafe(nil), stack=T.unsafe(nil)); end

  def self.strongly_connected_components(each_node, each_child); end

  def self.tsort(each_node, each_child); end

  def self.tsort_each(each_node, each_child); end
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Actions::CapturableERB
end

class Bundler::Thor::Actions::CapturableERB
end

module Bundler::Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Bundler::Thor::Actions::ClassMethods
end

class Bundler::Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Bundler::Thor::Actions::CreateFile
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Bundler::Thor::Actions::Directory
end

class Bundler::Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Bundler::Thor::Actions::EmptyDirectory
end

class Bundler::Thor::Actions::InjectIntoFile
  def behavior(); end

  def content(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def replacement_present?(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Bundler::Thor::Actions::InjectIntoFile
end

module Bundler::Thor::Actions
  def self.included(base); end
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def enum_to_s(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def print_default(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

class Bundler::Thor::AtLeastOneRequiredArgumentError
end

class Bundler::Thor::AtLeastOneRequiredArgumentError
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, wrap_long_description, usage, options=T.unsafe(nil), options_relation=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def method_at_least_one_option_names(); end

  def method_exclusive_option_names(); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def except(*keys); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def reverse_merge!(other_hash); end

  def slice(*keys); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

module Bundler::Thor::Correctable
  def corrections(); end

  def to_s(); end
end

module Bundler::Thor::Correctable
end

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::ExclusiveArgumentError
end

class Bundler::Thor::ExclusiveArgumentError
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*arg); end

  def self.printable_tasks(*arg); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::Option
  def aliases(); end

  def aliases_for_usage(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_at_least_one!(); end

  def check_exclusive!(); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil), relations=T.unsafe(nil)); end

  def names_to_switch_names(names=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end

  def unshift(arg, is_value: T.unsafe(nil)); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_error(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  include ::Bundler::Thor::Correctable
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  include ::Bundler::Thor::Correctable
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  def self.at_least_one(*args, &block); end

  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.exclusive(*args, &block); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_at_least_one(*args, &block); end

  def self.method_at_least_one_option_names(); end

  def self.method_exclusive(*args, &block); end

  def self.method_exclusive_option_names(); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.print_at_least_one_required_options(shell, command=T.unsafe(nil)); end

  def self.print_exclusive_options(shell, command=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.sort_commands!(list); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg=T.unsafe(nil), newline=T.unsafe(nil)); end

  def confirm?(); end

  def debug(msg=T.unsafe(nil), newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg=T.unsafe(nil), newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def error?(); end

  def info(msg=T.unsafe(nil), newline=T.unsafe(nil)); end

  def info?(); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg=T.unsafe(nil), newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def warn?(); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

class Bundler::UI::Silent
  def confirm?(); end

  def error?(); end

  def info?(); end

  def warn?(); end
end

module Bundler::URINormalizer
end

module Bundler::URINormalizer
  def self.normalize_suffix(uri, trailing_slash: T.unsafe(nil)); end
end

module Bundler
  def self.auto_install(); end

  def self.auto_switch(); end

  def self.configure_gem_home_and_path(path=T.unsafe(nil)); end

  def self.create_bundle_path(); end

  def self.gem_version(); end

  def self.most_specific_locked_platform?(platform); end

  def self.original_exec(*args); end

  def self.preferred_gemfile_name(); end

  def self.reset_settings_and_root!(); end

  def self.safe_load_marshal(data); end

  def self.self_manager(); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end
end

class Class
  def json_creatable?(); end
end

class Delegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

module DidYouMean::Correctable
  def corrections(); end

  def detailed_message(highlight: T.unsafe(nil), did_you_mean: T.unsafe(nil), **arg); end

  def original_message(); end

  def spell_checker(); end
end

class DidYouMean::Formatter
  def message_for(corrections); end
end

class DidYouMean::Formatter
  def self.message_for(corrections); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def names_to_exclude(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*arg); end
end

class DidYouMean::PatternKeyNameChecker
  def corrections(); end

  def initialize(no_matching_pattern_key_error); end
end

class DidYouMean::PatternKeyNameChecker
end

DidYouMean::PlainFormatter = DidYouMean::Formatter

class DidYouMean::RequirePathChecker
  def corrections(); end

  def initialize(exception); end

  def path(); end
end

class DidYouMean::RequirePathChecker
  def self.requireables(); end
end

class DidYouMean::TreeSpellChecker
  def augment(); end

  def correct(input); end

  def dictionary(); end

  def dictionary_without_leaves(); end

  def dimensions(); end

  def find_leaves(path); end

  def initialize(dictionary:, separator: T.unsafe(nil), augment: T.unsafe(nil)); end

  def plausible_dimensions(input); end

  def possible_paths(states); end

  def separator(); end

  def tree_depth(); end
end

class DidYouMean::TreeSpellChecker
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.correct_error(error_class, spell_checker); end

  def self.formatter(); end

  def self.formatter=(formatter); end

  def self.spell_checkers(); end
end

module Digest
  VERSION = ::T.let(nil, ::T.untyped)
end

class Dir
  def chdir(); end

  def children(); end

  def each_child(); end
end

module Dir::Tmpname
  UNUSABLE_CHARS = ::T.let(nil, ::T.untyped)
end

class Dir
  def self.fchdir(arg); end

  def self.for_fd(arg); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end
end

class Encoding
  def _dump(*arg); end
end

class Encoding::Converter
  def initialize(*arg); end
  LF_NEWLINE_DECORATOR = ::T.let(nil, ::T.untyped)
end

class Encoding
  def self._load(arg); end
end

module Enumerable
  def compact(); end
end

class Enumerator
  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*arg); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Generator
  def each(*arg, &blk); end

  def initialize(*arg); end
end

class Enumerator::Producer
  def each(&blk); end
end

class Enumerator::Producer
end

class Enumerator::Product
  def each(&blk); end
end

class Enumerator::Product
end

class Enumerator
  def self.product(*arg); end
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADARCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADARCH
end

class Errno::EBADEXEC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADEXEC
end

class Errno::EBADMACHO
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADMACHO
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDEVERR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EDEVERR
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ELAST
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ELAST
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOPOLICY
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOPOLICY
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPWROFF
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPWROFF
end

Errno::EQFULL = Errno::ELAST

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHLIBVERS
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ESHLIBVERS
end

module ErrorHighlight::CoreExt
  def detailed_message(highlight: T.unsafe(nil), error_highlight: T.unsafe(nil), **arg); end
end

module Etc
  VERSION = ::T.let(nil, ::T.untyped)
end

class Etc::Group
  def gid=(_); end

  def mem=(_); end

  def name=(_); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*arg); end

  def self.each(&blk); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*arg); end

  def self.each(&blk); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ExitCalledError
end

class ExitCalledError
end

class Fiber
  def backtrace(*arg); end

  def backtrace_locations(*arg); end

  def blocking?(); end

  def initialize(*arg); end

  def kill(); end

  def storage(); end

  def storage=(storage); end

  def transfer(*arg); end
end

class Fiber
  def self.blocking(); end

  def self.blocking?(); end

  def self.current(); end

  def self.current_scheduler(); end

  def self.schedule(*arg); end

  def self.scheduler(); end

  def self.set_scheduler(arg); end
end

class File
  def self.absolute_path?(arg); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
  def self.ln_sr(src, dest, target_directory: T.unsafe(nil), force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
end

module GC
  def garbage_collect(full_mark: T.unsafe(nil), immediate_mark: T.unsafe(nil), immediate_sweep: T.unsafe(nil)); end
end

module GC
  def self.latest_compact_info(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  HAVE_OPENSSL = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
end

module Gem::BUNDLED_GEMS
  def self.build_message(gem); end

  def self.find_gem(path); end

  def self.replace_require(specs); end

  def self.warning?(name, specs: T.unsafe(nil)); end
end

class Gem::BasicSpecification
  def base_dir_priority(gem_path); end

  def default_gem_priority(); end

  def full_name_with_location(); end

  def plugins(); end
end

module Gem::BetterPermissionError
  def data(); end
end

module Gem::BetterPermissionError
end

module Gem::BundlerVersionFinder
  def self.prioritize!(specs); end
end

module Gem::CIDetector
  ENV_DESCRIPTORS = ::T.let(nil, ::T.untyped)
  ENV_INDICATORS = ::T.let(nil, ::T.untyped)
end

module Gem::CIDetector
  def self.ci?(); end

  def self.ci_strings(); end
end

class Gem::ConfigFile
  def ipv4_fallback_enabled(); end

  def ipv4_fallback_enabled=(ipv4_fallback_enabled); end

  def last_update_check(); end

  def last_update_check=(timestamp); end

  def state_file_name(); end

  def state_file_writable?(); end
  DEFAULT_IPV4_FALLBACK_ENABLED = ::T.let(nil, ::T.untyped)
end

class Gem::ConfigFile
  def self.dump_with_rubygems_yaml(content); end

  def self.load_with_rubygems_config_hash(yaml); end
end

class Gem::Dependency
  include ::Bundler::ForcePlatform
  def force_ruby_platform(); end
end

class Gem::DependencyList
  include ::Gem::TSort
end

module Gem::Deprecate
  def deprecate(name, repl, year, month); end
end

module Gem::Deprecate
  def self.next_rubygems_major_version(); end

  def self.rubygems_deprecate(name, replacement=T.unsafe(nil)); end

  def self.rubygems_deprecate_command(version=T.unsafe(nil)); end
end

class Gem::Installer
  include ::Gem::InstallerUninstallerUtils
  def ensure_writable_dir(dir); end

  def explicit_version_requirement(name); end

  def gemdeps_load(name); end

  def generate_plugins(); end
end

class Gem::Installer::ExtensionBuildError
end

class Gem::Installer::ExtensionBuildError
end

class Gem::Installer::FakePackage
  def copy_to(path); end

  def data_mode(); end

  def data_mode=(data_mode); end

  def dir_mode(); end

  def dir_mode=(dir_mode); end

  def extract_files(destination_dir, pattern=T.unsafe(nil)); end

  def initialize(spec); end

  def prog_mode(); end

  def prog_mode=(prog_mode); end

  def spec(); end

  def spec=(spec); end
end

class Gem::Installer::FakePackage
end

class Gem::Installer
  def self.inherited(klass); end
end

module Gem::InstallerUninstallerUtils
  def regenerate_plugins_for(spec, plugins_dir); end

  def remove_plugins_for(spec, plugins_dir); end
end

module Gem::InstallerUninstallerUtils
end

class Gem::Licenses
  DEPRECATED_EXCEPTION_IDENTIFIERS = ::T.let(nil, ::T.untyped)
  DEPRECATED_EXCEPTION_REGEXP = ::T.let(nil, ::T.untyped)
  DEPRECATED_LICENSE_IDENTIFIERS = ::T.let(nil, ::T.untyped)
  DEPRECATED_LICENSE_REGEXP = ::T.let(nil, ::T.untyped)
  LICENSE_REF = ::T.let(nil, ::T.untyped)
  VALID_REGEXP = ::T.let(nil, ::T.untyped)
end

class Gem::Licenses
  def self.deprecated_exception_id?(license); end

  def self.deprecated_license_id?(license); end
end

module Gem::Molinillo
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Molinillo::CircularDependencyError
  def dependencies(); end

  def initialize(vertices); end
end

class Gem::Molinillo::CircularDependencyError
end

module Gem::Molinillo::Delegates
end

module Gem::Molinillo::Delegates::ResolutionState
  def activated(); end

  def conflicts(); end

  def depth(); end

  def name(); end

  def possibilities(); end

  def requirement(); end

  def requirements(); end

  def unused_unwind_options(); end
end

module Gem::Molinillo::Delegates::ResolutionState
end

module Gem::Molinillo::Delegates::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_equal?(dependencies, other_dependencies); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Gem::Molinillo::Delegates::SpecificationProvider
end

module Gem::Molinillo::Delegates
end

class Gem::Molinillo::DependencyGraph
  include ::Enumerable
  include ::Gem::TSort
  def ==(other); end

  def add_child_vertex(name, payload, parent_names, requirement); end

  def add_edge(origin, destination, requirement); end

  def add_vertex(name, payload, root=T.unsafe(nil)); end

  def delete_edge(edge); end

  def detach_vertex_named(name); end

  def each(&blk); end

  def log(); end

  def rewind_to(tag); end

  def root_vertex_named(name); end

  def set_payload(name, payload); end

  def tag(tag); end

  def to_dot(options=T.unsafe(nil)); end

  def tsort_each_child(vertex, &block); end

  def vertex_named(name); end

  def vertices(); end
end

class Gem::Molinillo::DependencyGraph::Action
  def down(graph); end

  def next(); end

  def next=(arg); end

  def previous(); end

  def previous=(previous); end

  def up(graph); end
end

class Gem::Molinillo::DependencyGraph::Action
  def self.action_name(); end
end

class Gem::Molinillo::DependencyGraph::AddEdgeNoCircular
  def destination(); end

  def initialize(origin, destination, requirement); end

  def make_edge(graph); end

  def origin(); end

  def requirement(); end
end

class Gem::Molinillo::DependencyGraph::AddEdgeNoCircular
end

class Gem::Molinillo::DependencyGraph::AddVertex
  def initialize(name, payload, root); end

  def name(); end

  def payload(); end

  def root(); end
end

class Gem::Molinillo::DependencyGraph::AddVertex
end

class Gem::Molinillo::DependencyGraph::DeleteEdge
  def destination_name(); end

  def initialize(origin_name, destination_name, requirement); end

  def make_edge(graph); end

  def origin_name(); end

  def requirement(); end
end

class Gem::Molinillo::DependencyGraph::DeleteEdge
end

class Gem::Molinillo::DependencyGraph::DetachVertexNamed
  def initialize(name); end

  def name(); end
end

class Gem::Molinillo::DependencyGraph::DetachVertexNamed
end

class Gem::Molinillo::DependencyGraph::Edge
  def destination(); end

  def destination=(_); end

  def origin(); end

  def origin=(_); end

  def requirement(); end

  def requirement=(_); end
end

class Gem::Molinillo::DependencyGraph::Edge
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Gem::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::Molinillo::DependencyGraph::SetPayload
  def initialize(name, payload); end

  def name(); end

  def payload(); end
end

class Gem::Molinillo::DependencyGraph::SetPayload
end

class Gem::Molinillo::DependencyGraph::Tag
  def initialize(tag); end

  def tag(); end
end

class Gem::Molinillo::DependencyGraph::Tag
end

class Gem::Molinillo::DependencyGraph::Vertex
  def ==(other); end

  def _path_to?(other, visited=T.unsafe(nil)); end

  def _recursive_predecessors(vertices=T.unsafe(nil)); end

  def _recursive_successors(vertices=T.unsafe(nil)); end

  def ancestor?(other); end

  def descendent?(other); end

  def eql?(other); end

  def explicit_requirements(); end

  def incoming_edges(); end

  def incoming_edges=(incoming_edges); end

  def initialize(name, payload); end

  def is_reachable_from?(other); end

  def name(); end

  def name=(name); end

  def outgoing_edges(); end

  def outgoing_edges=(outgoing_edges); end

  def path_to?(other); end

  def payload(); end

  def payload=(payload); end

  def predecessors(); end

  def recursive_predecessors(); end

  def recursive_successors(); end

  def requirements(); end

  def root(); end

  def root=(root); end

  def root?(); end

  def shallow_eql?(other); end

  def successors(); end
end

class Gem::Molinillo::DependencyGraph::Vertex
end

class Gem::Molinillo::DependencyGraph
  def self.tsort(vertices); end
end

class Gem::Molinillo::DependencyState
  def pop_possibility_state(); end
end

class Gem::Molinillo::DependencyState
end

class Gem::Molinillo::NoSuchDependencyError
  def dependency(); end

  def dependency=(dependency); end

  def initialize(dependency, required_by=T.unsafe(nil)); end

  def required_by(); end

  def required_by=(required_by); end
end

class Gem::Molinillo::NoSuchDependencyError
end

class Gem::Molinillo::PossibilityState
end

class Gem::Molinillo::PossibilityState
end

class Gem::Molinillo::ResolutionState
  def activated(); end

  def activated=(_); end

  def conflicts(); end

  def conflicts=(_); end

  def depth(); end

  def depth=(_); end

  def name(); end

  def name=(_); end

  def possibilities(); end

  def possibilities=(_); end

  def requirement(); end

  def requirement=(_); end

  def requirements(); end

  def requirements=(_); end

  def unused_unwind_options(); end

  def unused_unwind_options=(_); end
end

class Gem::Molinillo::ResolutionState
  def self.[](*arg); end

  def self.empty(); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Gem::Molinillo::Resolver
  def initialize(specification_provider, resolver_ui); end

  def resolve(requested, base=T.unsafe(nil)); end

  def resolver_ui(); end

  def specification_provider(); end
end

class Gem::Molinillo::Resolver::Resolution
  include ::Gem::Molinillo::Delegates::ResolutionState
  include ::Gem::Molinillo::Delegates::SpecificationProvider
  def base(); end

  def initialize(specification_provider, resolver_ui, requested, base); end

  def iteration_rate=(iteration_rate); end

  def original_requested(); end

  def resolve(); end

  def resolver_ui(); end

  def specification_provider(); end

  def started_at=(started_at); end

  def states=(states); end
end

class Gem::Molinillo::Resolver::Resolution::Conflict
  def activated_by_name(); end

  def activated_by_name=(_); end

  def existing(); end

  def existing=(_); end

  def locked_requirement(); end

  def locked_requirement=(_); end

  def possibility(); end

  def possibility_set(); end

  def possibility_set=(_); end

  def requirement(); end

  def requirement=(_); end

  def requirement_trees(); end

  def requirement_trees=(_); end

  def requirements(); end

  def requirements=(_); end

  def underlying_error(); end

  def underlying_error=(_); end
end

class Gem::Molinillo::Resolver::Resolution::Conflict
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Gem::Molinillo::Resolver::Resolution::PossibilitySet
  def dependencies(); end

  def dependencies=(_); end

  def latest_version(); end

  def possibilities(); end

  def possibilities=(_); end
end

class Gem::Molinillo::Resolver::Resolution::PossibilitySet
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Gem::Molinillo::Resolver::Resolution::UnwindDetails
  include ::Comparable
  def all_requirements(); end

  def conflicting_requirements(); end

  def conflicting_requirements=(_); end

  def requirement_tree(); end

  def requirement_tree=(_); end

  def requirement_trees(); end

  def requirement_trees=(_); end

  def requirements_unwound_to_instead(); end

  def requirements_unwound_to_instead=(_); end

  def reversed_requirement_tree_index(); end

  def state_index(); end

  def state_index=(_); end

  def state_requirement(); end

  def state_requirement=(_); end

  def sub_dependencies_to_avoid(); end

  def unwinding_to_primary_requirement?(); end
end

class Gem::Molinillo::Resolver::Resolution::UnwindDetails
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Gem::Molinillo::Resolver::Resolution
end

class Gem::Molinillo::Resolver
end

class Gem::Molinillo::ResolverError
end

class Gem::Molinillo::ResolverError
end

module Gem::Molinillo::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_equal?(dependencies, other_dependencies); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Gem::Molinillo::SpecificationProvider
end

module Gem::Molinillo::UI
  def after_resolution(); end

  def before_resolution(); end

  def debug(depth=T.unsafe(nil)); end

  def debug?(); end

  def indicate_progress(); end

  def output(); end

  def progress_rate(); end
end

module Gem::Molinillo::UI
end

class Gem::Molinillo::VersionConflict
  include ::Gem::Molinillo::Delegates::SpecificationProvider
  def conflicts(); end

  def initialize(conflicts, specification_provider); end

  def message_with_trees(opts=T.unsafe(nil)); end

  def specification_provider(); end
end

class Gem::Molinillo::VersionConflict
end

module Gem::Molinillo
end

class Gem::NameTuple
  def lock_name(); end
end

module Gem::Net
end

class Gem::Net::BufferedIO
  def <<(*strs); end

  def close(); end

  def closed?(); end

  def continue_timeout(); end

  def continue_timeout=(continue_timeout); end

  def debug_output(); end

  def debug_output=(debug_output); end

  def eof?(); end

  def initialize(io, read_timeout: T.unsafe(nil), write_timeout: T.unsafe(nil), continue_timeout: T.unsafe(nil), debug_output: T.unsafe(nil)); end

  def io(); end

  def read(len, dest=T.unsafe(nil), ignore_eof=T.unsafe(nil)); end

  def read_all(dest=T.unsafe(nil)); end

  def read_timeout(); end

  def read_timeout=(read_timeout); end

  def readline(); end

  def readuntil(terminator, ignore_eof=T.unsafe(nil)); end

  def write(*strs); end

  def write_timeout(); end

  def write_timeout=(write_timeout); end

  def writeline(str); end
  BUFSIZE = ::T.let(nil, ::T.untyped)
end

class Gem::Net::BufferedIO
end

class Gem::Net::HTTP
  def active?(); end

  def address(); end

  def ca_file(); end

  def ca_file=(ca_file); end

  def ca_path(); end

  def ca_path=(ca_path); end

  def cert(); end

  def cert=(cert); end

  def cert_store(); end

  def cert_store=(cert_store); end

  def ciphers(); end

  def ciphers=(ciphers); end

  def close_on_empty_response(); end

  def close_on_empty_response=(close_on_empty_response); end

  def continue_timeout(); end

  def continue_timeout=(sec); end

  def copy(path, initheader=T.unsafe(nil)); end

  def delete(path, initheader=T.unsafe(nil)); end

  def extra_chain_cert(); end

  def extra_chain_cert=(extra_chain_cert); end

  def finish(); end

  def get(path, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  def get2(path, initheader=T.unsafe(nil), &block); end

  def head(path, initheader=T.unsafe(nil)); end

  def head2(path, initheader=T.unsafe(nil), &block); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def initialize(address, port=T.unsafe(nil)); end

  def ipaddr(); end

  def ipaddr=(addr); end

  def keep_alive_timeout(); end

  def keep_alive_timeout=(keep_alive_timeout); end

  def key(); end

  def key=(key); end

  def local_host(); end

  def local_host=(local_host); end

  def local_port(); end

  def local_port=(local_port); end

  def lock(path, body, initheader=T.unsafe(nil)); end

  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def mkcol(path, body=T.unsafe(nil), initheader=T.unsafe(nil)); end

  def move(path, initheader=T.unsafe(nil)); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def options(path, initheader=T.unsafe(nil)); end

  def patch(path, data, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  def peer_cert(); end

  def port(); end

  def post(path, data, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  def post2(path, data, initheader=T.unsafe(nil), &block); end

  def propfind(path, body=T.unsafe(nil), initheader=T.unsafe(nil)); end

  def proppatch(path, body, initheader=T.unsafe(nil)); end

  def proxy?(); end

  def proxy_address(); end

  def proxy_address=(proxy_address); end

  def proxy_from_env=(proxy_from_env); end

  def proxy_from_env?(); end

  def proxy_pass(); end

  def proxy_pass=(proxy_pass); end

  def proxy_port(); end

  def proxy_port=(proxy_port); end

  def proxy_uri(); end

  def proxy_user(); end

  def proxy_user=(proxy_user); end

  def proxyaddr(); end

  def proxyport(); end

  def put(path, data, initheader=T.unsafe(nil)); end

  def put2(path, data, initheader=T.unsafe(nil), &block); end

  def read_timeout(); end

  def read_timeout=(sec); end

  def request(req, body=T.unsafe(nil), &block); end

  def request_get(path, initheader=T.unsafe(nil), &block); end

  def request_head(path, initheader=T.unsafe(nil), &block); end

  def request_post(path, data, initheader=T.unsafe(nil), &block); end

  def request_put(path, data, initheader=T.unsafe(nil), &block); end

  def response_body_encoding(); end

  def response_body_encoding=(value); end

  def send_request(name, path, data=T.unsafe(nil), header=T.unsafe(nil)); end

  def set_debug_output(output); end

  def ssl_timeout(); end

  def ssl_timeout=(ssl_timeout); end

  def ssl_version(); end

  def ssl_version=(ssl_version); end

  def start(); end

  def started?(); end

  def trace(path, initheader=T.unsafe(nil)); end

  def unlock(path, body, initheader=T.unsafe(nil)); end

  def use_ssl=(flag); end

  def use_ssl?(); end

  def verify_callback(); end

  def verify_callback=(verify_callback); end

  def verify_depth(); end

  def verify_depth=(verify_depth); end

  def verify_hostname(); end

  def verify_hostname=(verify_hostname); end

  def verify_mode(); end

  def verify_mode=(verify_mode); end

  def write_timeout(); end

  def write_timeout=(sec); end
  HAVE_ZLIB = ::T.let(nil, ::T.untyped)
  HTTPVersion = ::T.let(nil, ::T.untyped)
  IDEMPOTENT_METHODS_ = ::T.let(nil, ::T.untyped)
  SSL_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SSL_IVNAMES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Copy
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Copy
end

class Gem::Net::HTTP::Delete
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Delete
end

class Gem::Net::HTTP::Get
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Get
end

class Gem::Net::HTTP::Head
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Head
end

class Gem::Net::HTTP::Lock
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Lock
end

class Gem::Net::HTTP::Mkcol
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Mkcol
end

class Gem::Net::HTTP::Move
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Move
end

class Gem::Net::HTTP::Options
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Options
end

class Gem::Net::HTTP::Patch
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Patch
end

class Gem::Net::HTTP::Persistent
  def ca_file(); end

  def ca_file=(file); end

  def ca_path(); end

  def ca_path=(path); end

  def cert(); end

  def cert=(certificate); end

  def cert_store(); end

  def cert_store=(store); end

  def certificate(); end

  def certificate=(certificate); end

  def ciphers(); end

  def ciphers=(ciphers); end

  def connection_for(uri); end

  def debug_output(); end

  def debug_output=(debug_output); end

  def escape(str); end

  def expired?(connection); end

  def finish(connection); end

  def generation(); end

  def headers(); end

  def http_version(uri); end

  def http_versions(); end

  def idle_timeout(); end

  def idle_timeout=(idle_timeout); end

  def initialize(name: T.unsafe(nil), proxy: T.unsafe(nil), pool_size: T.unsafe(nil)); end

  def keep_alive(); end

  def keep_alive=(keep_alive); end

  def key(); end

  def key=(key); end

  def max_requests(); end

  def max_requests=(max_requests); end

  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def name(); end

  def no_proxy(); end

  def normalize_uri(uri); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def override_headers(); end

  def pool(); end

  def private_key(); end

  def private_key=(key); end

  def proxy=(proxy); end

  def proxy_bypass?(host, port); end

  def proxy_from_env(); end

  def proxy_uri(); end

  def read_timeout(); end

  def read_timeout=(read_timeout); end

  def reconnect(); end

  def reconnect_ssl(); end

  def request(uri, req=T.unsafe(nil), &block); end

  def request_setup(req_or_uri); end

  def reset(connection); end

  def reuse_ssl_sessions(); end

  def reuse_ssl_sessions=(reuse_ssl_sessions); end

  def shutdown(); end

  def socket_options(); end

  def ssl(connection); end

  def ssl_generation(); end

  def ssl_timeout(); end

  def ssl_timeout=(ssl_timeout); end

  def ssl_version(); end

  def ssl_version=(ssl_version); end

  def start(http); end

  def timeout_key(); end

  def unescape(str); end

  def verify_callback(); end

  def verify_callback=(callback); end

  def verify_depth(); end

  def verify_depth=(verify_depth); end

  def verify_mode(); end

  def verify_mode=(verify_mode); end

  def write_timeout(); end

  def write_timeout=(write_timeout); end
  DEFAULT_POOL_SIZE = ::T.let(nil, ::T.untyped)
  EPOCH = ::T.let(nil, ::T.untyped)
  HAVE_OPENSSL = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Persistent::Connection
  def close(); end

  def finish(); end

  def http(); end

  def http=(http); end

  def initialize(http_class, http_args, ssl_generation); end

  def last_use(); end

  def last_use=(last_use); end

  def requests(); end

  def requests=(requests); end

  def reset(); end

  def ressl(ssl_generation); end

  def ssl_generation(); end

  def ssl_generation=(ssl_generation); end
end

class Gem::Net::HTTP::Persistent::Connection
end

class Gem::Net::HTTP::Persistent::Error
end

class Gem::Net::HTTP::Persistent::Error
end

class Gem::Net::HTTP::Persistent::Pool
  def checkin(net_http_args); end

  def checkout(net_http_args); end

  def key(); end

  def shutdown(); end
end

class Gem::Net::HTTP::Persistent::Pool
end

class Gem::Net::HTTP::Persistent::TimedStackMulti
end

class Gem::Net::HTTP::Persistent::TimedStackMulti
  def self.hash_of_arrays(); end
end

class Gem::Net::HTTP::Persistent
  def self.detect_idle_timeout(uri, max=T.unsafe(nil)); end
end

class Gem::Net::HTTP::Post
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Post
end

class Gem::Net::HTTP::Propfind
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Propfind
end

class Gem::Net::HTTP::Proppatch
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Proppatch
end

module Gem::Net::HTTP::ProxyDelta
end

module Gem::Net::HTTP::ProxyDelta
end

class Gem::Net::HTTP::Put
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Put
end

class Gem::Net::HTTP::Trace
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Trace
end

class Gem::Net::HTTP::Unlock
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Unlock
end

class Gem::Net::HTTP
  def self.Proxy(p_addr=T.unsafe(nil), p_port=T.unsafe(nil), p_user=T.unsafe(nil), p_pass=T.unsafe(nil)); end

  def self.default_port(); end

  def self.get(uri_or_host, path_or_headers=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.get_print(uri_or_host, path_or_headers=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.get_response(uri_or_host, path_or_headers=T.unsafe(nil), port=T.unsafe(nil), &block); end

  def self.http_default_port(); end

  def self.https_default_port(); end

  def self.is_version_1_1?(); end

  def self.is_version_1_2?(); end

  def self.new(address, port=T.unsafe(nil), p_addr=T.unsafe(nil), p_port=T.unsafe(nil), p_user=T.unsafe(nil), p_pass=T.unsafe(nil), p_no_proxy=T.unsafe(nil)); end

  def self.newobj(*arg, **arg1); end

  def self.post(url, data, header=T.unsafe(nil)); end

  def self.post_form(url, params); end

  def self.proxy_address(); end

  def self.proxy_class?(); end

  def self.proxy_pass(); end

  def self.proxy_port(); end

  def self.proxy_user(); end

  def self.socket_type(); end

  def self.start(address, *arg, &block); end

  def self.version_1_1?(); end

  def self.version_1_2(); end

  def self.version_1_2?(); end
end

class Gem::Net::HTTPAccepted
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPAccepted
end

class Gem::Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPAlreadyReported
end

class Gem::Net::HTTPBadGateway
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPBadGateway
end

class Gem::Net::HTTPBadRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPBadRequest
end

class Gem::Net::HTTPBadResponse
end

class Gem::Net::HTTPBadResponse
end

class Gem::Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPClientError::EXCEPTION_TYPE = Gem::Net::HTTPClientException

class Gem::Net::HTTPClientError
end

Gem::Net::HTTPClientErrorCode = Gem::Net::HTTPClientError

class Gem::Net::HTTPClientException
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPClientException
end

class Gem::Net::HTTPConflict
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPConflict
end

class Gem::Net::HTTPContinue
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPContinue
end

class Gem::Net::HTTPCreated
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPCreated
end

class Gem::Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPEarlyHints
end

class Gem::Net::HTTPError
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPError
end

module Gem::Net::HTTPExceptions
  def data(); end

  def initialize(msg, res); end

  def response(); end
end

module Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPExpectationFailed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPExpectationFailed
end

class Gem::Net::HTTPFailedDependency
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPFailedDependency
end

class Gem::Net::HTTPFatalError
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPFatalError
end

Gem::Net::HTTPFatalErrorCode = Gem::Net::HTTPClientError

class Gem::Net::HTTPForbidden
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPForbidden
end

class Gem::Net::HTTPFound
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPFound
end

Gem::Net::HTTPGatewayTimeOut = Gem::Net::HTTPGatewayTimeout

class Gem::Net::HTTPGatewayTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPGatewayTimeout
end

class Gem::Net::HTTPGenericRequest
  include ::Gem::Net::HTTPHeader
  def body(); end

  def body=(str); end

  def body_exist?(); end

  def body_stream(); end

  def body_stream=(input); end

  def decode_content(); end

  def exec(sock, ver, path); end

  def initialize(m, reqbody, resbody, uri_or_path, initheader=T.unsafe(nil)); end

  def method(); end

  def path(); end

  def request_body_permitted?(); end

  def response_body_permitted?(); end

  def set_body_internal(str); end

  def update_uri(addr, port, ssl); end

  def uri(); end
end

class Gem::Net::HTTPGenericRequest::Chunker
  def finish(); end

  def initialize(sock); end

  def write(buf); end
end

class Gem::Net::HTTPGenericRequest::Chunker
end

class Gem::Net::HTTPGenericRequest
end

class Gem::Net::HTTPGone
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPGone
end

module Gem::Net::HTTPHeader
  def [](key); end

  def []=(key, val); end

  def add_field(key, val); end

  def basic_auth(account, password); end

  def canonical_each(); end

  def chunked?(); end

  def connection_close?(); end

  def connection_keep_alive?(); end

  def content_length(); end

  def content_length=(len); end

  def content_range(); end

  def content_type(); end

  def content_type=(type, params=T.unsafe(nil)); end

  def delete(key); end

  def each(&blk); end

  def each_capitalized(); end

  def each_capitalized_name(); end

  def each_header(); end

  def each_key(&block); end

  def each_name(&block); end

  def each_value(); end

  def fetch(key, *args, &block); end

  def form_data=(params, sep=T.unsafe(nil)); end

  def get_fields(key); end

  def initialize_http_header(initheader); end

  def key?(key); end

  def length(); end

  def main_type(); end

  def proxy_basic_auth(account, password); end

  def range(); end

  def range=(r, e=T.unsafe(nil)); end

  def range_length(); end

  def set_content_type(type, params=T.unsafe(nil)); end

  def set_form(params, enctype=T.unsafe(nil), formopt=T.unsafe(nil)); end

  def set_form_data(params, sep=T.unsafe(nil)); end

  def set_range(r, e=T.unsafe(nil)); end

  def size(); end

  def sub_type(); end

  def to_hash(); end

  def type_params(); end
  MAX_FIELD_LENGTH = ::T.let(nil, ::T.untyped)
  MAX_KEY_LENGTH = ::T.let(nil, ::T.untyped)
end

module Gem::Net::HTTPHeader
end

class Gem::Net::HTTPHeaderSyntaxError
end

class Gem::Net::HTTPHeaderSyntaxError
end

class Gem::Net::HTTPIMUsed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPIMUsed
end

class Gem::Net::HTTPInformation
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPInformation
end

class Gem::Net::HTTPInformation
end

Gem::Net::HTTPInformationCode::EXCEPTION_TYPE = Gem::Net::HTTPError

class Gem::Net::HTTPInformation
end

class Gem::Net::HTTPInsufficientStorage
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPInsufficientStorage
end

class Gem::Net::HTTPInternalServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPInternalServerError
end

class Gem::Net::HTTPLengthRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPLengthRequired
end

class Gem::Net::HTTPLocked
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPLocked
end

class Gem::Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPLoopDetected
end

class Gem::Net::HTTPMethodNotAllowed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMethodNotAllowed
end

class Gem::Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMisdirectedRequest
end

class Gem::Net::HTTPMovedPermanently
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMovedPermanently
end

Gem::Net::HTTPMovedTemporarily = Gem::Net::HTTPFound

class Gem::Net::HTTPMultiStatus
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMultiStatus
end

Gem::Net::HTTPMultipleChoice = Gem::Net::HTTPMultipleChoices

class Gem::Net::HTTPMultipleChoices
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMultipleChoices
end

class Gem::Net::HTTPNetworkAuthenticationRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNetworkAuthenticationRequired
end

class Gem::Net::HTTPNoContent
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNoContent
end

class Gem::Net::HTTPNonAuthoritativeInformation
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNonAuthoritativeInformation
end

class Gem::Net::HTTPNotAcceptable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotAcceptable
end

class Gem::Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotExtended
end

class Gem::Net::HTTPNotFound
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotFound
end

class Gem::Net::HTTPNotImplemented
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotImplemented
end

class Gem::Net::HTTPNotModified
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotModified
end

class Gem::Net::HTTPOK
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPOK
end

class Gem::Net::HTTPPartialContent
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPartialContent
end

class Gem::Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPayloadTooLarge
end

class Gem::Net::HTTPPaymentRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPaymentRequired
end

class Gem::Net::HTTPPermanentRedirect
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPermanentRedirect
end

class Gem::Net::HTTPPreconditionFailed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPreconditionFailed
end

class Gem::Net::HTTPPreconditionRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPreconditionRequired
end

class Gem::Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPProcessing
end

class Gem::Net::HTTPProxyAuthenticationRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPProxyAuthenticationRequired
end

class Gem::Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPRangeNotSatisfiable
end

class Gem::Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPRedirection::EXCEPTION_TYPE = Gem::Net::HTTPRetriableError

class Gem::Net::HTTPRedirection
end

Gem::Net::HTTPRedirectionCode = Gem::Net::HTTPRedirection

class Gem::Net::HTTPRequest
  def initialize(path, initheader=T.unsafe(nil)); end
end

class Gem::Net::HTTPRequest
end

Gem::Net::HTTPRequestEntityTooLarge = Gem::Net::HTTPPayloadTooLarge

class Gem::Net::HTTPRequestHeaderFieldsTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPRequestHeaderFieldsTooLarge
end

Gem::Net::HTTPRequestTimeOut = Gem::Net::HTTPRequestTimeout

class Gem::Net::HTTPRequestTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPRequestTimeout
end

Gem::Net::HTTPRequestURITooLarge = Gem::Net::HTTPURITooLong

Gem::Net::HTTPRequestURITooLong = Gem::Net::HTTPURITooLong

Gem::Net::HTTPRequestedRangeNotSatisfiable = Gem::Net::HTTPRangeNotSatisfiable

class Gem::Net::HTTPResetContent
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPResetContent
end

Gem::Net::HTTPResponceReceiver = Gem::Net::HTTPResponse

class Gem::Net::HTTPResponse
  include ::Gem::Net::HTTPHeader
  def body(); end

  def body=(value); end

  def body_encoding(); end

  def body_encoding=(value); end

  def code(); end

  def code_type(); end

  def decode_content(); end

  def decode_content=(decode_content); end

  def entity(); end

  def error!(); end

  def error_type(); end

  def header(); end

  def http_version(); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def initialize(httpv, code, msg); end

  def message(); end

  def msg(); end

  def read_body(dest=T.unsafe(nil), &block); end

  def read_header(); end

  def reading_body(sock, reqmethodallowbody); end

  def response(); end

  def uri(); end

  def uri=(uri); end

  def value(); end
  CODE_CLASS_TO_OBJ = ::T.let(nil, ::T.untyped)
  CODE_TO_OBJ = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPResponse::Inflater
  def bytes_inflated(); end

  def finish(); end

  def inflate_adapter(dest); end

  def initialize(socket); end

  def read(clen, dest, ignore_eof=T.unsafe(nil)); end

  def read_all(dest); end
end

class Gem::Net::HTTPResponse::Inflater
end

class Gem::Net::HTTPResponse
  def self.body_permitted?(); end

  def self.exception_type(); end

  def self.read_new(sock); end
end

Gem::Net::HTTPResponseReceiver = Gem::Net::HTTPResponse

Gem::Net::HTTPRetriableCode = Gem::Net::HTTPRedirection

class Gem::Net::HTTPRetriableError
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPRetriableError
end

class Gem::Net::HTTPSeeOther
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPSeeOther
end

class Gem::Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPServerError::EXCEPTION_TYPE = Gem::Net::HTTPFatalError

class Gem::Net::HTTPServerError
end

Gem::Net::HTTPServerErrorCode = Gem::Net::HTTPServerError

Gem::Net::HTTPServerException = Gem::Net::HTTPClientException

class Gem::Net::HTTPServiceUnavailable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPServiceUnavailable
end

Gem::Net::HTTPSession = Gem::Net::HTTP

class Gem::Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPSuccess::EXCEPTION_TYPE = Gem::Net::HTTPError

class Gem::Net::HTTPSuccess
end

Gem::Net::HTTPSuccessCode = Gem::Net::HTTPSuccess

class Gem::Net::HTTPSwitchProtocol
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPSwitchProtocol
end

class Gem::Net::HTTPTemporaryRedirect
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPTemporaryRedirect
end

class Gem::Net::HTTPTooManyRequests
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPTooManyRequests
end

class Gem::Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPURITooLong
end

class Gem::Net::HTTPUnauthorized
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnauthorized
end

class Gem::Net::HTTPUnavailableForLegalReasons
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnavailableForLegalReasons
end

class Gem::Net::HTTPUnknownResponse
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPUnknownResponse::EXCEPTION_TYPE = Gem::Net::HTTPError

class Gem::Net::HTTPUnknownResponse
end

class Gem::Net::HTTPUnprocessableEntity
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnprocessableEntity
end

class Gem::Net::HTTPUnsupportedMediaType
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnsupportedMediaType
end

class Gem::Net::HTTPUpgradeRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUpgradeRequired
end

class Gem::Net::HTTPUseProxy
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUseProxy
end

class Gem::Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPVariantAlsoNegotiates
end

class Gem::Net::HTTPVersionNotSupported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPVersionNotSupported
end

class Gem::Net::InternetMessageIO
  def each_list_item(); end

  def each_message_chunk(); end

  def initialize(*arg, **arg1); end

  def write_message(src); end

  def write_message_0(src); end

  def write_message_by_block(&block); end
end

class Gem::Net::InternetMessageIO
end

module Gem::Net::NetPrivate
end

Gem::Net::NetPrivate::HTTPRequest = Gem::Net::HTTPRequest

Gem::Net::NetPrivate::Socket = Gem::Net::InternetMessageIO

module Gem::Net::NetPrivate
end

class Gem::Net::OpenTimeout
end

class Gem::Net::OpenTimeout
end

class Gem::Net::ProtoAuthError
end

class Gem::Net::ProtoAuthError
end

class Gem::Net::ProtoCommandError
end

class Gem::Net::ProtoCommandError
end

class Gem::Net::ProtoFatalError
end

class Gem::Net::ProtoFatalError
end

class Gem::Net::ProtoRetriableError
end

class Gem::Net::ProtoRetriableError
end

class Gem::Net::ProtoServerError
end

class Gem::Net::ProtoServerError
end

class Gem::Net::ProtoSyntaxError
end

class Gem::Net::ProtoSyntaxError
end

class Gem::Net::ProtoUnknownError
end

class Gem::Net::ProtoUnknownError
end

Gem::Net::ProtocRetryError = Gem::Net::ProtoRetriableError

class Gem::Net::Protocol
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Net::Protocol
  def self.protocol_param(name, val); end
end

class Gem::Net::ProtocolError
end

class Gem::Net::ProtocolError
end

class Gem::Net::ReadAdapter
  def <<(str); end

  def initialize(block); end
end

class Gem::Net::ReadAdapter
end

class Gem::Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Gem::Net::ReadTimeout
end

class Gem::Net::WriteAdapter
  def <<(str); end

  def initialize(writer); end

  def print(str); end

  def printf(*args); end

  def puts(str=T.unsafe(nil)); end

  def write(str); end
end

class Gem::Net::WriteAdapter
end

class Gem::Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Gem::Net::WriteTimeout
end

module Gem::Net
end

class Gem::Package
  def copy_stream(src, dst); end

  def gem(); end

  def limit_read(io, name, limit); end
end

class Gem::Package::DigestIO
  def digests(); end

  def initialize(io, digests); end

  def write(data); end
end

class Gem::Package::DigestIO
  def self.wrap(io, digests); end
end

class Gem::Package::FileSource
  def initialize(path); end

  def path(); end

  def present?(); end

  def start(); end

  def with_read_io(&block); end

  def with_write_io(&block); end
end

class Gem::Package::FileSource
end

class Gem::Package::IOSource
  def initialize(io); end

  def io(); end

  def path(); end

  def present?(); end

  def start(); end

  def with_read_io(); end

  def with_write_io(); end
end

class Gem::Package::IOSource
end

class Gem::Package::Old
  def extract_files(destination_dir); end

  def file_list(io); end

  def read_until_dashes(io); end

  def skip_ruby(io); end
end

class Gem::Package::Old
end

class Gem::Package::Source
end

class Gem::Package::Source
end

class Gem::Package::SymlinkError
  def initialize(name, destination, destination_dir); end
end

class Gem::Package::SymlinkError
end

class Gem::Package::TarHeader
  def ==(other); end

  def checksum(); end

  def devmajor(); end

  def devminor(); end

  def empty?(); end

  def gid(); end

  def gname(); end

  def initialize(vals); end

  def linkname(); end

  def magic(); end

  def mode(); end

  def mtime(); end

  def name(); end

  def prefix(); end

  def size(); end

  def typeflag(); end

  def uid(); end

  def uname(); end

  def update_checksum(); end

  def version(); end
  EMPTY_HEADER = ::T.let(nil, ::T.untyped)
  FIELDS = ::T.let(nil, ::T.untyped)
  PACK_FORMAT = ::T.let(nil, ::T.untyped)
  UNPACK_FORMAT = ::T.let(nil, ::T.untyped)
end

class Gem::Package::TarHeader
  def self.from(stream); end

  def self.oct_or_256based(str); end

  def self.strict_oct(str); end
end

class Gem::Package::TarReader::Entry
  def check_closed(); end
end

class Gem::Package::TarReader
  def self.new(io); end
end

class Gem::Package::TarWriter
  def self.new(io); end
end

class Gem::Package
  def self.new(gem, security_policy=T.unsafe(nil)); end

  def self.raw_spec(path, security_policy=T.unsafe(nil)); end
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::Platform
  def normalized_linux_version(); end

  def normalized_linux_version_ext(); end
  WINDOWS = ::T.let(nil, ::T.untyped)
  X64_LINUX = ::T.let(nil, ::T.untyped)
  X64_LINUX_MUSL = ::T.let(nil, ::T.untyped)
end

class Gem::Platform
  def self._deprecated_match(platform); end

  def self.match_gem?(platform, gem_name); end

  def self.match_spec?(spec); end

  def self.sort_priority(platform); end
end

class Gem::RequestSet
  include ::Gem::TSort
end

class Gem::RequestSet::Lockfile::Tokenizer::Token
  def self.keyword_init?(); end
end

class Gem::Requirement
  def _sorted_requirements(); end
end

class Gem::Resolv
  def each_address(name); end

  def each_name(address); end

  def getaddress(name); end

  def getaddresses(name); end

  def getname(address); end

  def getnames(address); end

  def initialize(resolvers=T.unsafe(nil), use_ipv6: T.unsafe(nil)); end
  AddressRegex = ::T.let(nil, ::T.untyped)
  DefaultResolver = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS
  def close(); end

  def each_address(name); end

  def each_name(address); end

  def each_resource(name, typeclass, &proc); end

  def extract_resources(msg, name, typeclass); end

  def fetch_resource(name, typeclass); end

  def getaddress(name); end

  def getaddresses(name); end

  def getname(address); end

  def getnames(address); end

  def getresource(name, typeclass); end

  def getresources(name, typeclass); end

  def initialize(config_info=T.unsafe(nil)); end

  def lazy_initialize(); end

  def make_tcp_requester(host, port); end

  def make_udp_requester(); end

  def timeouts=(values); end
  Port = ::T.let(nil, ::T.untyped)
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
  UDPSize = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Config
  def generate_candidates(name); end

  def generate_timeouts(); end

  def initialize(config_info=T.unsafe(nil)); end

  def lazy_initialize(); end

  def nameserver_port(); end

  def resolv(name); end

  def single?(); end

  def timeouts=(values); end

  def use_ipv6?(); end
  InitialTimeout = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Config::NXDomain
end

class Gem::Resolv::DNS::Config::NXDomain
end

class Gem::Resolv::DNS::Config::OtherResolvError
end

class Gem::Resolv::DNS::Config::OtherResolvError
end

class Gem::Resolv::DNS::Config
  def self.default_config_hash(filename=T.unsafe(nil)); end

  def self.parse_resolv_conf(filename); end
end

class Gem::Resolv::DNS::DecodeError
end

class Gem::Resolv::DNS::DecodeError
end

class Gem::Resolv::DNS::EncodeError
end

class Gem::Resolv::DNS::EncodeError
end

module Gem::Resolv::DNS::Label
end

class Gem::Resolv::DNS::Label::Str
  def ==(other); end

  def downcase(); end

  def eql?(other); end

  def initialize(string); end

  def string(); end
end

class Gem::Resolv::DNS::Label::Str
end

module Gem::Resolv::DNS::Label
  def self.split(arg); end
end

class Gem::Resolv::DNS::Message
  def ==(other); end

  def aa(); end

  def aa=(aa); end

  def add_additional(name, ttl, data); end

  def add_answer(name, ttl, data); end

  def add_authority(name, ttl, data); end

  def add_question(name, typeclass); end

  def additional(); end

  def answer(); end

  def authority(); end

  def each_additional(); end

  def each_answer(); end

  def each_authority(); end

  def each_question(); end

  def each_resource(); end

  def encode(); end

  def id(); end

  def id=(id); end

  def initialize(id=T.unsafe(nil)); end

  def opcode(); end

  def opcode=(opcode); end

  def qr(); end

  def qr=(qr); end

  def question(); end

  def ra(); end

  def ra=(ra); end

  def rcode(); end

  def rcode=(rcode); end

  def rd(); end

  def rd=(rd); end

  def tc(); end

  def tc=(tc); end
end

class Gem::Resolv::DNS::Message::MessageDecoder
  def get_bytes(len=T.unsafe(nil)); end

  def get_label(); end

  def get_labels(); end

  def get_length16(); end

  def get_list(); end

  def get_name(); end

  def get_question(); end

  def get_rr(); end

  def get_string(); end

  def get_string_list(); end

  def get_unpack(template); end

  def initialize(data); end
end

class Gem::Resolv::DNS::Message::MessageDecoder
end

class Gem::Resolv::DNS::Message::MessageEncoder
  def put_bytes(d); end

  def put_label(d); end

  def put_labels(d, compress: T.unsafe(nil)); end

  def put_length16(); end

  def put_name(d, compress: T.unsafe(nil)); end

  def put_pack(template, *d); end

  def put_string(d); end

  def put_string_list(ds); end
end

class Gem::Resolv::DNS::Message::MessageEncoder
end

class Gem::Resolv::DNS::Message
  def self.decode(m); end
end

class Gem::Resolv::DNS::Name
  def ==(other); end

  def [](i); end

  def absolute?(); end

  def eql?(other); end

  def initialize(labels, absolute=T.unsafe(nil)); end

  def length(); end

  def subdomain_of?(other); end

  def to_a(); end
end

class Gem::Resolv::DNS::Name
  def self.create(arg); end
end

module Gem::Resolv::DNS::OpCode
  IQuery = ::T.let(nil, ::T.untyped)
  Notify = ::T.let(nil, ::T.untyped)
  Query = ::T.let(nil, ::T.untyped)
  Status = ::T.let(nil, ::T.untyped)
  Update = ::T.let(nil, ::T.untyped)
end

module Gem::Resolv::DNS::OpCode
end

class Gem::Resolv::DNS::Query
  def encode_rdata(msg); end
end

class Gem::Resolv::DNS::Query
  def self.decode_rdata(msg); end
end

module Gem::Resolv::DNS::RCode
  BADALG = ::T.let(nil, ::T.untyped)
  BADKEY = ::T.let(nil, ::T.untyped)
  BADMODE = ::T.let(nil, ::T.untyped)
  BADNAME = ::T.let(nil, ::T.untyped)
  BADSIG = ::T.let(nil, ::T.untyped)
  BADTIME = ::T.let(nil, ::T.untyped)
  BADVERS = ::T.let(nil, ::T.untyped)
  FormErr = ::T.let(nil, ::T.untyped)
  NXDomain = ::T.let(nil, ::T.untyped)
  NXRRSet = ::T.let(nil, ::T.untyped)
  NoError = ::T.let(nil, ::T.untyped)
  NotAuth = ::T.let(nil, ::T.untyped)
  NotImp = ::T.let(nil, ::T.untyped)
  NotZone = ::T.let(nil, ::T.untyped)
  Refused = ::T.let(nil, ::T.untyped)
  ServFail = ::T.let(nil, ::T.untyped)
  YXDomain = ::T.let(nil, ::T.untyped)
  YXRRSet = ::T.let(nil, ::T.untyped)
end

module Gem::Resolv::DNS::RCode
end

class Gem::Resolv::DNS::Requester
  def close(); end

  def request(sender, tout); end

  def sender_for(addr, msg); end
end

class Gem::Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::Requester::ConnectedUDP::Sender
  def data(); end

  def send(); end
end

class Gem::Resolv::DNS::Requester::ConnectedUDP::Sender
end

class Gem::Resolv::DNS::Requester::ConnectedUDP
end

class Gem::Resolv::DNS::Requester::MDNSOneShot
end

class Gem::Resolv::DNS::Requester::MDNSOneShot
end

class Gem::Resolv::DNS::Requester::RequestError
end

class Gem::Resolv::DNS::Requester::RequestError
end

class Gem::Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Gem::Resolv::DNS::Requester::Sender
end

class Gem::Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::Requester::TCP::Sender
  def data(); end

  def send(); end
end

class Gem::Resolv::DNS::Requester::TCP::Sender
end

class Gem::Resolv::DNS::Requester::TCP
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host, port=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP::Sender
  def data(); end

  def initialize(msg, data, sock, host, port); end

  def send(); end
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP::Sender
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP
end

class Gem::Resolv::DNS::Requester
end

class Gem::Resolv::DNS::Resource
  def ==(other); end

  def eql?(other); end

  def ttl(); end
  ClassHash = ::T.let(nil, ::T.untyped)
  ClassInsensitiveTypes = ::T.let(nil, ::T.untyped)
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::ANY
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::ANY
end

class Gem::Resolv::DNS::Resource::CNAME
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::CNAME
end

class Gem::Resolv::DNS::Resource::DomainName
  def initialize(name); end

  def name(); end
end

class Gem::Resolv::DNS::Resource::DomainName
end

class Gem::Resolv::DNS::Resource::Generic
  def data(); end

  def initialize(data); end
end

class Gem::Resolv::DNS::Resource::Generic
  def self.create(type_value, class_value); end
end

class Gem::Resolv::DNS::Resource::HINFO
  def cpu(); end

  def initialize(cpu, os); end

  def os(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::HINFO
end

module Gem::Resolv::DNS::Resource::IN
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::A
  def address(); end

  def initialize(address); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::A
end

class Gem::Resolv::DNS::Resource::IN::AAAA
  def address(); end

  def initialize(address); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::AAAA
end

class Gem::Resolv::DNS::Resource::IN::ANY
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::ANY
end

class Gem::Resolv::DNS::Resource::IN::CNAME
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::CNAME
end

class Gem::Resolv::DNS::Resource::IN::HINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::HINFO
end

class Gem::Resolv::DNS::Resource::IN::HTTPS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::HTTPS
end

class Gem::Resolv::DNS::Resource::IN::LOC
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::LOC
end

class Gem::Resolv::DNS::Resource::IN::MINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::MINFO
end

class Gem::Resolv::DNS::Resource::IN::MX
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::MX
end

class Gem::Resolv::DNS::Resource::IN::NS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::NS
end

class Gem::Resolv::DNS::Resource::IN::PTR
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::PTR
end

class Gem::Resolv::DNS::Resource::IN::SOA
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::SOA
end

class Gem::Resolv::DNS::Resource::IN::SRV
  def initialize(priority, weight, port, target); end

  def port(); end

  def priority(); end

  def target(); end

  def weight(); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::SRV
end

class Gem::Resolv::DNS::Resource::IN::SVCB
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::SVCB
end

class Gem::Resolv::DNS::Resource::IN::ServiceBinding
  def alias_mode?(); end

  def encode_rdata(msg); end

  def initialize(priority, target, params=T.unsafe(nil)); end

  def params(); end

  def priority(); end

  def service_mode?(); end

  def target(); end
end

class Gem::Resolv::DNS::Resource::IN::ServiceBinding
  def self.decode_rdata(msg); end
end

class Gem::Resolv::DNS::Resource::IN::TXT
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::TXT
end

class Gem::Resolv::DNS::Resource::IN::WKS
  def address(); end

  def bitmap(); end

  def initialize(address, protocol, bitmap); end

  def protocol(); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::WKS
end

module Gem::Resolv::DNS::Resource::IN
end

class Gem::Resolv::DNS::Resource::LOC
  def altitude(); end

  def hprecision(); end

  def initialize(version, ssize, hprecision, vprecision, latitude, longitude, altitude); end

  def latitude(); end

  def longitude(); end

  def ssize(); end

  def version(); end

  def vprecision(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::LOC
end

class Gem::Resolv::DNS::Resource::MINFO
  def emailbx(); end

  def initialize(rmailbx, emailbx); end

  def rmailbx(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::MINFO
end

class Gem::Resolv::DNS::Resource::MX
  def exchange(); end

  def initialize(preference, exchange); end

  def preference(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::MX
end

class Gem::Resolv::DNS::Resource::NS
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::NS
end

class Gem::Resolv::DNS::Resource::PTR
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::PTR
end

class Gem::Resolv::DNS::Resource::SOA
  def expire(); end

  def initialize(mname, rname, serial, refresh, retry_, expire, minimum); end

  def minimum(); end

  def mname(); end

  def refresh(); end

  def retry(); end

  def rname(); end

  def serial(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::SOA
end

class Gem::Resolv::DNS::Resource::TXT
  def data(); end

  def initialize(first_string, *rest_strings); end

  def strings(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::TXT
end

class Gem::Resolv::DNS::Resource
  def self.get_class(type_value, class_value); end
end

class Gem::Resolv::DNS::SvcParam
  ClassHash = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::ALPN
  def encode(msg); end

  def initialize(protocol_ids); end

  def protocol_ids(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::ALPN
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::DoHPath
  def encode(msg); end

  def initialize(template); end

  def template(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::DoHPath
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::Generic
  def encode(msg); end

  def initialize(value); end

  def value(); end
end

class Gem::Resolv::DNS::SvcParam::Generic
  def self.create(key_number); end

  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::IPv4Hint
  def addresses(); end

  def encode(msg); end

  def initialize(addresses); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::IPv4Hint
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::IPv6Hint
  def addresses(); end

  def encode(msg); end

  def initialize(addresses); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::IPv6Hint
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::Mandatory
  def encode(msg); end

  def initialize(keys); end

  def keys(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::Mandatory
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::NoDefaultALPN
  def encode(msg); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::NoDefaultALPN
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::Port
  def encode(msg); end

  def initialize(port); end

  def port(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::Port
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam
  def self.key_name(); end

  def self.key_number(); end
end

class Gem::Resolv::DNS::SvcParams
  include ::Enumerable
  def [](key); end

  def add(param); end

  def count(); end

  def delete(key); end

  def each(&block); end

  def empty?(); end

  def encode(msg); end

  def initialize(params=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::SvcParams
  def self.decode(msg); end
end

class Gem::Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.open(*args); end

  def self.random(arg); end
end

class Gem::Resolv::Hosts
  def each_address(name, &proc); end

  def each_name(address, &proc); end

  def getaddress(name); end

  def getaddresses(name); end

  def getname(address); end

  def getnames(address); end

  def initialize(filename=T.unsafe(nil)); end

  def lazy_initialize(); end
  DefaultFileName = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::Hosts
end

class Gem::Resolv::IPv4
  def ==(other); end

  def address(); end

  def eql?(other); end

  def initialize(address); end

  def to_name(); end
  Regex = ::T.let(nil, ::T.untyped)
  Regex256 = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::IPv4
  def self.create(arg); end
end

class Gem::Resolv::IPv6
  def ==(other); end

  def address(); end

  def eql?(other); end

  def initialize(address); end

  def to_name(); end
  Regex = ::T.let(nil, ::T.untyped)
  Regex_6Hex4Dec = ::T.let(nil, ::T.untyped)
  Regex_8Hex = ::T.let(nil, ::T.untyped)
  Regex_8HexLinkLocal = ::T.let(nil, ::T.untyped)
  Regex_CompressedHex = ::T.let(nil, ::T.untyped)
  Regex_CompressedHex4Dec = ::T.let(nil, ::T.untyped)
  Regex_CompressedHexLinkLocal = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::IPv6
  def self.create(arg); end
end

module Gem::Resolv::LOC
end

class Gem::Resolv::LOC::Alt
  def ==(other); end

  def altitude(); end

  def eql?(other); end

  def initialize(altitude); end
  Regex = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::LOC::Alt
  def self.create(arg); end
end

class Gem::Resolv::LOC::Coord
  def ==(other); end

  def coordinates(); end

  def eql?(other); end

  def initialize(coordinates, orientation); end

  def orientation(); end
  Regex = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::LOC::Coord
  def self.create(arg); end
end

class Gem::Resolv::LOC::Size
  def ==(other); end

  def eql?(other); end

  def initialize(scalar); end

  def scalar(); end
  Regex = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::LOC::Size
  def self.create(arg); end
end

module Gem::Resolv::LOC
end

class Gem::Resolv::MDNS
  AddressV4 = ::T.let(nil, ::T.untyped)
  AddressV6 = ::T.let(nil, ::T.untyped)
  Addresses = ::T.let(nil, ::T.untyped)
  Port = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::MDNS
end

class Gem::Resolv::ResolvError
end

class Gem::Resolv::ResolvError
end

class Gem::Resolv::ResolvTimeout
end

class Gem::Resolv::ResolvTimeout
end

class Gem::Resolv
  def self.each_address(name, &block); end

  def self.each_name(address, &proc); end

  def self.getaddress(name); end

  def self.getaddresses(name); end

  def self.getname(address); end

  def self.getnames(address); end
end

class Gem::Resolver
  include ::Gem::Molinillo::UI
  include ::Gem::Molinillo::SpecificationProvider
end

class Gem::Resolver::APISet::GemParser
  def parse(line); end
end

class Gem::Resolver::APISet::GemParser
end

class Gem::Resolver::APISpecification
  def self.new(set, api_data); end
end

class Gem::Resolver::ActivationRequest
  def eql?(other); end
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::IndexSpecification
  def ==(other); end
end

class Gem::Resolver::InstallerSet
  def force(); end

  def force=(force); end
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::Specification
  def required_ruby_version(); end

  def required_rubygems_version(); end
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

module Gem::Security
  DEFAULT_KEY_ALGORITHM = ::T.let(nil, ::T.untyped)
  EC_NAME = ::T.let(nil, ::T.untyped)
  RSA_DSA_KEY_LENGTH = ::T.let(nil, ::T.untyped)
end

class Gem::Security::Signer
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def digest_algorithm(); end

  def digest_name(); end

  def extract_name(cert); end

  def initialize(key, cert_chain, passphrase=T.unsafe(nil), options=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def load_cert_chain(); end

  def options(); end

  def re_sign_key(expiration_length: T.unsafe(nil)); end

  def sign(data); end
end

class Gem::Security::Signer
  def self.re_sign_cert(expired_cert, expired_cert_path, private_key); end
end

class Gem::Security::TrustDir
  def cert_path(certificate); end

  def dir(); end

  def each_certificate(); end

  def initialize(dir, permissions=T.unsafe(nil)); end

  def issuer_of(certificate); end

  def load_certificate(certificate_file); end

  def name_path(name); end

  def trust_cert(certificate); end

  def verify(); end
end

module Gem::Security
  def self.alt_name_or_x509_entry(certificate, x509_entry); end

  def self.create_cert(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_cert_email(email, key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.create_cert_self_signed(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_digest(algorithm=T.unsafe(nil)); end

  def self.create_key(algorithm); end

  def self.email_to_name(email_address); end

  def self.get_public_key(key); end

  def self.re_sign(expired_certificate, private_key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.reset(); end

  def self.sign(certificate, signing_key, signing_cert, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.trust_dir(); end

  def self.trusted_certificates(&block); end

  def self.write(pemmable, path, permissions=T.unsafe(nil), passphrase=T.unsafe(nil), cipher=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil), num_results=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::Specification
  include ::Bundler::MatchMetadata
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def _deprecated_validate_dependencies(); end

  def _deprecated_validate_metadata(); end

  def _deprecated_validate_permissions(); end

  def deleted_gem?(); end

  def flatten_require_paths(); end

  def removed_method_calls(); end

  def to_ruby(); end
  LATEST_RUBY_WITHOUT_PATCH_VERSIONS = ::T.let(nil, ::T.untyped)
  REMOVED_METHODS = ::T.let(nil, ::T.untyped)
end

class Gem::Specification
  extend ::Gem::Deprecate
  extend ::Enumerable
  def self.find_by_full_name(full_name); end

  def self.gemspec_stubs_in(dir, pattern); end

  def self.latest_spec_for(name); end

  def self.specification_record(); end

  def self.stubs_for_pattern(pattern, match_platform=T.unsafe(nil)); end
end

class Gem::SpecificationPolicy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def initialize(specification); end

  def packaging(); end

  def packaging=(packaging); end

  def validate(strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_duplicate_dependencies(); end

  def validate_metadata(); end

  def validate_optional(strict); end

  def validate_permissions(); end

  def validate_required!(); end

  def validate_required_ruby_version(); end
  HOMEPAGE_URI_PATTERN = ::T.let(nil, ::T.untyped)
  LAZY = ::T.let(nil, ::T.untyped)
  LAZY_PATTERN = ::T.let(nil, ::T.untyped)
  METADATA_LINK_KEYS = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  VALID_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  VALID_URI_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::SpecificationPolicy
end

class Gem::SpecificationRecord
  include ::Enumerable
  def add_spec(spec); end

  def all(); end

  def all=(specs); end

  def all_names(); end

  def each(&blk); end

  def find_active_stub_by_path(path); end

  def find_all_by_name(name, *requirements); end

  def find_by_path(path); end

  def find_inactive_by_path(path); end

  def initialize(dirs); end

  def latest_spec_for(name); end

  def latest_specs(prerelease); end

  def remove_spec(spec); end

  def stubs(); end

  def stubs_for(name); end

  def stubs_for_pattern(pattern, match_platform=T.unsafe(nil)); end
end

class Gem::SpecificationRecord
  def self.dirs_from(paths); end

  def self.from_path(path); end
end

class Gem::StubSpecification
  include ::Gem::BetterPermissionError
  def ==(other); end

  def build_extensions(); end

  def eql?(other); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def sort_obj(); end

  def spec(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

module Gem::TSort
  def each_strongly_connected_component(&block); end

  def each_strongly_connected_component_from(node, id_map=T.unsafe(nil), stack=T.unsafe(nil), &block); end

  def strongly_connected_components(); end

  def tsort(); end

  def tsort_each(&block); end

  def tsort_each_child(node); end

  def tsort_each_node(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::TSort::Cyclic
end

class Gem::TSort::Cyclic
end

module Gem::TSort
  def self.each_strongly_connected_component(each_node, each_child); end

  def self.each_strongly_connected_component_from(node, each_child, id_map=T.unsafe(nil), stack=T.unsafe(nil)); end

  def self.strongly_connected_components(each_node, each_child); end

  def self.tsort(each_node, each_child); end

  def self.tsort_each(each_node, each_child); end
end

module Gem::Timeout
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Timeout::Error
end

class Gem::Timeout::Error
  def self.handle_timeout(message); end
end

class Gem::Timeout::ExitException
  def exception(*arg); end
end

class Gem::Timeout::ExitException
end

module Gem::Timeout
  def self.ensure_timeout_thread_created(); end

  def self.timeout(sec, klass=T.unsafe(nil), message=T.unsafe(nil), &block); end
end

module Gem::URI
  include ::Gem::URI::RFC2396_REGEXP
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ABS_URI_REF = ::T.let(nil, ::T.untyped)
  DEFAULT_PARSER = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  OPAQUE = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  REL_URI_REF = ::T.let(nil, ::T.untyped)
  RFC3986_PARSER = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TBLDECWWWCOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCURICOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCWWWCOMP_ = ::T.let(nil, ::T.untyped)
  UNSAFE = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_CODE = ::T.let(nil, ::T.untyped)
  WEB_ENCODINGS_ = ::T.let(nil, ::T.untyped)
end

class Gem::URI::BadURIError
end

class Gem::URI::BadURIError
end

class Gem::URI::Error
end

class Gem::URI::Error
end

class Gem::URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  TYPECODE = ::T.let(nil, ::T.untyped)
  TYPECODE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Gem::URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class Gem::URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::File
end

class Gem::URI::Generic
  include ::Gem::URI
  include ::Gem::URI::RFC2396_REGEXP
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def decoded_password(); end

  def decoded_user(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def to_str(); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  USE_REGISTRY = ::T.let(nil, ::T.untyped)
end

class Gem::URI::Generic
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class Gem::URI::HTTP
  def authority(); end

  def origin(); end

  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::HTTP
end

class Gem::URI::HTTPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::HTTPS
end

class Gem::URI::InvalidComponentError
end

class Gem::URI::InvalidComponentError
end

class Gem::URI::InvalidURIError
end

class Gem::URI::InvalidURIError
end

class Gem::URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_BASE = ::T.let(nil, ::T.untyped)
  SCOPE_ONE = ::T.let(nil, ::T.untyped)
  SCOPE_SUB = ::T.let(nil, ::T.untyped)
end

class Gem::URI::LDAP
end

class Gem::URI::LDAPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::LDAPS
end

class Gem::URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EMAIL_REGEXP = ::T.let(nil, ::T.untyped)
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

class Gem::URI::MailTo
end

Gem::URI::Parser = Gem::URI::RFC2396_Parser

Gem::URI::REGEXP = Gem::URI::RFC2396_REGEXP

class Gem::URI::RFC2396_Parser
  include ::Gem::URI::RFC2396_REGEXP
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class Gem::URI::RFC2396_Parser
end

module Gem::URI::RFC2396_REGEXP
end

module Gem::URI::RFC2396_REGEXP::PATTERN
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ALNUM = ::T.let(nil, ::T.untyped)
  ALPHA = ::T.let(nil, ::T.untyped)
  DOMLABEL = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HEX = ::T.let(nil, ::T.untyped)
  HIER_PART = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  HOSTNAME = ::T.let(nil, ::T.untyped)
  HOSTPORT = ::T.let(nil, ::T.untyped)
  IPV4ADDR = ::T.let(nil, ::T.untyped)
  IPV6ADDR = ::T.let(nil, ::T.untyped)
  IPV6REF = ::T.let(nil, ::T.untyped)
  NET_PATH = ::T.let(nil, ::T.untyped)
  OPAQUE_PART = ::T.let(nil, ::T.untyped)
  PATH_SEGMENTS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REG_NAME = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_SEGMENT = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TOPLABEL = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  URIC = ::T.let(nil, ::T.untyped)
  URIC_NO_SLASH = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  X_ABS_URI = ::T.let(nil, ::T.untyped)
  X_REL_URI = ::T.let(nil, ::T.untyped)
end

module Gem::URI::RFC2396_REGEXP::PATTERN
end

module Gem::URI::RFC2396_REGEXP
end

class Gem::URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  RFC3986_URI = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  SEG = ::T.let(nil, ::T.untyped)
  SEG_NC = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
end

class Gem::URI::RFC3986_Parser
end

module Gem::URI::Util
end

module Gem::URI::Util
  def self.make_components_hash(klass, array_hash); end
end

class Gem::URI::WS
  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::WS
end

class Gem::URI::WSS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::WSS
end

module Gem::URI
  def self.decode_uri_component(str, enc=T.unsafe(nil)); end

  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.decode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.encode_uri_component(str, enc=T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.extract(str, schemes=T.unsafe(nil), &block); end

  def self.for(scheme, *arguments, default: T.unsafe(nil)); end

  def self.get_encoding(label); end

  def self.join(*str); end

  def self.parse(uri); end

  def self.regexp(schemes=T.unsafe(nil)); end

  def self.register_scheme(scheme, klass); end

  def self.scheme_list(); end

  def self.split(uri); end
end

class Gem::UninstallError
  def spec(); end

  def spec=(spec); end
end

class Gem::UninstallError
end

class Gem::UnknownCommandError
  def initialize(unknown_command); end

  def unknown_command(); end
end

class Gem::UnknownCommandError
  def self.attach_correctable(); end
end

class Gem::UnknownCommandSpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end
end

class Gem::UnknownCommandSpellChecker
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

module Gem::Util
  def self._deprecated_silent_system(*command); end
end

class Gem::Version
  def partition_segments(ver); end
end

Gem::Version::Requirement = Gem::Requirement

class Gem::WebauthnVerificationError
  def initialize(message); end
end

class Gem::WebauthnVerificationError
end

module Gem
  def self.URI(uri); end

  def self.activated_gem_paths(); end

  def self.cache_home(); end

  def self.config_home(); end

  def self.data_home(); end

  def self.default_user_install(); end

  def self.disable_system_update_message(); end

  def self.disable_system_update_message=(disable_system_update_message); end

  def self.discover_gems_on_require(); end

  def self.discover_gems_on_require=(discover_gems_on_require); end

  def self.dynamic_library_suffixes(); end

  def self.find_config_file(); end

  def self.find_default_spec(path); end

  def self.freebsd_platform?(); end

  def self.load_safe_marshal(); end

  def self.old_default_bindir(); end

  def self.old_default_dir(); end

  def self.old_default_path(); end

  def self.old_default_specifications_dir(); end

  def self.old_ruby(); end

  def self.open_file(path, flags, &block); end

  def self.plugin_suffix_pattern(); end

  def self.plugin_suffix_regexp(); end

  def self.plugindir(install_dir=T.unsafe(nil)); end

  def self.private_dir(); end

  def self.solaris_platform?(); end

  def self.state_file(); end

  def self.state_home(); end
end

class Hash
  def deconstruct_keys(arg); end
end

class Hash
  def self.ruby2_keywords_hash(arg); end

  def self.ruby2_keywords_hash?(arg); end
end

class IO
  def nonblock(*arg); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def path(); end

  def pathconf(arg); end

  def ready?(); end

  def timeout(); end

  def timeout=(timeout); end

  def to_path(); end

  def wait(*arg); end

  def wait_priority(*arg); end

  def wait_readable(*arg); end

  def wait_writable(*arg); end
  PRIORITY = ::T.let(nil, ::T.untyped)
  READABLE = ::T.let(nil, ::T.untyped)
  WRITABLE = ::T.let(nil, ::T.untyped)
end

class IO::Buffer
  include ::Comparable
  def &(arg); end

  def ^(arg); end

  def and!(arg); end

  def clear(*arg); end

  def copy(*arg); end

  def each(*arg, &blk); end

  def each_byte(*arg); end

  def empty?(); end

  def external?(); end

  def free(); end

  def get_string(*arg); end

  def get_value(arg, arg1); end

  def get_values(arg, arg1); end

  def hexdump(*arg); end

  def initialize(*arg); end

  def internal?(); end

  def locked(); end

  def locked?(); end

  def mapped?(); end

  def not!(); end

  def null?(); end

  def or!(arg); end

  def pread(*arg); end

  def private?(); end

  def pwrite(*arg); end

  def read(*arg); end

  def readonly?(); end

  def resize(arg); end

  def set_string(*arg); end

  def set_value(arg, arg1, arg2); end

  def set_values(arg, arg1, arg2); end

  def shared?(); end

  def size(); end

  def slice(*arg); end

  def transfer(); end

  def valid?(); end

  def values(*arg); end

  def write(*arg); end

  def xor!(arg); end

  def |(arg); end

  def ~(); end
  BIG_ENDIAN = ::T.let(nil, ::T.untyped)
  DEFAULT_SIZE = ::T.let(nil, ::T.untyped)
  EXTERNAL = ::T.let(nil, ::T.untyped)
  HOST_ENDIAN = ::T.let(nil, ::T.untyped)
  INTERNAL = ::T.let(nil, ::T.untyped)
  LITTLE_ENDIAN = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MAPPED = ::T.let(nil, ::T.untyped)
  NETWORK_ENDIAN = ::T.let(nil, ::T.untyped)
  PAGE_SIZE = ::T.let(nil, ::T.untyped)
  PRIVATE = ::T.let(nil, ::T.untyped)
  READONLY = ::T.let(nil, ::T.untyped)
  SHARED = ::T.let(nil, ::T.untyped)
end

class IO::Buffer::AccessError
end

class IO::Buffer::AccessError
end

class IO::Buffer::AllocationError
end

class IO::Buffer::AllocationError
end

class IO::Buffer::InvalidatedError
end

class IO::Buffer::InvalidatedError
end

class IO::Buffer::LockedError
end

class IO::Buffer::LockedError
end

class IO::Buffer::MaskError
end

class IO::Buffer::MaskError
end

class IO::Buffer
  def self.for(arg); end

  def self.map(*arg); end

  def self.size_of(arg); end

  def self.string(arg); end
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO::TimeoutError
end

class IO::TimeoutError
end

class IO
  def self.new(*arg); end
end

class IPAddr
  def ==(other); end

  def begin_addr(); end

  def end_addr(); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def netmask(); end

  def zone_id(); end

  def zone_id=(zid); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Integer
  def ceildiv(other); end

  def to_bn(); end
end

class Integer
  def self.try_convert(arg); end
end

class JSON::Ext::Generator::State
  def allow_nan=(allow_nan); end

  def ascii_only=(ascii_only); end

  def escape_slash(); end

  def escape_slash=(escape_slash); end

  def escape_slash?(); end

  def script_safe(); end

  def script_safe=(script_safe); end

  def script_safe?(); end

  def strict(); end

  def strict=(strict); end

  def strict?(); end
end

class JSON::Ext::Generator::State
  def self.from_state(arg); end

  def self.generate(arg, arg1); end
end

class JSON::Ext::Parser
  def initialize(*arg); end
end

class JSON::Ext::Parser
  def self.parse(arg, arg1); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module JSON
  def self.create_fast_state(); end

  def self.create_pretty_state(); end

  def self.unsafe_load(source, proc=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.unsafe_load_default_options(); end

  def self.unsafe_load_default_options=(unsafe_load_default_options); end
end

module Kernel
  def self.at_exit(); end

  def self.exit(*arg); end

  def self.no_warning_require(arg); end
end

class KeyError
  include ::DidYouMean::Correctable
end

class LoadError
  include ::DidYouMean::Correctable
end

class MatchData
  def deconstruct(); end

  def deconstruct_keys(arg); end

  def match(arg); end

  def match_length(arg); end
end

class Module
  def set_temporary_name(arg); end

  def undefined_instance_methods(); end
end

class Monitor
  def enter(); end

  def exit(); end

  def mon_check_owner(); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_enter(); end

  def try_mon_enter(); end

  def wait_for_cond(arg, arg1); end
end

module MonitorMixin
  def initialize(*arg, **arg1, &arg2); end
end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
end

class NameError
  include ::ErrorHighlight::CoreExt
  include ::DidYouMean::Correctable
end

class NilClass
  def =~(arg); end
end

class NoMatchingPatternKeyError
  include ::DidYouMean::Correctable
  def key(); end

  def matchee(); end
end

class Object
  include ::PP::ObjectMixin
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class ObjectSpace::WeakMap
  def delete(arg); end
end

module Opal
  CONST_NAME_REGEXP = ::T.let(nil, ::T.untyped)
  FORBIDDEN_CONST_NAME_CHARS = ::T.let(nil, ::T.untyped)
  FORBIDDEN_ENDING_IDENTIFIER_CHARS = ::T.let(nil, ::T.untyped)
  FORBIDDEN_STARTING_IDENTIFIER_CHARS = ::T.let(nil, ::T.untyped)
  INLINE_IDENTIFIER_REGEXP = ::T.let(nil, ::T.untyped)
  REGEXP_END = ::T.let(nil, ::T.untyped)
  REGEXP_START = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Opal::Compiler
  COMPARE = ::T.let(nil, ::T.untyped)
  INDENT = ::T.let(nil, ::T.untyped)
end

class Opal::ERB::Compiler
  BLOCK_EXPR = ::T.let(nil, ::T.untyped)
end

class Opal::EofContent
  DATA_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module Opal::MagicComments
  EMACS_MAGIC_COMMENT_RE = ::T.let(nil, ::T.untyped)
  MAGIC_COMMENT_RE = ::T.let(nil, ::T.untyped)
end

class Opal::Nodes::BeginNode
  COMPLEX_CHILDREN = ::T.let(nil, ::T.untyped)
end

class Opal::Nodes::CallNode
  OPERATORS = ::T.let(nil, ::T.untyped)
  SPECIALS = ::T.let(nil, ::T.untyped)
end

class Opal::Nodes::Closure
  ANY = ::T.let(nil, ::T.untyped)
  DEF = ::T.let(nil, ::T.untyped)
  ITER = ::T.let(nil, ::T.untyped)
  JS_FUNCTION = ::T.let(nil, ::T.untyped)
  JS_LOOP = ::T.let(nil, ::T.untyped)
  JS_LOOP_INSIDE = ::T.let(nil, ::T.untyped)
  LAMBDA = ::T.let(nil, ::T.untyped)
  LOOP = ::T.let(nil, ::T.untyped)
  LOOP_INSIDE = ::T.let(nil, ::T.untyped)
  MODULE = ::T.let(nil, ::T.untyped)
  NONE = ::T.let(nil, ::T.untyped)
  RESCUE_RETRIER = ::T.let(nil, ::T.untyped)
  SEND = ::T.let(nil, ::T.untyped)
  TOP = ::T.let(nil, ::T.untyped)
end

class Opal::Nodes::ConstNode
  OPTIMIZED_ACCESS_CONSTS = ::T.let(nil, ::T.untyped)
end

class Opal::Nodes::IfNode
  SWITCH_BRANCH_TEST_MATCH = ::T.let(nil, ::T.untyped)
  SWITCH_BRANCH_TEST_MATCH_CONTINUED = ::T.let(nil, ::T.untyped)
  SWITCH_TEST_MATCH = ::T.let(nil, ::T.untyped)
  SWITCH_TEST_MATCH_CONTINUED = ::T.let(nil, ::T.untyped)
end

class Opal::Nodes::MassAssignNode
  SIMPLE_ASSIGNMENT = ::T.let(nil, ::T.untyped)
end

class Opal::Nodes::RangeNode
  SIMPLE_CHILDREN_TYPES = ::T.let(nil, ::T.untyped)
end

class Opal::Nodes::RegexpNode
  SUPPORTED_FLAGS = ::T.let(nil, ::T.untyped)
end

class Opal::Nodes::StringNode
  ESCAPE_CHARS = ::T.let(nil, ::T.untyped)
  ESCAPE_REGEX = ::T.let(nil, ::T.untyped)
end

class Opal::PathReader
  DEFAULT_EXTENSIONS = ::T.let(nil, ::T.untyped)
  RELATIVE_PATH_REGEXP = ::T.let(nil, ::T.untyped)
end

class Opal::Rewriters::Base
  DUMMY_LOCATION = ::T.let(nil, ::T.untyped)
end

class Opal::Rewriters::BinaryOperatorAssignment
  ASSIGNMENT_STRING_NODE = ::T.let(nil, ::T.untyped)
  ClassVariableHandler = ::T.let(nil, ::T.untyped)
  ConstantHandler = ::T.let(nil, ::T.untyped)
  GET_SET = ::T.let(nil, ::T.untyped)
  GlobalVariableHandler = ::T.let(nil, ::T.untyped)
  HANDLERS = ::T.let(nil, ::T.untyped)
  InstanceVariableHandler = ::T.let(nil, ::T.untyped)
  LocalVariableHandler = ::T.let(nil, ::T.untyped)
end

class Opal::Rewriters::InlineArgs::Initializer
  STEPS = ::T.let(nil, ::T.untyped)
end

class Opal::Rewriters::JsReservedWords
  BASIC_IDENTIFIER_RULES = ::T.let(nil, ::T.untyped)
  ES3_RESERVED_WORD_EXCLUSIVE = ::T.let(nil, ::T.untyped)
  ES51_RESERVED_WORD = ::T.let(nil, ::T.untyped)
  IMMUTABLE_PROPS = ::T.let(nil, ::T.untyped)
  PROTO_SPECIAL_METHODS = ::T.let(nil, ::T.untyped)
  PROTO_SPECIAL_PROPS = ::T.let(nil, ::T.untyped)
  RESERVED_FUNCTION_NAMES = ::T.let(nil, ::T.untyped)
end

class Opal::Rewriters::LogicalOperatorAssignment
  ASSIGNMENT_STRING_NODE = ::T.let(nil, ::T.untyped)
  ClassVariableHandler = ::T.let(nil, ::T.untyped)
  ConstantHandler = ::T.let(nil, ::T.untyped)
  GET_SET = ::T.let(nil, ::T.untyped)
  GlobalVariableHandler = ::T.let(nil, ::T.untyped)
  HANDLERS = ::T.let(nil, ::T.untyped)
  InstanceVariableHandler = ::T.let(nil, ::T.untyped)
  LocalVariableHandler = ::T.let(nil, ::T.untyped)
end

class Opal::Rewriters::OpalEngineCheck
  RUBY_ENGINE_CHECK = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_CHECK_NOT = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM_CHECK = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM_CHECK_NOT = ::T.let(nil, ::T.untyped)
end

class Opal::SimpleServer
  def append_path(path); end

  def builder(path); end

  def cache_invalidator(); end

  def call(env); end

  def call_index(); end

  def call_js(path); end

  def fetch_asset(path); end

  def index_path(); end

  def index_path=(index_path); end

  def initialize(options=T.unsafe(nil)); end

  def javascript_include_tag(path); end

  def main(); end

  def main=(main); end
end

class Opal::SimpleServer::NotFound
end

class Opal::SimpleServer::NotFound
end

class Opal::SimpleServer
end

class Opal::SourceMap::File
  include ::Opal::SourceMap::Map
  def absolute_mappings(); end

  def file(); end

  def fragments(); end

  def generated_code(); end

  def initialize(fragments, file, source, generated_code=T.unsafe(nil)); end

  def map(source_root: T.unsafe(nil)); end

  def names(); end

  def relative_mappings(); end

  def segment_from_fragment(fragment, generated_column); end

  def source(); end
end

class Opal::SourceMap::File
end

class Opal::SourceMap::Index
  include ::Opal::SourceMap::Map
  def initialize(source_maps, join: T.unsafe(nil)); end

  def map(); end

  def source_maps(); end
end

class Opal::SourceMap::Index
end

module Opal::SourceMap::Map
  def as_json(*arg); end

  def cache(); end

  def marshal_dump(); end

  def marshal_load(value); end

  def to_data_uri_comment(); end

  def to_h(); end

  def to_json(); end

  def to_s(); end
end

module Opal::SourceMap::Map
end

module Opal::SourceMap::VLQ
  BASE64_DIGITS = ::T.let(nil, ::T.untyped)
  BASE64_VALUES = ::T.let(nil, ::T.untyped)
  VLQ_BASE = ::T.let(nil, ::T.untyped)
  VLQ_BASE_MASK = ::T.let(nil, ::T.untyped)
  VLQ_BASE_SHIFT = ::T.let(nil, ::T.untyped)
  VLQ_CONTINUATION_BIT = ::T.let(nil, ::T.untyped)
end

module Opal::SourceMap::VLQ
  def self.decode(str); end

  def self.decode_mappings(str); end

  def self.encode(ary); end

  def self.encode_mappings(ary); end
end

class OpenStruct
  def __id__!(); end

  def __send__!(*arg); end

  def at_exit!(&block); end

  def class!(); end

  def clone!(freeze: T.unsafe(nil)); end

  def define_singleton_method!(*arg); end

  def delete_field!(name, &block); end

  def dig!(name, *names); end

  def display!(*arg); end

  def dup!(); end

  def each_pair!(); end

  def encode_with(coder); end

  def encode_with!(coder); end

  def enum_for!(*arg); end

  def exit!(*arg); end

  def extend!(mod, *args); end

  def freeze!(); end

  def gem!(dep, *reqs); end

  def hash!(); end

  def init_with(coder); end

  def init_with!(coder); end

  def inspect!(); end

  def instance_eval!(*arg); end

  def instance_exec!(*arg); end

  def instance_variable_get!(arg); end

  def instance_variable_set!(arg, arg1); end

  def instance_variables!(); end

  def itself!(); end

  def marshal_dump!(); end

  def method!(arg); end

  def methods!(*arg); end

  def object_id!(); end

  def pretty_inspect!(); end

  def pretty_print!(q); end

  def pretty_print_cycle!(q); end

  def pretty_print_inspect!(); end

  def pretty_print_instance_variables!(); end

  def private_methods!(*arg); end

  def protected_methods!(*arg); end

  def public_method!(arg); end

  def public_methods!(*arg); end

  def public_send!(*arg); end

  def remove_instance_variable!(arg); end

  def send!(*arg); end

  def singleton_class!(); end

  def singleton_method!(arg); end

  def singleton_methods!(*arg); end

  def tap!(); end

  def then!(); end

  def to_enum!(*arg); end

  def to_h!(&block); end

  def to_json!(*arg); end

  def to_s!(); end

  def yield_self!(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class PP
  VERSION = ::T.let(nil, ::T.untyped)
end

class PP
  def self.width_for(out); end
end

class Paggio::CSS::Unit
  COMPATIBLE = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

ParseError = Racc::ParseError

module Parser
  MESSAGES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Parser::Context
  FLAGS = ::T.let(nil, ::T.untyped)
end

class Parser::Diagnostic
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer
  ESCAPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_BEGIN = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  PUNCTUATION = ::T.let(nil, ::T.untyped)
  PUNCTUATION_BEGIN = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
  TAB_WIDTH = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Literal
  DELIMITERS = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  TAB = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::LexerStrings
  ESCAPES = ::T.let(nil, ::T.untyped)
  ESCAPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  REGEXP_META_CHARACTERS = ::T.let(nil, ::T.untyped)
end

class Parser::MaxNumparamStack
  ORDINARY_PARAMS = ::T.let(nil, ::T.untyped)
end

module Parser::Meta
  NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Rewriter
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby24
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby32
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Buffer
  ENCODING_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Comment::Associator
  MAGIC_COMMENT_RE = ::T.let(nil, ::T.untyped)
  POSTFIX_TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Rewriter
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Source::TreeRewriter
  ACTIONS = ::T.let(nil, ::T.untyped)
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  POLICY_TO_LEVEL = ::T.let(nil, ::T.untyped)
end

class Parser::StaticEnvironment
  ANONYMOUS_BLOCKARG_INHERITED = ::T.let(nil, ::T.untyped)
  ANONYMOUS_BLOCKARG_IN_CURRENT_SCOPE = ::T.let(nil, ::T.untyped)
  ANONYMOUS_KWRESTARG_INHERITED = ::T.let(nil, ::T.untyped)
  ANONYMOUS_KWRESTARG_IN_CURRENT_SCOPE = ::T.let(nil, ::T.untyped)
  ANONYMOUS_RESTARG_INHERITED = ::T.let(nil, ::T.untyped)
  ANONYMOUS_RESTARG_IN_CURRENT_SCOPE = ::T.let(nil, ::T.untyped)
  FORWARD_ARGS = ::T.let(nil, ::T.untyped)
end

class Pathname
  def lutime(arg, arg1); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class PrettyPrint
  VERSION = ::T.let(nil, ::T.untyped)
end

class Proc
  def <<(arg); end

  def >>(arg); end

  def clone(); end
end

class Process::Status
  def self.wait(*arg); end
end

class Process::Tms
  def self.keyword_init?(); end
end

module Process
  def self.exit(*arg); end
end

module Racc
  Copyright = ::T.let(nil, ::T.untyped)
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

class Ractor::ClosedError
end

class Ractor::ClosedError
end

class Ractor::Error
end

class Ractor::Error
end

class Ractor::IsolationError
end

class Ractor::IsolationError
end

class Ractor::MovedError
end

class Ractor::MovedError
end

class Ractor::MovedObject
  def !(*arg); end

  def !=(*arg); end

  def ==(*arg); end

  def __id__(*arg); end

  def equal?(*arg); end
end

class Ractor::MovedObject
end

class Ractor::RemoteError
  def ractor(); end
end

class Ractor::RemoteError
end

class Ractor::UnsafeError
end

class Ractor::UnsafeError
end

class Ractor
  def self.new(*args, name: T.unsafe(nil), &block); end
end

class Random::Base
  include ::Random::Formatter
  def bytes(arg); end

  def initialize(*arg); end

  def seed(); end
end

class Random::Base
  extend ::Random::Formatter
end

module Random::Formatter
  def uuid_v4(); end

  def uuid_v7(extra_timestamp_bits: T.unsafe(nil)); end
end

class Random
  def self.bytes(arg); end

  def self.seed(); end
end

class Range
  def %(arg); end

  def entries(); end

  def reverse_each(); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end
end

class Refinement
  def target(); end
end

class Regexp
  def timeout(); end
end

class Regexp
  def self.linear_time?(*arg); end
end

class RubyVM::AbstractSyntaxTree::Node
  def all_tokens(); end

  def node_id(); end

  def pretty_print_children(q, names=T.unsafe(nil)); end

  def script_lines(); end

  def source(); end

  def tokens(); end
end

module RubyVM::AbstractSyntaxTree
  def self.node_id_for_backtrace_location(backtrace_location); end
end

class RubyVM::InstructionSequence
  def script_lines(); end
end

class RubyVM::InstructionSequence
  def self.compile_file_prism(*arg); end

  def self.compile_prism(*arg); end
end

module RubyVM::RJIT
end

module RubyVM::RJIT
  def self.enable(); end

  def self.enabled?(); end
end

module RubyVM::YJIT
  def self.disasm(iseq); end

  def self.exit_locations(); end

  def self.insns_compiled(iseq); end

  def self.simulate_oom!(); end

  def self.trace_exit_locations_enabled?(); end
end

class RubyVM
  def self.keep_script_lines(); end

  def self.keep_script_lines=(keep_script_lines); end
end

class Set
  def ==(other); end

  def ===(o); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class String
  def dedup(); end
end

class String
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
  def self.new(*arg); end
end

class StringIO
  def pread(*arg); end

  def set_encoding_by_bom(); end
  MAX_LENGTH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class StringIO
  def self.new(*arg); end
end

class Struct
  def deconstruct(); end

  def deconstruct_keys(arg); end

  def filter(*arg); end
end

class Struct
  def self.new(*arg); end
end

class SyntaxError
  def path(); end
end

module SyntaxSuggest
end

class SyntaxSuggest::MiniStringIO
  def initialize(isatty: T.unsafe(nil)); end

  def isatty(); end

  def puts(value=T.unsafe(nil), **arg); end

  def string(); end
end

class SyntaxSuggest::MiniStringIO
end

module SyntaxSuggest
  def self.module_for_detailed_message(); end
end

class Thread::Backtrace
  def self.limit(); end
end

class Thread
  def self.ignore_deadlock(); end

  def self.ignore_deadlock=(ignore_deadlock); end

  def self.new(*arg); end
end

class Time
  def deconstruct_keys(arg); end
end

class TracePoint
  def eval_script(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TracePoint
  def self.allow_reentry(); end

  def self.new(*events); end
end

class TypeError
  include ::ErrorHighlight::CoreExt
end

module UnicodeNormalize
end

module UnicodeNormalize
end

module Warning
  extend ::Warning
end

class Zlib::Deflate
  def initialize(*arg); end
end

class Zlib::GzipReader
  def initialize(*arg); end
end

class Zlib::GzipReader
  def self.zcat(*arg); end
end

class Zlib::GzipWriter
  def initialize(*arg); end
end

class Zlib::InProgressError
end

class Zlib::InProgressError
end

class Zlib::Inflate
  def initialize(*arg); end
end
